<!DOCTYPE html>
<html lang="en">
<head>
  <script src="localization-client.js"></script>
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';
    const SUPABASE_URL = 'https://tqdmrzcnnciatviwogpa.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRxZG1yemNubmNpYXR2aXdvZ3BhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYwMTM1MDcsImV4cCI6MjA3MTU4OTUwN30.I1D_7G9rshIHeA82VQ0Q-GD7oC3ovypkas7LG3FTDbo';
    window.supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true
      }
    });

    // Guest mode system
    window.initGuestMode = function initGuestMode() {
      let guestId = localStorage.getItem('guestId');
      if (!guestId) {
        // Generate anonymous guest ID
        guestId = 'guest_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('guestId', guestId);
        console.log('Created guest session:', guestId);
      }
      
      // Set up guest user object
      const guestUser = {
        id: guestId,
        email: null,
        name: 'Guest User',
        tier: 'free',
        isGuest: true
      };
      
      if (!localStorage.getItem('authToken')) {
        localStorage.setItem('user', JSON.stringify(guestUser));
        console.log('Guest mode active:', guestUser);
        // Ensure UI reflects guest state immediately
        setTimeout(() => renderAuthHeader(), 100);
      }
      
      return guestUser;
    }

    // Keep auth token/user in localStorage so existing fetches work
    supabase.auth.onAuthStateChange(async (_event, session) => {
      const token = session?.access_token || '';
      const emailConfirmed = !!(session?.user?.email_confirmed_at || session?.user?.confirmed_at);
      const user = session?.user ? {
        id: session.user.id,
        email: session.user.email,
        name: (session.user.user_metadata && session.user.user_metadata.name) ? session.user.user_metadata.name : (session.user.email||'').split('@')[0],
        isGuest: false
      } : null;
      
      if (token) {
        if (!emailConfirmed) {
          // Block unconfirmed sessions: sign out and show guidance
          try { await supabase.auth.signOut(); } catch {}
          localStorage.removeItem('authToken');
          const msg = 'Please confirm your email before signing in.';
          console.warn(msg);
          try{ if (typeof showToast==='function') showToast(msg); }catch{}
          window.initGuestMode();
          window.renderAuthHeader();
          return;
        }
        localStorage.setItem('authToken', token);
        // Clear guest mode when user signs in
        localStorage.removeItem('guestId');
      } else {
        localStorage.removeItem('authToken');
        // Initialize guest mode if no user session
        if (!user) {
          window.initGuestMode();
        }
      }
      
      if (user) {
        // For authenticated users, always fetch the authoritative tier from backend
        localStorage.setItem('user', JSON.stringify(user));
        console.log('ðŸ” Authenticated user detected, will fetch tier from backend');
        // Don't render header yet - wait for profile fetch to get correct tier
      } else {
        // Keep guest user if no authenticated user
        const currentUser = JSON.parse(localStorage.getItem('user') || '{}');
        if (!currentUser.isGuest) {
          localStorage.removeItem('user');
          window.initGuestMode();
        }
        window.renderAuthHeader();
      }
      
      // Fetch server-side profile to get authoritative tier
      try{
        if (token) {
          // Token exists and email is confirmed (guarded above)
          console.log('ðŸ” Fetching profile for authenticated user with token');
          const profileHeaders = token ? { 'Authorization': `Bearer ${token}` } : {};
          const res = await fetch('/api/profile', { headers: profileHeaders });
          console.log('ðŸ” Profile fetch response:', res.status, res.ok);
          if (res.ok) {
            const p = await res.json();
            console.log('ðŸ” Profile data received:', p);
            const u = JSON.parse(localStorage.getItem('user')||'{}');
            u.tier = p.tier || 'business'; // Use backend tier or default to business
            u.isGuest = false; // Ensure authenticated users are not marked as guests
            localStorage.setItem('user', JSON.stringify(u));
            console.log('ðŸ” Updated user object with backend tier:', u);
            // refresh UI and phrasebook
            window.renderAuthHeader();
            try{ initMaxToggle(); updateSubmitHints(); }catch{}
            try{ if (typeof renderSavedPhrasebookAll==='function') await renderSavedPhrasebookAll(); }catch{}
          } else {
            console.log('ðŸ” Profile fetch failed, but user has token - marking as authenticated');
            // If profile fetch fails but we have a token, still mark as not guest with business tier
            const u = JSON.parse(localStorage.getItem('user')||'{}');
            u.isGuest = false;
            u.tier = u.tier || 'business'; // Default to business tier for authenticated users
            localStorage.setItem('user', JSON.stringify(u));
            console.log('ðŸ” Fallback user object with team tier:', u);
            window.renderAuthHeader();
            try{ initMaxToggle(); updateSubmitHints(); }catch{}
          }
        } else {
          // No token, ensure guest mode is active
          const currentUser = JSON.parse(localStorage.getItem('user') || '{}');
          if (!currentUser.isGuest) {
            window.initGuestMode();
          }
          window.renderAuthHeader();
        }
      }catch(e){ 
        console.warn('profile fetch failed', e);
        // On error, if we have a token, still mark as authenticated
        if (token) {
          const u = JSON.parse(localStorage.getItem('user')||'{}');
          u.isGuest = false;
          localStorage.setItem('user', JSON.stringify(u));
        }
        window.renderAuthHeader();
      }
    });

    // On initial load, recover session immediately (covers OAuth redirect)
    (async () => {
      try{
        console.log('Checking for existing session...');
        const { data: { session } } = await supabase.auth.getSession();
        const token = session?.access_token;
        console.log('Session found:', !!session, 'Token:', !!token);
        
        // If we arrived via OAuth, clean the hash from the URL once handled
        const hasOAuthTokens = /access_token=|refresh_token=|code=/i.test(location.hash);
        if (hasOAuthTokens) {
          console.log('OAuth tokens detected in URL hash, processing...');
          try { history.replaceState(null, '', location.pathname + location.search); } catch {}
        }
        
        if (token) {
          const user = session.user ? {
            id: session.user.id,
            email: session.user.email,
            name: (session.user.user_metadata && session.user.user_metadata.name) ? session.user.user_metadata.name : (session.user.email||'').split('@')[0],
            isGuest: false
          } : null;
          localStorage.setItem('authToken', token);
          localStorage.removeItem('guestId'); // Clear guest mode
          if (user) {
            user.isGuest = false; // Explicitly mark as not guest
            user.tier = 'business'; // Default to business tier for authenticated users
            localStorage.setItem('user', JSON.stringify(user));
            console.log('ðŸ” Initial session recovery - set user with team tier:', user);
          }
          try{
            const profileHeaders = token ? { 'Authorization': `Bearer ${token}` } : {};
            const res = await fetch('/api/profile', { headers: profileHeaders });
            if (res.ok) {
              const p = await res.json();
              const u = JSON.parse(localStorage.getItem('user')||'{}');
              u.tier = p.tier || 'business'; // Use backend tier or default to business
              u.isGuest = false; // Ensure not marked as guest
              localStorage.setItem('user', JSON.stringify(u));
              console.log('ðŸ” Session recovery - updated user with backend tier:', u);
            }
          }catch{}
        } else {
          // No authenticated session, initialize guest mode
          window.initGuestMode();
        }
        // Update header to reflect current state
        window.renderAuthHeader();
      }catch{
        // On error, ensure guest mode is active
        initGuestMode();
        window.renderAuthHeader();
      }
    })();

    window.getAuthToken = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      return session?.access_token || '';
    };
  </script>
  <meta charset="UTF-8" />
  <title>AI Localization Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#F6F6F2;--card:#fff;--text:#0b0b0c;--muted:#6e6e73;--border:#d2d2d7;
      --accent:#007aff;--accent-weak:#e6f0ff;--radius:14px;--radius-pill:999px;
      --shadow:0 10px 30px rgba(0,0,0,.08);--shadow-soft:0 2px 10px rgba(0,0,0,.06);
      --ease:cubic-bezier(.22,.61,.36,1);
      --fs:14px;
    }
    /* Settings page shell */
    .settings-page{ 
      position:fixed; 
      top:0; 
      left:0; 
      width:100%; 
      height:100vh; 
      background:var(--bg); 
      z-index:1000; 
      display:none; 
      opacity:0; 
      overflow-y:auto;
      will-change:opacity, transform;
    }
    .settings-page.active{ display:block; opacity:1; transform:translateX(0) }
    .settings-container{ padding:20px; min-height:85vh; display:flex; flex-direction:column }
    .settings-inner{ max-width:1000px; margin:0 auto; width:100%; flex:1; display:flex; flex-direction:column }
    .settings-logo{ font-size:32px; font-weight:700; color:var(--text); margin:0 0 20px; text-align:left }
    .settings-logo img{ height:72px; width:auto; display:block }
    .settings-main-container{ background:#fff; border:none; border-radius:20px; box-shadow:var(--shadow-soft); overflow:hidden; flex:1; display:flex; flex-direction:column }
    .settings-header{ display:flex; align-items:center; justify-content:space-between; padding:16px 20px; border-bottom:1px solid var(--border) }
    .settings-nav-header{ display:flex; align-items:center; gap:8px }
    .settings-back{ display:flex; align-items:center; justify-content:center; width:36px; height:36px; border:1px solid var(--border); background:#fff; border-radius:50%; cursor:pointer; transition:all .18s var(--ease) }
    .settings-back:hover{ border-color:var(--accent); color:var(--accent) }
    .settings-back-text{ font-size:14px; color:var(--text); margin-left:8px }
    .settings-title{ font-size:14px; font-weight:500; color:var(--text); margin:0 }
    .settings-main{ display:grid; grid-template-columns:264px 1fr; gap:0; align-items:stretch; flex:1; min-height:450px }
    .settings-sidebar{ background:#F6F6F2; padding:16px; width:240px; display:flex; flex-direction:column; margin:12px; border-radius:12px; position:relative }
    .settings-nav{ display:flex; flex-direction:column; gap:12px }
    .settings-link{ display:flex; align-items:center; padding:8px 12px; border-radius:7px; cursor:pointer; transition:all .18s var(--ease); font-size:16px; font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif; font-weight:400; color:var(--text); background:transparent; border:none; width:100%; text-align:left; height:33px }
    .settings-link:hover{ background:#EAEAEA }
    .settings-link.active{ background:#EAEAEA; color:var(--accent); font-weight:500 }
    .settings-content{ background:transparent; border:none; box-shadow:none; overflow:visible; max-width:none; padding:20px }
    .settings-section{ padding:20px; display:none }
    .settings-section.active{ display:block }
    .settings-h1{ font-size:20px; font-weight:700; margin:0 0 8px; color:var(--text) }
    .settings-sub{ font-size:14px; color:var(--muted); margin:0 0 20px; line-height:1.5 }
    .settings-row{ display:flex; flex-direction:column; gap:16px }
    .settings-field{ display:flex; flex-direction:column; gap:8px }
    .settings-label{ font-size:14px; font-weight:500; color:var(--text) }
    .settings-input{ padding:12px 16px; border:1px solid var(--border); border-radius:10px; font-size:14px; font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif; background:#fff; transition:all .18s var(--ease) }
    .settings-input:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak) }
    .settings-input:disabled{ background:#f6f6f2; color:var(--muted) }
    .settings-actions{ display:flex; gap:12px; margin-top:20px }
    .settings-btn{ padding:9px 14px; border:1px solid var(--border); background:#fff; border-radius:10px; font-size:14px; font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif; cursor:pointer; transition:all .18s var(--ease); font-weight:500 }
    .settings-btn.primary{ background:var(--accent); color:#fff; border-color:var(--accent) }
    .settings-btn.primary:hover{ background:#0056d6; border-color:#0056d6; transform:translateY(-1px); box-shadow:0 4px 12px rgba(0,107,255,.3) }
    .settings-btn.danger{ background:#ff3b30; color:#fff; border-color:#ff3b30 }
    .settings-btn.danger:hover{ background:#d70015; border-color:#d70015; transform:translateY(-1px); box-shadow:0 4px 12px rgba(255,59,48,.3) }
    .settings-btn:hover{ background:#f6f6f2; border-color:var(--accent); color:var(--accent); transform:translateY(-1px); box-shadow:0 2px 8px rgba(0,0,0,.1) }
    .settings-btn:active{ transform:translateY(0); box-shadow:none }
    .settings-muted{ color:var(--muted); font-size:13px }
    /* Invoices table */
    .inv-table{ width:100%; border-collapse:separate; border-spacing:0; margin-top:8px }
    .inv-table th,.inv-table td{ text-align:left; font-size:14px; padding:10px 12px; border-bottom:1px solid #eef0f3 }
    .inv-table th{ color:var(--muted); font-weight:600 }
    .inv-table tr:last-child td{ border-bottom:none }
    .inv-view{ color:var(--accent); cursor:pointer; border:1px solid var(--accent); background:var(--accent-weak); padding:6px 10px; border-radius:10px }
    /* Chips and toggles (STATE-GUIDE) */
    .chips-row{ display:flex; gap:8px }
    .chip-btn{ border:1px solid var(--border); background:#fff; color:var(--text); border-radius:999px; padding:8px 16px; font-size:14px; font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif; cursor:pointer; transition:all .18s var(--ease); font-weight:500 }
    .chip-btn:hover{ background:inherit; border-color:var(--accent); color:inherit }
    .chip-btn.active{ background:var(--accent-weak); color:var(--accent); border-color:var(--accent); box-shadow:0 0 0 2px var(--accent-weak) }
    .switch{ position:relative; width:44px; height:24px; display:inline-block }
    .switch input{ display:none }
    .switch .slider{ position:absolute; inset:0; background:#d2d2d7; border-radius:999px; transition:all .3s var(--ease) }
    .switch .slider::before{ content:""; position:absolute; left:2px; top:2px; width:20px; height:20px; background:#fff; border-radius:50%; transition:all .3s var(--ease); box-shadow:0 2px 4px rgba(0,0,0,.1) }
    .switch input:checked + .slider{ background:var(--accent) }
    .switch input:checked + .slider::before{ transform:translateX(20px) }
    .dialog-backdrop{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.08); backdrop-filter:blur(6px); -webkit-backdrop-filter:blur(6px); z-index:2000; opacity:0; transition:opacity .2s var(--ease) }
    .dialog-backdrop.active{ display:flex; opacity:1 }
    .dialog-card{ width:min(560px,92vw); background:rgba(255,255,255,.85); border:1px solid var(--border); border-radius:14px; box-shadow:0 18px 50px rgba(0,0,0,.18); padding:20px }
    
    /* Billing Dialog Styles */
    .billing-dialog-backdrop{ 
      position:fixed; 
      top:0;
      left:264px; /* Start after sidebar */
      right:0;
      bottom:0;
      display:none; 
      align-items:center; 
      justify-content:center; 
      background:transparent; /* Remove dark background */
      z-index:2000; 
      opacity:0; 
      transition:all .3s var(--ease);
    }
    .billing-dialog-backdrop.active{ display:flex; opacity:1 }
    .billing-dialog-card{ 
      width:540px; 
      height:600px;
      background:rgba(255,255,255,0.85); 
      border:1px solid #eaeaea; 
      border-radius:15px; 
      box-shadow:0 25px 60px rgba(0,0,0,.15); 
      padding:30px;
      backdrop-filter:blur(15px);
      -webkit-backdrop-filter:blur(15px);
      position:relative;
      transform:scale(0.9);
      transition:transform .3s var(--ease);
    }
    .billing-dialog-backdrop.active .billing-dialog-card{
      transform:scale(1);
    }
    
    /* Card Input Container */
    .billing-card-inputs{
      display:grid;
      grid-template-columns:1fr 80px 60px;
      gap:12px;
      width:100%;
    }
    .billing-input{
      border:2px solid #eaeaea;
      border-radius:10px;
      height:28px;
      padding:0 11px;
      font-size:12px;
      font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      background:#fff;
      color:var(--text);
      outline:none;
      transition:border-color .2s ease;
    }
    .billing-input:focus{ border-color:#006cff; }
    .billing-input::placeholder{ color:#666666; }
    
    /* Input Focus States - All editable text boxes */
    .settings-input:focus{
      border-color:#006cff !important;
      outline:none;
    }
    input[type="text"]:focus,
    input[type="email"]:focus,
    input[type="password"]:focus{
      border-color:#006cff !important;
      outline:none;
    }
    
    /* Card Input Specific Styling */
    .billing-card-number{
      grid-column:1;
    }
    .billing-expiry{
      grid-column:2;
    }
    .billing-cvv{
      grid-column:3;
    }
    
    /* Custom Checkbox */
    .billing-checkbox-wrapper{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
    }
    .billing-checkbox-input{
      display:none;
    }
    .billing-checkbox-custom{
      width:15px;
      height:15px;
      border:2px solid #eaeaea;
      border-radius:10px;
      background:#fff;
      position:relative;
      transition:all .2s ease;
    }
    .billing-checkbox-input:checked + .billing-checkbox-custom{
      background:#006cff;
      border-color:#006cff;
    }
    .billing-checkbox-input:checked + .billing-checkbox-custom::after{
      content:'';
      position:absolute;
      left:2px;
      top:-1px;
      width:6px;
      height:10px;
      border:solid white;
      border-width:0 2px 2px 0;
      transform:rotate(45deg);
    }
    
    /* Billing Dialog Buttons */
    .billing-btn{
      height:26px;
      padding:0 12px;
      border:1px solid #eaeaea;
      border-radius:6px;
      font-size:12px;
      font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      cursor:pointer;
      transition:all .2s ease;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .billing-btn-cancel{
      background:#f6f6f2;
      color:var(--text);
      box-shadow:none !important;
    }
    /* Remove hover effects for dialog action buttons */
    .billing-btn-cancel:hover{ background:#f6f6f2 !important; border-color:#eaeaea !important; color:var(--text) !important; transform:none !important; box-shadow:none !important; }
    .billing-btn-primary{
      background:#006cff;
      color:white;
      border-color:#006cff;
      box-shadow:none !important;
    }
    .billing-btn-primary:hover{ background:#006cff !important; border-color:#006cff !important; color:white !important; transform:none !important; box-shadow:none !important; }
    
    /* Country Select Styling */
    .billing-country-select{
      appearance:none;
      background-image:url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23666666' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat:no-repeat;
      background-position:right 11px center;
      background-size:14px;
      padding-right:35px;
      cursor:pointer;
      border-radius:10px;
      transition:border-color .2s ease;
    }
    .billing-country-select:focus{
      border-color:#006cff;
    }
    
    /* Toggle Switch Styling */
    .switch input:checked + .slider {
      background-color: #006cff !important;
    }
    .switch input:checked + .slider:before {
      transform: translateX(20px);
    }
    .slider {
      background-color: #ccc;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    /* Completely disable ALL hover effects for profile page buttons */
    #saveProfileBtn,
    #deleteAccountBtn,
    #emailVerifyBtn {
      transition: none !important;
    }
    /* Ensure save button never shows a drop shadow in any state */
    #saveProfileBtn { box-shadow: none !important; }
    
    #saveProfileBtn:hover,
    #saveProfileBtn:focus,
    #saveProfileBtn:active,
    #deleteAccountBtn:hover,
    #deleteAccountBtn:focus,
    #deleteAccountBtn:active,
    #emailVerifyBtn:hover,
    #emailVerifyBtn:focus,
    #emailVerifyBtn:active {
      transform: none !important;
      box-shadow: none !important;
      opacity: 1 !important;
      filter: none !important;
      transition: none !important;
      animation: none !important;
    }
    /* Save button - keep original blue style always */
    #saveProfileBtn:hover,
    #saveProfileBtn:focus,
    #saveProfileBtn:active {
      background: var(--accent) !important;
      border-color: var(--accent) !important;
      color: #fff !important;
    }
    
    /* Delete button - keep original red style always */
    #deleteAccountBtn:hover,
    #deleteAccountBtn:focus,
    #deleteAccountBtn:active {
      background: #ff3b30 !important;
      border-color: #ff3b30 !important;
      color: #fff !important;
    }
    
    /* Email verify button - keep original default style always */
    #emailVerifyBtn:hover,
    #emailVerifyBtn:focus,
    #emailVerifyBtn:active {
      background: #F6F6F2 !important;
      border-color: #EAEAEA !important;
      color: #000000 !important;
    }
    
    /* Verified email button - completely static */
    #emailVerifyBtn[disabled],
    #emailVerifyBtn[disabled]:hover,
    #emailVerifyBtn[disabled]:focus,
    #emailVerifyBtn[disabled]:active {
      background: transparent !important;
      border: none !important;
      color: #006cff !important;
      cursor: default !important;
      transform: none !important;
      box-shadow: none !important;
      opacity: 1 !important;
      pointer-events: none !important;
    }
    @media (max-width: 880px){ .settings-main{ grid-template-columns:1fr; } .settings-sidebar{ position:static } .settings-nav{ flex-direction:row; overflow-x:auto; gap:8px; padding:8px } .settings-content{ max-width:none } .settings-inner{ max-width:none; padding:0 } }
    *,*::before,*::after{box-sizing:border-box}
    button,input,textarea,select{font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif}
    html,body{height:100%}
    html{overflow-y:scroll;scrollbar-gutter:stable}
    body{margin:0;font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Helvetica Neue",Arial,sans-serif;color:var(--text);background:var(--bg);min-height:100vh;overflow-y:scroll}
    body.settings-open{position:fixed;top:0;left:0;width:100%;height:100%}
    .shell{max-width:1100px;margin:28px auto 48px;padding:0 20px; position:relative; z-index:1; will-change:opacity, transform; min-height:calc(100vh - 76px)}
    .titlebar{display:flex;align-items:center;justify-content:space-between;gap:12px; position:relative; z-index:20; will-change:opacity, transform}
    .title{font-weight:700;letter-spacing:.2px;font-size:28px;margin:6px 0 18px}
    .title-logo{display:flex;align-items:center;margin:6px 0 18px}
    .title-logo img{height:72px;width:auto;display:block}
    .toolbar{display:flex;flex-direction:column;gap:8px;align-items:stretch}
    .toolbar-row{display:flex;gap:8px;align-items:center;justify-content:flex-end;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid var(--border);background:#fafafa;padding:9px 14px;border-radius:12px;font-size:14px;font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif;letter-spacing:.2px;transition:transform .12s var(--ease),box-shadow .12s var(--ease),background .12s,border-color .12s,opacity .12s;box-shadow:var(--shadow-soft);user-select:none;cursor:pointer;display:inline-flex;align-items:center;gap:8px;min-height:36px; transition:
    transform .12s var(--ease),
    box-shadow .18s var(--ease),
    background .18s,
    border-color .18s,
    color .18s,
    opacity .12s,
    filter .22s var(--ease),
    backdrop-filter .22s var(--ease);}
    /* Unified hover/active for toolbar/main buttons: border only changes to blue */
    .btn:hover{ border-color: var(--accent); background:#fff; color: inherit; transform:none; box-shadow:none }
    .btn:active{ border-color: var(--accent); background:#fff; transform:none; box-shadow:none }
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .toggle-btn.active,.style-btn.active{border-color:var(--accent);background:var(--accent-weak);box-shadow:0 0 0 2px var(--accent-weak)}
    .primary{background:var(--accent);color:#fff;border-color:var(--accent);padding:10px 16px;border-radius:12px;box-shadow:0 6px 16px rgba(0,122,255,.25)}
    .card{position:relative;background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:22px;overflow:hidden}
    .card.export-open{overflow:visible}
    .section{margin-top:18px}
    .label{display:block;font-size:13px;color:var(--muted);margin:0 0 8px;letter-spacing:.2px}
    .hr{height:1px;background:var(--border);margin:14px 0}

    /* Notifications */
    .notification-host{position:fixed;top:24px;right:clamp(16px,calc((100vw - 1100px)/2 + 20px),160px);display:flex;flex-direction:column;align-items:flex-end;gap:12px;pointer-events:none;width:min(340px,calc(100vw - 32px));z-index:10020;}
    .notification-card{position:relative;display:flex;gap:12px;align-items:center;width:100%;background:var(--card,#fff);border:1px solid rgba(15,23,42,0.08);border-radius:16px;padding:14px 18px;box-shadow:0 18px 40px -24px rgba(15,23,42,.5),0 6px 18px -12px rgba(15,23,42,.35);color:var(--text,#111);pointer-events:auto;opacity:0;transform:translateY(-8px);animation:notification-enter .24s ease forwards;}
    
    .notification-card__icon{width:20px;height:20px;flex:0 0 20px;color:var(--tone-color,#2563eb);display:flex;align-items:center;justify-content:center;}
    .notification-card__body{flex:1;min-width:0;display:flex;flex-direction:column;justify-content:center;gap:2px;}
    .notification-card__title{font-weight:600;font-size:14px;margin-bottom:2px;}
    .notification-card__message{font-size:13px;line-height:1.4;color:var(--muted,#555);}
    .notification-card__close{background:transparent;border:none;color:rgba(15,23,42,.45);cursor:pointer;font-size:16px;line-height:1;padding:2px;border-radius:8px;transition:background .18s ease,color .18s ease;display:flex;align-items:center;justify-content:center;width:28px;height:28px;}
    .notification-card__close:hover{background:rgba(15,23,42,.05);color:rgba(15,23,42,.7);}
    .notification-card--success{--tone-color:#16a34a;}
    .notification-card--error{--tone-color:#dc2626;}
    .notification-card--warning{--tone-color:#d97706;}
    .notification-card--info{--tone-color:#2563eb;}
    @keyframes notification-enter{from{opacity:0;transform:translateY(-12px);}to{opacity:1;transform:translateY(0);}}
    .notification-card.notification-leave{animation:notification-leave .22s ease forwards;}
    @keyframes notification-leave{from{opacity:1;transform:translateY(0);}to{opacity:0;transform:translateY(-12px);}}
    @media (max-width: 720px){
      .notification-host{top:auto;bottom:24px;left:50%;right:auto;transform:translateX(-50%);align-items:center;width:min(420px,calc(100vw - 32px));}
      .notification-card{transform:translateY(12px);animation:notification-enter-bottom .24s ease forwards;}
      .notification-card.notification-leave{animation:notification-leave-bottom .22s ease forwards;}
    }
    @keyframes notification-enter-bottom{from{opacity:0;transform:translateY(12px);}to{opacity:1;transform:translateY(0);}}
    @keyframes notification-leave-bottom{from{opacity:1;transform:translateY(0);}to{opacity:0;transform:translateY(12px);}}

    /* Modern Tabs: pill + subtle shadow + grab-scroll */
    .tabs-wrap{margin:8px 0 12px; will-change:opacity, transform}
    .tabs{display:flex;align-items:center;gap:8px;overflow:auto;padding:4px;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow-soft);cursor:grab;-webkit-overflow-scrolling:touch}
    .tabs.grabbing{cursor:grabbing}
    .tabs::-webkit-scrollbar{display:none}
    .tab{position:relative;display:inline-flex;align-items:center;gap:10px;max-width:260px;padding:8px 12px;border:1px solid var(--border);border-radius:999px;background:#fafafa;color:#2c2c2e;font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif;cursor:pointer;transition:background .18s,border-color .18s,transform .12s var(--ease),box-shadow .18s}
    .tab.active{background:#fff;border-color:var(--accent);box-shadow:0 0 0 2px var(--accent-weak), var(--shadow-soft)}
    .tab:hover{background:#fff}
    .tab-title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px}
    .tab-ext{opacity:.6;font-size:12px}
    .tab-close{border:1px solid var(--border);border-radius:9px;padding:2px 6px;background:#fff;cursor:pointer;font-size:12px}

    textarea{
      width:100%;min-height:140px;max-height:42vh;resize:vertical;border:1px solid var(--border);font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      border-radius:12px;padding:12px 14px;background:#fff;box-shadow:var(--shadow-soft);
      line-height:1.55;outline:none;transition:box-shadow .18s var(--ease),border-color .18s var(--ease);
      font-family:inherit;font-size:var(--fs);overflow:hidden /* was auto â€“ causes arrows on short text */
    }
    textarea:focus{border-color:var(--accent);box-shadow:0 0 0 4px var(--accent-weak)}
    .rich{min-height:200px;max-height:42vh;overflow:auto;border:1px solid var(--border);border-radius:12px;padding:12px 14px;background:#fff;box-shadow:var(--shadow-soft);line-height:1.55;outline:none;white-space:pre-wrap;font-size:var(--fs);resize:vertical}
    /* Always keep placeholder text left-aligned regardless of RTL content */
    textarea::placeholder{ text-align:left; direction:ltr; }
    textarea.rtl::placeholder{ text-align:left; direction:ltr; }
    .is-hidden{display:none!important}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;min-height:38px}
    .substyle{border:1px solid var(--border);border-radius:12px;background:#fff;box-shadow:var(--shadow-soft);padding:12px}
    .substyle-trigger{display:flex;justify-content:space-between;align-items:center;width:100%;background:#fff;border:0;padding:8px 4px;font-size:14px;cursor:pointer}
    .chev{transition:transform .22s var(--ease)}
    .chev.up{transform:rotate(180deg)}
    .substyle-panel{overflow:hidden;opacity:0;max-height:0;transition:max-height .28s var(--ease),opacity .2s var(--ease)}
    .substyle-panel.open{opacity:1;max-height:220px}
    .substyle-scroll{max-height:180px;overflow:auto;padding:8px 0 2px}
    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{border:1px solid var(--border);background:#fafafa;border-radius:999px;padding:6px 12px;font-size:13px;transition:background .12s,border-color .12s,transform .12s var(--ease);cursor:pointer}
    .chip:hover{transform:none; border-color:var(--accent)}
    .chip.active{background:var(--accent-weak);border-color:var(--accent)}

    /* Split view + rows */
    .mode-wrap{position:relative;transition:height .34s var(--ease);min-height:360px;height:auto}
    .mode-wrap:not(.layered) .view{display:none;position:static;opacity:1;transform:none;filter:none;pointer-events:auto}
    .mode-wrap:not(.layered) .view.active{display:block}
    .mode-wrap.layered .view{display:block;position:absolute;left:0;right:0;top:0;opacity:0;transform:translateY(8px) scale(.995);filter:blur(6px);transition:opacity .34s var(--ease),transform .34s var(--ease),filter .30s var(--ease);pointer-events:none;will-change:opacity,transform,filter}
    .mode-wrap.layered .view.active{opacity:1;transform:translateY(0) scale(1);filter:none;pointer-events:auto}
    @media (prefers-reduced-motion:reduce){.mode-wrap{transition:none}.mode-wrap.layered .view{transition:none;filter:none;transform:none}}

    .split-grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;align-items:start}
    @media (max-width:900px){.split-grid{grid-template-columns:1fr}}
    .paneCard{border:1px solid var(--border);border-radius:12px;background:#fff;box-shadow:var(--shadow-soft);padding:12px;position:relative;display:flex;flex-direction:column;min-width:0}
    .paneHead{font-size:13px;color:#3a3a3c;font-weight:600;margin:0 0 6px}
    .segbox{border:1px solid var(--border);border-radius:12px;background:#fff;padding:12px;max-height:70vh;overflow:auto;position:relative;flex:1;min-width:0;word-wrap:break-word;height:auto}
    .view.split .segbox{max-height:none;height:auto;overflow:auto}
    /* Prevent scroll anchoring jumps inside segment boxes */
    #segSrcBox, #segTgtBox{overflow-anchor:none;scrollbar-gutter:stable both-edges}
    #segSrcBox,#segTgtBox{padding-right:72px;padding-bottom:56px}
    .segrow{display:flex;gap:10px;align-items:stretch;padding:12px 6px;border-bottom:1px dashed #ececec;min-width:0;min-height:auto}
    .segrow:last-child{border-bottom:none}
    .lineno{min-width:26px;height:22px;line-height:22px;text-align:center;border:1px solid var(--border);border-radius:999px;font-size:12px;color:#666;background:#f6f8ff;margin-top:2px;user-select:none}
    .segcontent{flex:1;min-width:0;overflow-wrap:break-word;width:100%;height:auto;display:flex;flex-direction:column}
    .segtext{white-space:pre-wrap;word-wrap:break-word;line-height:1.55;font-family:inherit;font-size:var(--fs);min-width:0;overflow-wrap:anywhere;width:100%;height:auto;display:block;flex:1;overflow:visible;max-height:none}
    /* RTL helpers (content-only alignment; spacing and sizing unchanged) */
    .rtl{ direction:rtl; text-align:right; }
    textarea.rtl{ direction:rtl; text-align:right; }
    .segtext.rtl{ direction:rtl; text-align:right; }
    .segtext-textarea.rtl{ direction:rtl; text-align:right; }
    #segTgtBox textarea[data-srt].rtl{ direction:rtl; text-align:right; }
    /* Target segment textareas: clean styling */
    .segtext-textarea{
      width:100%;min-height:40px;border:1px solid transparent;
      border-radius:8px;padding:8px;background:transparent;
      font-family:inherit;font-size:var(--fs);line-height:1.55;
      height:auto; /* allow JS to grow to scrollHeight */
      resize:none;overflow:hidden; /* prevent native resize + hide scrollbars */
      transition:border-color .18s var(--ease);
    }
    .segtext-textarea:focus{
      outline:none;border-color:var(--accent);
      box-shadow:0 0 0 2px var(--accent-weak);
    }
    .segmeta{margin-top:6px;font-size:12px;color:#666}
    .segrow.placeholder .segtext{color:#aaa}

    .segbox textarea[data-srt]{
      width:100%;min-height:44px;border:1px solid var(--border);
      border-radius:10px;padding:8px 10px;resize:none;line-height:1.55;
      font-family:inherit;font-size:var(--fs);background:#fff;box-shadow:var(--shadow-soft);
      overflow:auto;max-height:none;height:auto
    }

    .split-footer{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-top:10px;padding-top:10px;border-top:1px solid var(--border)}
    .split-footer .label{margin:0;color:#888;font-size:12px;flex:1 1 auto;min-width:0}
    
    /* (removed Edit Mode styles) */

    /* Status tab (replaces progress bar; collapsible with smooth motion) */
    .upload-progress-bar{
      margin:0; /* collapsed state */
      padding:0 20px; /* vertical padding animated */
      background:rgba(255,255,255,0.95);
      border:2px solid var(--accent);
      border-radius:12px;
      box-shadow:0 8px 32px rgba(0,0,0,0.12);
      opacity:0;
      transform:translateY(-12px); /* appears from behind input */
      transition:opacity .38s var(--ease), transform .38s var(--ease),
                 margin .38s var(--ease), padding .38s var(--ease),
                 max-height .42s var(--ease);
      backdrop-filter:blur(12px);
      -webkit-backdrop-filter:blur(12px);
      z-index:1000;
      position:relative;
      overflow:hidden;
      max-height:0; /* collapse space when hidden */
      pointer-events:none;
    }
    .upload-progress-bar.show{
      opacity:1;
      transform:translateY(0);
      margin:12px 0;
      padding:12px 20px;
      max-height:72px; /* smooth push/pull of content */
      pointer-events:auto;
    }
    /* Subtle pulse while busy */
    .upload-progress-bar.is-busy{--pulse:rgba(0,122,255,.22);animation:pulseShadow 1.6s var(--ease) infinite}
    @keyframes pulseShadow{0%{box-shadow:0 8px 32px rgba(0,0,0,.12),0 0 0 0 var(--pulse)}70%{box-shadow:0 8px 32px rgba(0,0,0,.12),0 0 0 8px rgba(0,122,255,0)}100%{box-shadow:0 8px 32px rgba(0,0,0,.12),0 0 0 0 rgba(0,122,255,0)}}
    /* Typing ellipsis on the status text */
    .upload-progress-bar.is-busy .upload-progress-text[data-ellipsis]::after{content:attr(data-ellipsis);display:inline-block;width:1.4em;text-align:left;animation:typingDots 1.2s steps(4,end) infinite}
    @keyframes typingDots{0%{content:""}25%{content:"."}50%{content:".."}75%{content:"..."}100%{content:""}}
    .upload-progress-text{
      font-size:15px;
      font-weight:600;
      color:var(--accent);
      margin-bottom:8px;
      text-align:center;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    /* Hide bar visuals; we only keep status text per requirement */
    .upload-progress-track{ display:none }
    .upload-progress-fill{ display:none }

    /* Result actions container (outside text box) */
    .result-actions{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      margin-top:12px;
      padding:0;
    }
    
    /* Legacy action strip (for split view) */
    .action-strip{position:absolute;right:12px;bottom:12px;display:inline-flex;align-items:center;gap:8px;z-index:2}
    .ctl-btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;height:34px;padding:0 12px;border-radius:12px;border:1px solid var(--border);background:#fff;box-shadow:var(--shadow-soft);cursor:pointer;transition:transform .18s var(--ease),background .18s,border-color .18s,color .18s,filter .22s var(--ease),backdrop-filter .22s var(--ease)}
    .ctl-btn svg{width:16px;height:16px}
    .ctl-btn.copy-btn{min-width:110px}
    .split-footer .ctl-btn{white-space:nowrap}
    .ctl-btn[disabled],
    .ctl-btn.is-disabled{
      cursor:not-allowed;
      opacity:.55;
      box-shadow:none;
      pointer-events:none;
    }

    .export-menu{
      position:relative;
    }
    .export-toggle{
      padding:0 16px;
      gap:6px;
    }
    .export-caret{
      width:12px;
      height:12px;
      pointer-events:none;
      transition:transform .18s var(--ease);
      margin-left:auto;
    }
    .export-menu[data-open="true"] .export-caret{
      transform:rotate(180deg);
    }
    .export-dropdown{
      position:absolute;
      right:0;
      top:calc(100% + 8px);
      min-width:210px;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:var(--shadow);
      padding:8px;
      display:grid;
      gap:6px;
      opacity:0;
      pointer-events:none;
      transform:translateY(-6px);
      transition:opacity .18s var(--ease), transform .18s var(--ease);
      z-index:1030;
    }
    .export-menu[data-open="true"] .export-dropdown{
      opacity:1;
      pointer-events:auto;
      transform:translateY(0);
    }
    .export-menu[data-placement="top"] .export-dropdown{
      top:auto;
      bottom:calc(100% + 8px);
      transform:translateY(6px);
    }
    .export-menu[data-placement="top"][data-open="true"] .export-dropdown{
      transform:translateY(0);
    }
    .export-menu[data-placement="top"] .export-dropdown{
      top:auto;
      bottom:calc(100% + 8px);
      transform:translateY(6px);
    }
    .export-menu[data-placement="top"][data-open="true"] .export-dropdown{
      transform:translateY(0);
    }
    .export-option{
      display:flex;
      align-items:center;
      justify-content:space-between;
      width:100%;
      border:none;
      background:transparent;
      border-radius:8px;
      padding:10px 12px;
      font-size:14px;
      color:var(--text);
      text-align:left;
      cursor:pointer;
      transition:background .18s var(--ease), color .18s var(--ease);
      white-space:nowrap;
    }
    .export-option:hover,
    .export-option:focus{
      background:var(--accent-weak);
      color:var(--accent);
      outline:none;
    }
    .export-option-suffix{
      font-size:12px;
      font-weight:600;
      letter-spacing:.04em;
      color:var(--muted, #6b7280);
    }

    .ctl-btn:hover{ background:inherit; border-color:var(--accent); color:inherit; transform:none; box-shadow:none }
    .copy-btn.copied{background:var(--accent-weak);border-color:var(--accent);color:var(--accent);transform:translateY(-1px);backdrop-filter:blur(3px) saturate(1.12);-webkit-backdrop-filter:blur(3px) saturate(1.12)}

    .no-js .mode-wrap{height:auto!important;min-height:unset!important}
    .no-js .view{position:static;opacity:1;filter:none;transform:none;pointer-events:auto}
    #clearHl{display:none}

    .glass{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(120% 120% at 50% 30%,rgba(255,255,255,.25) 0,rgba(245,245,247,.35) 40%,rgba(245,245,247,.55) 100%);backdrop-filter:blur(8px) saturate(1.1);-webkit-backdrop-filter:blur(8px) saturate(1.1);opacity:0;pointer-events:none;transform:scale(1.02);transition:opacity .28s var(--ease),transform .28s var(--ease);z-index:5}
    .glass.show{opacity:1;pointer-events:auto;transform:scale(1)}
    .glass-content{display:flex;flex-direction:column;align-items:center;gap:10px;transform:translateY(6px)}
    .ring{width:28px;height:28px;border-radius:50%;border:3px solid rgba(0,0,0,.12);border-top-color:var(--accent);animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .glass-text{font-size:13px;color:var(--muted);letter-spacing:.2px}


  .lang-overlay{position:fixed; inset:0; z-index:10000; display:flex; align-items:center; justify-content:center;
    /* uses the same tuning as the Phrasebook bubble */
    background:radial-gradient(120% 120% at 50% 30%,
      rgb(255 255 255 / var(--save-bubble-alpha, .10)) 0,
      rgb(245 245 247 / var(--save-bubble-alpha, .10)) 40%,
      rgb(245 245 247 / var(--save-bubble-alpha, .10)) 100%);
    backdrop-filter:blur(var(--save-bubble-blur, 2px)) saturate(1.28);
    -webkit-backdrop-filter:blur(var(--save-bubble-blur, 2px)) saturate(1.28);
    opacity:0; pointer-events:none; transform:scale(1.02); transition:opacity .28s var(--ease), transform .28s var(--ease)}

    .lang-overlay.show{opacity:1; pointer-events:auto; transform:scale(1)}
    .lang-sheet{width:min(720px,92vw); background:#fff; border:1px solid var(--border); border-radius:16px; box-shadow:var(--shadow); overflow:hidden; overflow-x:hidden; transform:translateY(8px) scale(.995); filter:blur(var(--save-bubble-blur, 4px)); transition:transform .34s var(--ease), filter .30s var(--ease), opacity .34s var(--ease); opacity:0}
    .lang-overlay.show .lang-sheet{transform:translateY(0) scale(1); filter:none; opacity:1}
    .lang-head{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid var(--border)}
    .lang-title{font-weight:700}
    .lang-close{border:1px solid var(--border); background:#fafafa; border-radius:10px; padding:6px 10px; cursor:pointer}
    .lang-grid{display:grid; grid-template-columns:1fr 1fr; gap:0; max-height:60vh; overflow:auto; overflow-x:hidden}
    .lang-item{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-top:1px solid #f0f0f3; cursor:pointer; transition:all .18s var(--ease); border-radius:0}
    .lang-item:hover{
      background:var(--accent-weak);
      border-color:var(--accent);
      color:var(--accent);
      transform:translateX(2px);
      box-shadow:0 2px 8px rgba(0,122,255,.12)
    }
    .lang-code{font-size:12px; color:#666}
    .lang-check{opacity:0; transition:opacity .18s var(--ease)}
    .lang-item.active .lang-check{opacity:1; color:var(--accent)}
    .lang-item.active{
      background:rgba(0,122,255,.05);
      border-left:3px solid var(--accent);
      font-weight:600;
    }
    .lang-item.active:hover{
      background:var(--accent-weak);
      transform:translateX(1px);
    }
    .face-btn{display:inline-flex; align-items:center; justify-content:center; gap:6px; min-width:56px}
    .face-btn svg{width:16px;height:16px;stroke:currentColor}

    .or-wrap{display:flex;align-items:center;gap:10px;margin:14px 0}
    .or-wrap::before,.or-wrap::after{content:"";flex:1;height:1px;background:var(--border)}
    .or{font-size:12px;color:var(--muted);letter-spacing:.3px;text-transform:uppercase}

    .dropzone{
      position:relative;border:1.5px dashed var(--border);border-radius:14px;
      background:#fff;padding:18px;display:flex;align-items:center;justify-content:center;
      gap:10px;cursor:pointer;transition:background .18s,border-color .18s,transform .12s var(--ease)
    }
    .dropzone:hover{transform:translateY(-1px)}
    .dropzone input{position:absolute;inset:0;opacity:0;width:100%;height:100%;cursor:pointer}
    .dropzone.drag{border-color:var(--accent);background:var(--accent-weak)}
    .dz-hint{font-size:13px;color:#383a3e}
    .dz-sub{font-size:12px;color:var(--muted)}

    .file-badge{display:inline-flex;align-items:center;gap:10px;border:1px solid var(--border);
      border-radius:12px;padding:8px 10px;background:#fff;box-shadow:var(--shadow-soft)}
    .file-badge b{font-weight:600}
    .file-badge .kill{margin-left:6px;border:1px solid var(--border);border-radius:10px;padding:4px 8px;cursor:pointer}

    .substyle-note{margin-top:10px;font-size:13px;color:#3a3a3c;opacity:0;transform:translateY(4px);
      transition:opacity .22s var(--ease), transform .22s var(--ease)}
    .substyle-note.show{opacity:1;transform:translateY(0)}
    .substyle-note b{font-weight:600}

        /* Glassy toolbar buttons (Language + History) */
    #uiLangBtn,
    #historyBtn,
    #addTextTabBtn,
    #settingsBtn,
    #signInBtn,
    #signOutBtnTop,
    #toggleSplit,
    #brandBtn,
    #advBtn{
      background:#fff; /* keep base white */
      border-color: var(--border);
      box-shadow: var(--shadow-soft);
    }

    /* Toolbar: explicit hover accents */
    /* Sign out â†’ red outline only */
    #signOutBtnTop:hover{ background:#fff; color: inherit; border-color: #ef4444; box-shadow:none }
    /* Sign in â†’ blue outline only */
    #signInBtn:hover{ background:#fff; color: inherit; border-color: var(--accent); box-shadow:none }

    /* Blue accent on Split View and New Tab hover (match Brand Kit/History style) */
    #toggleSplit:hover,
    #addTextTabBtn:hover,
    #settingsBtn:hover,
    #brandBtn:hover,
    #advBtn:hover{ background:#fff; color: inherit; border-color: var(--accent); box-shadow:none }

    /* Transparent hover + blue accent ring (keep text black) */
    #uiLangBtn:hover,
    #historyBtn:hover,
    #settingsBtn:hover,
    #brandBtn:hover,
    #advBtn:hover{ background:#fff; color: inherit; border-color: var(--accent); box-shadow:none }

    /* Active press state stays transparent */
    #uiLangBtn:active,
    #historyBtn:active{ transform:none; filter:none; border-color: var(--accent); box-shadow:none }

    /* Keyboard focus â€” blue focus ring */
    #uiLangBtn:focus-visible,
    #historyBtn:focus-visible{
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-weak);
    }

    /* Language modal close hover (specific) */
    #langOverlay .lang-close{ border:1px solid var(--border) !important; border-radius:10px; padding:6px 10px; background:#fff; color:#6b7280; transition:border-color .18s ease, color .18s ease; }
    #langOverlay .lang-close:hover{ border-color:var(--accent) !important; color:var(--accent) !important; }

  </style>
  <style>
    /* Minimal modal base styles */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:9999;display:none;align-items:center;justify-content:center}
    .modal-card{background:#fff;border:1px solid var(--border);border-radius:14px;box-shadow:var(--shadow-hard);width:min(440px,92vw);padding:20px}
    .modal-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:14px}
    /* Animated dropdown */
    @keyframes popIn{from{opacity:0;transform:translateY(-6px) scale(.98)}to{opacity:1;transform:translateY(0) scale(1)}}
    .menu-show{display:block !important;animation:popIn .16s ease-out}

    /* Auth modal â€” polished visuals */
    #authModal .modal-card{animation:popIn .18s ease-out}
    #authModal .modal-head h3{margin:0;font-weight:600;font-size:18px;color:#0f172a}
    #authModal .auth-body{display:grid;gap:12px}
    #authModal .btn-google{display:flex;align-items:center;justify-content:center;gap:8px;background:#fff;border:1px solid var(--border);border-radius:10px;padding:10px 12px;color:#111}
    #authModal .btn-google:hover{border-color:var(--accent);box-shadow:0 6px 22px rgba(0,0,0,.10),0 0 0 2px var(--accent-weak)}
    #authModal .btn-google svg{width:18px;height:18px}
    #authModal .auth-divider{display:flex;align-items:center;gap:10px;color:#6b7280;font-size:12px}
    #authModal .auth-divider:before,#authModal .auth-divider:after{content:"";flex:1;height:1px;background:#e5e7eb}
    #authModal .auth-tabs{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    #authModal .auth-tabs .btn{border-radius:10px;padding:9px 10px;justify-content:center;transition:all .18s var(--ease)}
    #authModal .auth-tabs .btn.active{background:var(--accent);color:#fff;border-color:var(--accent);box-shadow:0 0 0 2px var(--accent-weak)}
    #authModal .auth-form{display:grid;gap:10px}
    #authModal .auth-field{display:grid;gap:6px;transition:all .18s var(--ease)}
    #authModal .auth-field label{font-size:12px;color:#374151}
    #authModal .auth-input{padding:10px;border:1px solid var(--border);border-radius:10px;font-size:14px;font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif;transition:all .18s var(--ease)}
    #authModal .auth-input:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 3px var(--accent-weak)}
    #authModal .auth-primary{background:var(--accent);color:#fff;border-color:var(--accent);border-width:1px;border-style:solid;border-radius:10px;padding:10px;justify-content:center;display:inline-flex;transition:all .18s var(--ease)}
    #authModal .auth-primary:hover{filter:saturate(1.08);box-shadow:0 6px 16px rgba(0,122,255,.25)}
    #authModal .auth-msg{font-size:12px;color:#e11d48;min-height:16px}
    #authModal .auth-close{background:transparent}
    
    /* Auth state transitions */
    #authModal .auth-field{transition:all .25s var(--ease)}
    #authModal .auth-field.hidden{opacity:0;transform:translateY(-8px);max-height:0;margin:0;overflow:hidden}
    #authModal .auth-field.visible{opacity:1;transform:translateY(0);max-height:100px}
    
    /* Check email state */
    #authModal .check-email{text-align:center;padding:20px 0}
    #authModal .check-email-icon{font-size:48px;margin-bottom:16px;color:var(--accent)}
    #authModal .check-email-title{font-size:18px;font-weight:600;margin-bottom:8px;color:#0f172a}
    #authModal .check-email-text{color:#6b7280;font-size:14px;line-height:1.5;margin-bottom:20px}
    #authModal .check-email-back{background:transparent;color:var(--accent);border:1px solid var(--accent)}
  </style>
  <!-- Login/Register Modal -->
  <div id="authModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true">
      <div class="modal-head">
        <div>
          <h3>Sign in</h3>
        </div>
        <button id="authClose" class="btn auth-close" aria-label="Close">âœ•</button>
      </div>
      <div class="auth-body">
        <button id="authGoogle" class="btn btn-google" type="button" aria-label="Continue with Google">
          <img src="/Google_Favicon_2025.svg" alt="Google" width="18" height="18" style="display:inline-block"/>
          Continue with Google
        </button>
        <div class="auth-divider"><span>or</span></div>
        <div class="auth-tabs">
          <button id="authTabLogin" class="btn active" type="button">Login</button>
          <button id="authTabRegister" class="btn" type="button">Register</button>
        </div>
        <div id="authFormContainer">
          <form id="authForm" class="auth-form">
            <div class="auth-field hidden" id="authNameField">
              <label for="authName">Full name</label>
              <input id="authName" class="auth-input" placeholder="Full name" />
            </div>
            <div class="auth-field">
              <label for="authEmail">Email</label>
              <input id="authEmail" class="auth-input" placeholder="Email" type="email" required />
            </div>
            <div class="auth-field">
              <label for="authPassword">Password</label>
              <input id="authPassword" class="auth-input" placeholder="Password" type="password" required />
            </div>
            <button id="authSubmit" class="btn auth-primary" type="submit">Sign in</button>
            <div id="authMsg" class="auth-msg"></div>
          </form>
          
          <!-- Check email state -->
          <div id="checkEmailState" class="check-email" style="display:none">
            <div class="check-email-icon">ðŸ“§</div>
            <div class="check-email-title">Check your email</div>
            <div class="check-email-text">We've sent you a confirmation link. Please check your email and click the link to verify your account.</div>
            <button id="backToLogin" class="btn check-email-back">Back to Sign in</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</head>
<body class="no-js">
  <div class="shell">
    <div class="titlebar">
      <div class="title-logo" aria-label="Feels Local">
        <img src="./brand/FL-Logo2-Blue.svg" alt="Feels Local Logo" />
      </div>
      <div class="toolbar">
        <div class="toolbar-row" id="toolbarRow1">
          <!-- Row 1 order: New tab, History (injected), Language, Sign in -->
          <button id="addTextTabBtn" class="btn" title="New tab" data-i18n="new_tab">New Tab</button>
          <!-- History button will be injected before Language -->
          <button id="uiLangBtn" class="btn face-btn" aria-haspopup="dialog" aria-expanded="false" title="Change language">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.75" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M3 12h18M12 3a12 12 0 0 1 0 18M12 3a12 12 0 0 0 0 18"></path></svg>
          <span>En</span>
          </button>
          <button id="settingsBtn" class="btn" type="button" title="Settings">Settings</button>
          <button id="signInBtn" class="btn" type="button">Sign in</button>
          <button id="signOutBtnTop" class="btn" type="button" style="display:none">Sign out</button>
        </div>
        <div class="toolbar-row" id="toolbarRow2">
          <!-- Row 2 order: Split View, Brand Kit, Advanced Tools, Usage Meter -->
          <button id="toggleSplit" class="btn" type="button" disabled data-i18n="split_view">Split View</button>
          
          <!-- Compact Usage Meter (end of row 2) -->
          <div id="usageMini" class="usage-mini" role="button" aria-expanded="false" tabindex="0" aria-label="Monthly usage">
          <div class="usage-mini-main">
            <span id="usageMiniLabel" class="usage-mini-label">0 / 1,000</span>
            <div class="usage-mini-track" aria-hidden="true">
              <div id="usageMiniBar" class="usage-mini-bar"></div>
            </div>
          </div>
          <div id="usageMiniDropdown" class="usage-mini-dropdown" aria-hidden="true">
            <div class="usage-mini-panel scrollable">
              <div class="usage-mini-left">
                <div id="usageMiniPlan" class="usage-mini-plan">Free</div>
                <div class="usage-mini-reset">Resets <span id="usageMiniReset">â€”</span></div>
              </div>
              <div class="usage-mini-right"><span id="usageMiniPct" class="usage-mini-pct">0.0</span><span class="usage-mini-suffix">% used</span></div>
            </div>
          </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tabs bar -->
    <div class="tabs-wrap">
      <div id="tabBar" class="tabs" role="tablist" aria-label="Documents"></div>
    </div>
    <div class="card" id="cardRoot" aria-live="polite" aria-busy="false">
      <div id="modeWrap" class="mode-wrap">
        <!-- STACK (normal) -->
        <div id="stackArea" class="view active">
          <div class="section">
            <label class="label" for="inputText" data-i18n="input_label">Input Text</label>
            <textarea id="inputText" data-maxh="420" placeholder="Paste or write your text hereâ€¦"></textarea>
          </div>

          <div class="or-wrap"><span class="or" data-i18n="or">Or</span></div>
          <div class="section">
            <div id="dropzone" class="dropzone" role="button" tabindex="0" aria-label="Upload files">
              <input id="fileInput" type="file" accept=".txt,.srt,.docx,.pdf" multiple>
              <div>
                <div class="dz-hint" data-i18n="upload_hint">Drag & drop a .txt, .docx, .pdf, or .srt here</div>
                <div class="dz-sub" data-i18n="upload_sub">â€¦or click to browse</div>
              </div>
            </div>

            <!-- Badge hidden for tabs UI, kept for backward-compat -->
            <div id="fileBadgeWrap" class="section is-hidden">
              <span class="file-badge" id="fileBadge">
                <span id="fileMeta"></span>
                <button id="clearFile" class="kill" type="button">âœ•</button>
              </span>
            </div>
          </div>

          <div class="hr"></div>

          <div class="section">
            <div class="label" data-i18n="target_lang">Target Language</div>
            <div class="row" id="langButtonsRow"></div>
          </div>

          <div class="section">
            <div class="label" data-i18n="loc_style">Localization Style</div>
            <div class="row" id="styleButtonsRow"></div>
          </div>

          <div class="section is-hidden" id="subStyleContainer">
            <div class="substyle">
              <button type="button" class="substyle-trigger" id="substyleTrigger">
                <span id="substyleTitle" data-i18n="substyle">Sub-style</span>
                <span id="substyleChevron" class="chev">â–¾</span>
              </button>
              <div id="subStylePanel" class="substyle-panel">
                <div class="substyle-scroll">
                  <div id="chipsWrap" class="chips"></div>
                </div>
                <!-- Microcopy line lives here; created in JS -->
              </div>
            </div>
          </div>

          <div class="section" id="maxSection">
            <div id="maxRow" class="brand-toggle-section">
              <button id="maxToggle" class="brand-toggle" type="button" aria-pressed="false" title="Enable Gemini 2.5 Pro (Business only)"></button>
              <span class="brand-toggle-label">Max Localization</span>
            </div>
          </div>

          <div class="section">
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <button id="submitBtn" class="btn primary" type="button" data-i18n="submit">Submit</button>
              <button id="submitAllBtn" class="btn is-hidden" type="button" title="Submit all open files">Submit All</button>
              <span id="submitHints" style="font-size:12px;color:#006cff;display:none;margin-left:8px"></span>
            </div>
          </div>

          <div class="section">
            <label class="label" for="outputText" data-i18n="result_label">Result</label>
            <div class="output-wrapper" style="position:relative">
              <textarea id="outputText" data-maxh="420" readonly style="min-height:160px;"></textarea>
              <div id="outputRich" class="rich is-hidden" contenteditable="true" aria-label="Result editor"></div>
            </div>
            <div class="result-actions">
              <button id="copyBtn" class="ctl-btn copy-btn" title="Copy result">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="9" y="9" width="13" height="13" rx="3"></rect>
                  <rect x="2" y="2" width="13" height="13" rx="3"></rect>
                </svg>
                <span data-i18n="copy">Copy</span>
              </button>
              <button id="downloadInlineBtn" class="ctl-btn" type="button" title="Download localized" data-i18n="download_localized">Download</button>
              <button id="downloadAllInlineBtn" class="ctl-btn" type="button" title="Download all (.zip)" data-i18n="download_all_zip">Download all (.zip)</button>
              <div id="exportInlineMenu" class="export-menu" data-menu="export" data-placement="top">
                <button id="exportInlineToggle" class="ctl-btn export-toggle" type="button" aria-haspopup="true" aria-expanded="false" aria-controls="exportInlineDropdown">
                  <span data-i18n="export">Export</span>
                  <svg class="export-caret" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5" aria-hidden="true">
                    <path d="M3 4.5 6 7.5 9 4.5" stroke-linecap="round" stroke-linejoin="round"></path>
                  </svg>
                </button>
                <div id="exportInlineDropdown" class="export-dropdown" role="menu" aria-hidden="true">
                  <button class="export-option" type="button" data-format="pdf">
                    <span data-i18n="export_pdf">Export as PDF</span>
                    <span class="export-option-suffix">PDF</span>
                  </button>
                  <button class="export-option" type="button" data-format="docx">
                    <span data-i18n="export_docx">Export as DOCX</span>
                    <span class="export-option-suffix">DOCX</span>
                  </button>
                  <button class="export-option" type="button" data-format="txt">
                    <span data-i18n="export_txt">Export as TXT</span>
                    <span class="export-option-suffix">TXT</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- SPLIT -->
        <div id="splitArea" class="view">
          <div class="section">
            <div class="split-grid">
              <div class="paneCard">
                <div class="paneHead" data-i18n="pane_input">Input</div>
                <div id="segSrcBox" class="segbox" aria-label="Source segments"></div>
              </div>

              <div class="paneCard" id="resultPaneCard">
                <div class="paneHead" data-i18n="pane_result">Result</div>
                <div id="segTgtBox" class="segbox" aria-label="Target segments"></div>
              </div>
            </div>

            <div class="split-footer">
              <div class="label">Tip: Split View shows sentence lines with timecodes (SRT) and word &amp; character counts for QA.</div>
              <div style="display:flex;gap:8px;flex-wrap:nowrap;align-items:center">
                <button id="copySplitBtn" class="ctl-btn copy-btn" title="Copy result" aria-label="Copy result">
                  <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="3"></rect>
                    <rect x="2" y="2" width="13" height="13" rx="3"></rect>
                  </svg>
                  <span data-i18n="copy">Copy</span>
                </button>
                <button id="downloadSplitBtn" class="ctl-btn" type="button" title="Download localized" data-i18n="download_localized">Download</button>
                <button id="downloadAllSplitBtn" class="ctl-btn" type="button" title="Download all (.zip)" data-i18n="download_all_zip">Download all (.zip)</button>
                <div id="exportSplitMenu" class="export-menu" data-menu="export" data-placement="top">
                  <button id="exportSplitToggle" class="ctl-btn export-toggle" type="button" aria-haspopup="true" aria-expanded="false" aria-controls="exportSplitDropdown">
                    <span data-i18n="export">Export</span>
                    <svg class="export-caret" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5" aria-hidden="true">
                      <path d="M3 4.5 6 7.5 9 4.5" stroke-linecap="round" stroke-linejoin="round"></path>
                    </svg>
                  </button>
                  <div id="exportSplitDropdown" class="export-dropdown" role="menu" aria-hidden="true">
                    <button class="export-option" type="button" data-format="pdf">
                      <span data-i18n="export_pdf">Export as PDF</span>
                      <span class="export-option-suffix">PDF</span>
                    </button>
                    <button class="export-option" type="button" data-format="docx">
                      <span data-i18n="export_docx">Export as DOCX</span>
                      <span class="export-option-suffix">DOCX</span>
                    </button>
                    <button class="export-option" type="button" data-format="txt">
                      <span data-i18n="export_txt">Export as TXT</span>
                      <span class="export-option-suffix">TXT</span>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="glassLoader" class="glass" aria-hidden="true">
        <div class="glass-content">
          <div class="ring"></div>
          <div class="glass-text">Localizingâ€¦</div>
        </div>
      </div>
    </div>
    <!-- Settings Page -->
    <div id="settingsPage" class="settings-page" aria-labelledby="settingsTitle">
      <div class="settings-container">
        <div class="settings-inner">
          <!-- Logo Header -->
          <div class="settings-logo">
            <img src="./brand/FL-Logo2-Blue.svg" alt="Feels Local Logo" />
          </div>
          
          <!-- Main Container with Header and Content -->
          <div class="settings-main-container">
            <!-- Navigation Header -->
            <div class="settings-header">
              <div class="settings-nav-header">
                <button id="settingsBackTop" class="settings-back">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7"/>
                  </svg>
                </button>
                <span class="settings-back-text"style="font-size:16px;">Back</span>
              </div>
              <div class="settings-title"style="font-size:16px;">Settings</div>
            </div>
            
            <!-- Main Content Grid -->
            <div class="settings-main">
            <nav class="settings-sidebar" aria-label="Settings">
              <div class="settings-nav">
                <button class="settings-link active" data-target="#secProfile">Profile</button>
                <button class="settings-link" data-target="#secBilling">Billing & Subscription</button>
                <button class="settings-link" data-target="#secSecurity">Security</button>
                <button class="settings-link" data-target="#secA11y">Accessibility</button>
              </div>
            </nav>
            <div class="settings-content">
          <section id="secProfile" class="settings-section" tabindex="-1">
            <!-- Name Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 4px">Name</h3>
              <p style="font-size:12px; color:var(--text); margin:0 0 8px">The name associated with this account</p>
              <input id="profileDisplayName" class="settings-input" value="" style="width:400px; height:32px; padding:10px 12px; font-size:14px" />
            </div>
            
            <!-- Email Address Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 4px">Email address</h3>
              <p style="font-size:12px; color:var(--text); margin:0 0 8px">The email address associated with this account</p>
              <div style="display:flex; gap:12px; align-items:flex-end">
                <input id="profileEmail" class="settings-input" value="" disabled style="width:400px; height:32px; padding:10px 12px; font-size:14px; background:#f6f6f2; color:var(--muted)" />
                <button class="settings-btn" id="emailVerifyBtn" type="button" style="height:32px; padding:8px 14px; font-size:14px; border-radius:10px; background:#F6F6F2; border-color:#EAEAEA; color:#000000; display:flex; align-items:center; justify-content:center">Verify</button>
              </div>
            </div>
            
            <!-- Save Button -->
            <div style="margin-bottom:30px; display:flex; align-items:center; gap:12px;">
              <button id="saveProfileBtn" class="settings-btn primary" style="height:32px; padding:8px 14px; font-size:14px; border-radius:10px; display:flex; align-items:center; justify-content:center">Save</button>
              <span id="saveProfileStatus" style="display:none; font-size:14px; color:#006cff;">Saved!</span>
            </div>
            
            <!-- Delete Account Section -->
            <div style="border-top:1px solid var(--border); padding-top:20px">
              <h3 style="color:#ff0000; font-size:16px; font-weight:500; margin:0 0 4px">Delete account</h3>
              <p style="font-size:12px; color:var(--text); margin:0 0 12px">Deleting your account is permanent and cannot be undone.</p>
              <button id="deleteAccountBtn" class="settings-btn danger" style="height:32px; padding:8px 14px; font-size:14px; border-radius:10px; display:flex; align-items:center; justify-content:center">Delete account</button>
            </div>
          </section>

          <section id="secBilling" class="settings-section" tabindex="-1">
            <!-- Plan Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 8px">Plan</h3>
              <div style="background:#f6f6f2; border:1px solid #eaeaea; border-radius:11px; padding:20px;">
                <div style="display:flex; align-items:flex-end; justify-content:space-between; gap:20px;">
                  <div style="flex:1;">
                    <div style="display:flex; align-items:baseline; gap:8px; margin-bottom:12px;">
                      <span id="planName" style="font-size:24px; font-weight:500; color:#006cff;">Free</span>
                      <span style="font-size:14px; color:var(--text);">Current plan</span>
                    </div>
                    <div id="planUsagePct" style="font-size:14px; color:var(--text); margin-bottom:8px;">70% Characters used</div>
                    <div class="usage-mini-track" style="width:100%; height:8px; background:#d9d9d9; border-radius:100px; overflow:hidden;">
                      <div id="planUsageBar" class="usage-mini-bar" style="height:100%; width:70%; background:#e56e21; border-radius:100px; transition:width .35s cubic-bezier(.22,.61,.36,1);"></div>
                    </div>
                  </div>
                  <div style="text-align:right;">
                    <div id="planPrice" style="font-size:24px; font-weight:400; color:var(--text); margin-bottom:8px;">$0</div>
                    <button id="planUpgradeBtn" style="background:#006cff; color:white; border:none; border-radius:10px; padding:8px 14px; font-size:14px; height:32px; cursor:pointer;">Upgrade</button>
                  </div>
                </div>
              </div>
            </div>

            <!-- Billing Details Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 8px">Billing details</h3>
              <div style="background:#f6f6f2; border:1px solid #eaeaea; border-radius:11px; padding:20px;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:16px;">
                  <div>
                    <div style="font-size:14px; color:#006cff; margin-bottom:4px;">Email address</div>
                    <div id="billingSummaryEmail" style="font-size:14x; color:var(--text);"></div>
                  </div>
                  <div>
                    <div style="font-size:14px; color:#006cff; margin-bottom:4px;">Address</div>
                    <div id="billingSummaryAddress" style="font-size:14x; color:var(--text);"></div>
                  </div>
                </div>
                <div style="margin-bottom:14px;">
                  <div style="font-size:14px; color:#006cff; margin-bottom:4px;">Payment method</div>
                  <div id="billingSummaryPayment" style="font-size:14x; color:var(--text);"></div>
              </div>
                </div>
              <div style="text-align:right; margin-top:12px;">
                <button id="openBillingDialog" style="background:#006cff; color:white; border:none; border-radius:10px; padding:8px 14px; font-size:14px; height:32px; cursor:pointer;">Update billing details</button>
              </div>
            </div>

            <!-- Invoices Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 8px">Invoices</h3>
              <div style="background:#f6f6f2; border:1px solid #eaeaea; border-radius:11px; padding:20px;">
                <div style="overflow-x:auto;">
                  <table class="inv-table" style="width:100%; border-collapse:separate; border-spacing:0;">
                <thead>
                  <tr>
                        <th style="text-align:left; font-size:16px; color:#006cff; padding:8px 0; border-bottom:1px solid #eaeaea;">Invoice</th>
                        <th style="text-align:left; font-size:16px; color:#006cff; padding:8px 0; border-bottom:1px solid #eaeaea;">Status</th>
                        <th style="text-align:left; font-size:16px; color:#006cff; padding:8px 0; border-bottom:1px solid #eaeaea;">Amount</th>
                        <th style="text-align:left; font-size:16px; color:#006cff; padding:8px 0; border-bottom:1px solid #eaeaea;">Date</th>
                        <th style="text-align:left; font-size:16px; color:#006cff; padding:8px 0; border-bottom:1px solid #eaeaea;"></th>
                  </tr>
                </thead>
                <tbody id="invoicesBody"></tbody>
              </table>
                  <div class="settings-muted" id="invoicesEmpty" style="display:block;">No invoices yet</div>
                </div>
              </div>
            </div>
          </section>

          <section id="secSecurity" class="settings-section" tabindex="-1">
            <!-- Two-Factor Authentication Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 8px">Two-Factor authentication</h3>
              <div style="background:#f6f6f2; border:1px solid #eaeaea; border-radius:11px; padding:10px;">
                <div style="display:flex; align-items:center; justify-content:space-between;">
                  <span style="font-size:16px; color:var(--text);">Disabled</span>
                  <button id="add2FABtn" style="background:#006cff; color:white; border:none; border-radius:7px; padding:6px 12px; font-size:14x; cursor:pointer;">Add Two-Factor authentication</button>
              </div>
                </div>
              </div>

            <!-- Change Password Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 8px">Change password</h3>
              <div style>
                <!-- Current Password -->
                <div style="margin-bottom:16px;">
                  <label style="font-size:14px; color:var(--text); margin-bottom:4px; display:block;">Current password</label>
                  <div style="display:flex; align-items:center; gap:8px;">
                    <input id="currentPassword" type="password" value="" style="flex:1; border:2px solid #eaeaea; border-radius:10px; height:28px; padding:0 11px; font: size 14px; background:#fff;" />
                    <button id="showCurrentPw" type="button" style="background:none; border:none; color:var(--text); font-size:14px; cursor:pointer; padding:4px 8px;">Show</button>
            </div>
            </div>
                
                <!-- New Password -->
                <div style="margin-bottom:16px;">
                  <label style="font-size:14px; color:var(--text); margin-bottom:4px; display:block;">New password</label>
                  <div style="display:flex; align-items:center; gap:8px;">
                    <input id="newPassword" type="password" style="flex:1; border:2px solid #eaeaea; border-radius:10px; height:28px; padding:0 11px; font-size:14px; background:#fff;" />
                    <button id="showNewPw" type="button" style="background:none; border:none; color:var(--text); font-size:14px; cursor:pointer; padding:4px 8px;">Hide</button>
                  </div>
                </div>
                
                <!-- Confirm New Password -->
                <div style="margin-bottom:20px;">
                  <label style="font-size:14px; color:var(--text); margin-bottom:4px; display:block;">Confirm new password</label>
                  <div style="display:flex; align-items:center; gap:8px;">
                    <input id="confirmPassword" type="password" style="flex:1; border:2px solid #eaeaea; border-radius:10px; height:28px; padding:0 11px; font-size:14px; background:#fff;" />
                    <button id="showConfirmPw" type="button" style="background:none; border:none; color:var(--text); font-size:14px; cursor:pointer; padding:4px 8px;">Hide</button>
                </div>
              </div>
              
                    </div>
              <div style="text-align:left; margin-top:12px;">
                <button id="changePasswordBtn" style="background:#006cff; color:white; border:none; border-radius:7px; padding:6px 12px; font-size:14px; cursor:pointer;">Change password</button>
                  </div>
            </div>

            <!-- Log Out Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 8px">Log out from all device</h3>
              <p style="font-size:12px; color:var(--text); margin:0 0 16px; line-height:1.4;">This will log out your account from all devices connected.</p>
              <div style="text-align:left;">
                <button id="logoutAllBtn" style="background:#ff0000; color:white; border:none; border-radius:7px; padding:6px 12px; font-size:14px; font-weight:bold; cursor:pointer;">Log out</button>
                </div>
              </div>
            </section>

          <section id="secA11y" class="settings-section" tabindex="-1">
            <!-- Appearance Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 12px">Appearance</h3>
              <div style="display:flex; gap:8px;">
                <button id="themeAuto" class="theme-btn active" style="background:#F6F6F2; color:var(--text); border:2px solid #006cff; border-radius:7px; padding:8px 16px; font-size:14px; cursor:pointer; font-weight:500;">Auto</button>
                <button id="themeLight" class="theme-btn" style="background:#FFFFFF; color:var(--text); border:2px solid #eaeaea; border-radius:7px; padding:8px 16px; font-size:14px; cursor:pointer;">Light</button>
                <button id="themeDark" class="theme-btn" style="background:#000000; color:white; border:2px solid #eaeaea; border-radius:7px; padding:8px 16px; font-size:14px; cursor:pointer;">Dark</button>
            </div>
          </div>

            <!-- Reduced Motion Section -->
            <div style="margin-bottom:20px">
              <h3 style="font-size:16px; font-weight:500; color:var(--text); margin:0 0 12px">Reduced motion</h3>
              <label class="switch" style="position:relative; display:inline-block; width:44px; height:24px;">
                <input id="a11yReduceMotion" type="checkbox" style="opacity:0; width:0; height:0;" />
                <span class="slider" style="position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background:#ccc; border-radius:24px; transition:.4s; display:block;"></span>
              </label>
            </div>
          </section>
            </div>
          </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Billing Dialog -->
    <div id="billingDialog" class="billing-dialog-backdrop" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="billing-dialog-card">
        <!-- Header -->
        <div style="margin-bottom:16px">
                    <h3 style="margin:0; font-size:20px; font-weight:500; color:#006cff;">Add payment method</h3>
        </div>

        <!-- Description -->
        <div style="margin-bottom:16px">
          <p style="font-size:12px; color:var(--text); margin:0; line-height:1.3;">Add your credit card details below. This card will be saved to<br>your account and can be removed at any time.</p>
        </div>
        
        <!-- Card Information Section -->
        <div style="margin-bottom:20px">
          <h4 style="font-size:14px; font-weight:500; color:var(--text); margin:0 0 12px;">Card Information</h4>
          <div class="billing-card-inputs">
            <input id="cardNumberInput" class="billing-input billing-card-number" placeholder="Card number" maxlength="19" />
            <input id="expiryInput" class="billing-input billing-expiry" placeholder="MM/YY" maxlength="5" />
            <input id="cvvInput" class="billing-input billing-cvv" placeholder="CVC" maxlength="4" />
          </div>
        </div>
        
                <!-- Name on Card -->
        <div style="margin-bottom:20px">
          <h4 style="font-size:14px; font-weight:500; color:var(--text); margin:0 0 12px;">Name on card</h4>
          <input class="billing-input" placeholder="" style="width:100%;" />
          </div>

        <!-- Billing Address Section -->
        <div style="margin-bottom:20px">
          <h4 style="font-size:14px; font-weight:500; color:var(--text); margin:0 0 12px;">Billing address</h4>
          <div style="margin-bottom:12px; position:relative;">
            <select class="billing-input billing-country-select" style="width:100%;">
              <option value="">Select country</option>
              <option value="AF">Afghanistan</option>
              <option value="AL">Albania</option>
              <option value="AR">Argentina</option>
              <option value="AU">Australia</option>
              <option value="AT">Austria</option>
              <option value="BH">Bahrain</option>
              <option value="BD">Bangladesh</option>
              <option value="BY">Belarus</option>
              <option value="BE">Belgium</option>
              <option value="BO">Bolivia</option>
              <option value="BA">Bosnia and Herzegovina</option>
              <option value="BW">Botswana</option>
              <option value="BR">Brazil</option>
              <option value="BN">Brunei</option>
              <option value="BG">Bulgaria</option>
              <option value="KH">Cambodia</option>
              <option value="CA">Canada</option>
              <option value="CL">Chile</option>
              <option value="CN">China</option>
              <option value="CO">Colombia</option>
              <option value="HR">Croatia</option>
              <option value="CY">Cyprus</option>
              <option value="CZ">Czech Republic</option>
              <option value="DK">Denmark</option>
              <option value="EC">Ecuador</option>
              <option value="EG">Egypt</option>
              <option value="EE">Estonia</option>
              <option value="SZ">Eswatini</option>
              <option value="FI">Finland</option>
              <option value="FR">France</option>
              <option value="GF">French Guiana</option>
              <option value="DE">Germany</option>
              <option value="GH">Ghana</option>
              <option value="GR">Greece</option>
              <option value="GY">Guyana</option>
              <option value="HK">Hong Kong</option>
              <option value="HU">Hungary</option>
              <option value="IN">India</option>
              <option value="ID">Indonesia</option>
              <option value="IR">Iran</option>
              <option value="IQ">Iraq</option>
              <option value="IE">Ireland</option>
              <option value="IL">Israel</option>
              <option value="IT">Italy</option>
              <option value="JP">Japan</option>
              <option value="JO">Jordan</option>
              <option value="KZ">Kazakhstan</option>
              <option value="KE">Kenya</option>
              <option value="XK">Kosovo</option>
              <option value="KW">Kuwait</option>
              <option value="KG">Kyrgyzstan</option>
              <option value="LA">Laos</option>
              <option value="LV">Latvia</option>
              <option value="LB">Lebanon</option>
              <option value="LS">Lesotho</option>
              <option value="LT">Lithuania</option>
              <option value="MY">Malaysia</option>
              <option value="MW">Malawi</option>
              <option value="MT">Malta</option>
              <option value="MX">Mexico</option>
              <option value="MD">Moldova</option>
              <option value="MN">Mongolia</option>
              <option value="ME">Montenegro</option>
              <option value="MZ">Mozambique</option>
              <option value="MM">Myanmar</option>
              <option value="NA">Namibia</option>
              <option value="NP">Nepal</option>
              <option value="NL">Netherlands</option>
              <option value="NG">Nigeria</option>
              <option value="MK">North Macedonia</option>
              <option value="NO">Norway</option>
              <option value="OM">Oman</option>
              <option value="PK">Pakistan</option>
              <option value="PS">Palestine</option>
              <option value="PY">Paraguay</option>
              <option value="PE">Peru</option>
              <option value="PH">Philippines</option>
              <option value="PL">Poland</option>
              <option value="PT">Portugal</option>
              <option value="QA">Qatar</option>
              <option value="RO">Romania</option>
              <option value="RU">Russia</option>
              <option value="SA">Saudi Arabia</option>
              <option value="RS">Serbia</option>
              <option value="SG">Singapore</option>
              <option value="SK">Slovakia</option>
              <option value="SI">Slovenia</option>
              <option value="ZA">South Africa</option>
              <option value="KR">South Korea</option>
              <option value="ES">Spain</option>
              <option value="LK">Sri Lanka</option>
              <option value="SR">Suriname</option>
              <option value="SE">Sweden</option>
              <option value="CH">Switzerland</option>
              <option value="SY">Syria</option>
              <option value="TW">Taiwan</option>
              <option value="TJ">Tajikistan</option>
              <option value="TZ">Tanzania</option>
              <option value="TH">Thailand</option>
              <option value="TR">Turkey</option>
              <option value="TM">Turkmenistan</option>
              <option value="UG">Uganda</option>
              <option value="UA">Ukraine</option>
              <option value="AE">United Arab Emirates</option>
              <option value="GB">United Kingdom</option>
              <option value="US">United States</option>
              <option value="UY">Uruguay</option>
              <option value="UZ">Uzbekistan</option>
              <option value="VE">Venezuela</option>
              <option value="VN">Vietnam</option>
              <option value="YE">Yemen</option>
              <option value="ZM">Zambia</option>
              <option value="ZW">Zimbabwe</option>
            </select>
          </div>
          <div style="margin-bottom:12px">
            <input class="billing-input" placeholder="Address line 1" style="width:100%;" />
          </div>
          <div style="margin-bottom:12px">
            <input class="billing-input" placeholder="Address line 2" style="width:100%;" />
          </div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px; margin-bottom:12px;">
            <input class="billing-input" placeholder="City" style="width:100%;" />
            <input class="billing-input" placeholder="Postal Code" style="width:100%;" />
          </div>
          <input class="billing-input" placeholder="State, county, province, or region" style="width:100%;" />
        </div>
        
        <!-- Default Payment Method Checkbox -->
        <div style="margin-bottom:24px">
          <label class="billing-checkbox-wrapper">
            <input type="checkbox" class="billing-checkbox-input" />
            <span class="billing-checkbox-custom"></span>
            <span style="font-size:14px; color:var(--text);">Set as default payment method</span>
          </label>
        </div>
        
        <!-- Action Buttons -->
        <div style="display:flex; gap:12px; justify-content:flex-end;">
          <button id="billingCancel" class="billing-btn billing-btn-cancel" style="height:32px; padding:8px 14px; font-size:14px; border-radius:7px;">Cancel</button>
          <button id="billingSave" class="billing-btn billing-btn-primary" style="height:32px; padding:8px 14px; font-size:14px; border-radius:7px;">Add payment method</button>
        </div>
      </div>
    </div>
  </div>

  <div id="notificationHost" class="notification-host" aria-live="polite" aria-atomic="true"></div>

  <!-- Language overlay -->
  <div id="langOverlay" class="lang-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="lang-sheet" role="document">
      <div class="lang-head">
        <div class="lang-title" data-i18n="choose_lang">Select your language</div>
        <button class="lang-close" id="langCloseBtn" aria-label="Close">âœ•</button>
      </div>
      <div class="lang-grid" id="langGrid"></div>
    </div>
  </div>
  <!-- GSAP for animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script>
    /* =======================
       0) Style labels + MICROCOPY
       ======================= */

    // STYLE_I18N: localized style & sub-style labels used by buttons/chips
    // (EN, ID, ZH, FR, ES)
    window.STYLE_I18N = {
      en: {
        style: {
          formal:"Formal", casual:"Casual", marketing:"Marketing", dubbing:"Dubbing",
          creative:"Creative", technical:"Technical", legal:"Legal", medical:"Medical",
          journalistic:"Journalistic", corporate:"Corporate", entertainment:"Entertainment", educational:"Educational"
        },
        sub: {
          general:"General", academic:"Academic", scientific:"Scientific",
          chat:"Chat", gaming:"Gaming", "street-talk":"Street Talk", "social-media":"Social Media",
          promotional:"Promotional", persuasive:"Persuasive", "product-descriptions":"Product Description",
          "brand-storytelling":"Brand Storytelling", "seo-friendly":"SEOâ€‘Friendly", "email-campaigns":"Email Campaigns",
          "event-promotion":"Event Promotion", "influencer-ugc-style":"Influencer/UGC Style",
          dialogue:"Dialogue", narration:"Narration",
          "literary-adaptation":"Literary Adaptation", "slogan-tagline-writing":"Slogan/Tagline Writing",
          "poetic-tone":"Poetic Tone", "narrative-prose":"Narrative Prose",
          "software-documentation":"Software Documentation", "engineering-manuals":"Engineering Manuals",
          "product-specs":"Product Specs", "api-guides":"API Guides",
          contracts:"Contracts", "terms-conditions":"Terms & Conditions", "compliance-docs":"Compliance Docs",
          "privacy-policies":"Privacy Policies", constitutional:"Constitutional",
          "patient-friendly-explanation":"Patientâ€‘friendly Explanation", "research-abstracts":"Research Abstracts",
          "clinical-documentation":"Clinical Documentation", "health-campaigns":"Health Campaigns",
          "news-reports":"News Reports", "editorial-opinion":"Editorial Opinion", "feature-articles":"Feature Articles",
          "press-releases":"Press Releases", "internal-communications":"Internal Communications",
          "investor-relations":"Investor Relations", "annual-reports":"Annual Reports",
          "professional-presentations":"Professional Presentations",
          subtitling:"Subtitling", screenwriting:"Screenwriting", "script-adaptation":"Script Adaptation", "character-dialogue":"Character Dialogue",
          "e-learning":"Eâ€‘learning", "step-by-step-guides":"Stepâ€‘byâ€‘step Guides", "academic-tutorials":"Academic Tutorials", "test-preparation":"Test Preparation"
        }
      },
      id: {
        style: {
          formal:"Formal", casual:"Kasual", marketing:"Pemasaran", dubbing:"Dubbing",
          creative:"Kreatif", technical:"Teknis", legal:"Hukum", medical:"Medis",
          journalistic:"Jurnalistik", corporate:"Korporat", entertainment:"Hiburan", educational:"Edukasi"
        },
        sub: {
          general:"Umum", academic:"Akademik", scientific:"Ilmiah",
          chat:"Obrolan", gaming:"Gim", "street-talk":"Bahasa Jalanan", "social-media":"Media Sosial",
          promotional:"Promosi", persuasive:"Persuasif", "product-descriptions":"Deskripsi Produk",
          "brand-storytelling":"Kisah Merek", "seo-friendly":"Ramah SEO", "email-campaigns":"Kampanye Email",
          "event-promotion":"Promosi Acara", "influencer-ugc-style":"Gaya Influencer/UGC",
          dialogue:"Dialog", narration:"Narasi",
          "literary-adaptation":"Adaptasi Sastra", "slogan-tagline-writing":"Slogan/Tagline",
          "poetic-tone":"Nada Puitis", "narrative-prose":"Prosa Naratif",
          "software-documentation":"Dokumentasi Perangkat Lunak", "engineering-manuals":"Manual Teknik",
          "product-specs":"Spesifikasi Produk", "api-guides":"Panduan API",
          contracts:"Kontrak", "terms-conditions":"Syarat & Ketentuan", "compliance-docs":"Dokumen Kepatuhan",
          "privacy-policies":"Kebijakan Privasi", constitutional:"Konstitusional",
          "patient-friendly-explanation":"Penjelasan Ramah Pasien", "research-abstracts":"Abstrak Riset",
          "clinical-documentation":"Dokumentasi Klinis", "health-campaigns":"Kampanye Kesehatan",
          "news-reports":"Laporan Berita",
          "editorial-opinion":"Opini Editorial", "feature-articles":"Artikel Fitur",
          "press-releases":"Siaran Pers", "internal-communications":"Komunikasi Internal",
          "investor-relations":"Hubungan Investor", "annual-reports":"Laporan Tahunan",
          "professional-presentations":"Presentasi Profesional",
          subtitling:"Subtitel", screenwriting:"Penulisan Skenario", "script-adaptation":"Adaptasi Naskah", "character-dialogue":"Dialog Karakter",
          "e-learning":"Eâ€‘learning", "step-by-step-guides":"Panduan Langkah Demi Langkah", "academic-tutorials":"Tutorial Akademik", "test-preparation":"Persiapan Ujian"
        }
      },
      zh: {
        style: {
          formal:"æ­£å¼", casual:"æ—¥å¸¸", marketing:"å¸‚åœºè¥é”€", dubbing:"é…éŸ³",
          creative:"åˆ›æ„", technical:"æŠ€æœ¯", legal:"æ³•å¾‹", medical:"åŒ»å­¦",
          journalistic:"æ–°é—»", corporate:"ä¼ä¸š", entertainment:"å¨±ä¹", educational:"æ•™è‚²"
        },
        sub: {
          general:"é€šç”¨", academic:"å­¦æœ¯", scientific:"ç§‘å­¦",
          chat:"èŠå¤©", gaming:"æ¸¸æˆ", "street-talk":"è¡—å¤´å£è¯­", "social-media":"ç¤¾äº¤åª’ä½“",
          promotional:"ä¿ƒé”€", persuasive:"è¯´æœåž‹", "product-descriptions":"äº§å“æè¿°",
          "brand-storytelling":"å“ç‰Œæ•…äº‹", "seo-friendly":"SEO å‹å¥½", "email-campaigns":"ç”µå­é‚®ä»¶è¥é”€",
          "event-promotion":"æ´»åŠ¨æŽ¨å¹¿", "influencer-ugc-style":"KOL/UGC é£Žæ ¼",
          dialogue:"å¯¹è¯", narration:"æ—ç™½",
          "literary-adaptation":"æ–‡å­¦æ”¹å†™", "slogan-tagline-writing":"å£å·/æ ‡è¯­",
          "poetic-tone":"è¯—æ„è¯­è°ƒ", "narrative-prose":"å™äº‹æ•£æ–‡",
          "software-documentation":"è½¯ä»¶æ–‡æ¡£", "engineering-manuals":"å·¥ç¨‹æ‰‹å†Œ",
          "product-specs":"äº§å“è§„æ ¼", "api-guides":"API æŒ‡å—",
          contracts:"åˆåŒ", "terms-conditions":"æ¡æ¬¾ä¸Žæ¡ä»¶", "compliance-docs":"åˆè§„æ–‡ä»¶",
          "privacy-policies":"éšç§æ”¿ç­–", constitutional:"å®ªæ³•ç±»",
          "patient-friendly-explanation":"æ‚£è€…æ˜“æ‡‚è¯´æ˜Ž", "research-abstracts":"ç ”ç©¶æ‘˜è¦",
          "clinical-documentation":"ä¸´åºŠæ–‡æ¡£", "health-campaigns":"å¥åº·å®£ä¼ ",
          "news-reports":"æ–°é—»æŠ¥é“", "editorial-opinion":"ç¤¾è®º/è¯„è®º", "feature-articles":"ç‰¹å†™æŠ¥é“",
          "press-releases":"æ–°é—»ç¨¿", "internal-communications":"å†…éƒ¨æ²Ÿé€š",
          "investor-relations":"æŠ•èµ„è€…å…³ç³»", "annual-reports":"å¹´åº¦æŠ¥å‘Š",
          "professional-presentations":"ä¸“ä¸šæ¼”ç¤º",
          subtitling:"å­—å¹•", screenwriting:"ç¼–å‰§", "script-adaptation":"å‰§æœ¬æ”¹ç¼–", "character-dialogue":"äººç‰©å¯¹ç™½",
          "e-learning":"åœ¨çº¿å­¦ä¹ ", "step-by-step-guides":"æ­¥éª¤æŒ‡å—", "academic-tutorials":"å­¦æœ¯æ•™ç¨‹", "test-preparation":"è€ƒè¯•å‡†å¤‡"
        }
      },
      fr: {
        style: {
          formal:"Formel", casual:"DÃ©contractÃ©", marketing:"Marketing", dubbing:"Doublage",
          creative:"CrÃ©atif", technical:"Technique", legal:"Juridique", medical:"MÃ©dical",
          journalistic:"Journalistique", corporate:"Entreprise", entertainment:"Divertissement", educational:"Ã‰ducatif"
        },
        sub: {
          general:"GÃ©nÃ©ral", academic:"AcadÃ©mique", scientific:"Scientifique",
          chat:"Discussion", gaming:"Jeu vidÃ©o", "street-talk":"Argot de rue", "social-media":"RÃ©seaux sociaux",
          promotional:"Promotionnel", persuasive:"Persuasif", "product-descriptions":"Descriptions produit",
          "brand-storytelling":"Narration de Marque",
          "seo-friendly":"OptimisÃ© SEO", "email-campaigns":"Campagnes eâ€‘mail",
          "event-promotion":"Promotion d'Ã©vÃ©nement", "influencer-ugc-style":"Style influenceur/UGC",
          dialogue:"Dialogue", narration:"Narration",
          "literary-adaptation":"Adaptation littÃ©raire", "slogan-tagline-writing":"Slogan/Baseline",
          "poetic-tone":"Ton poÃ©tique", "narrative-prose":"Prose narrative",
          "software-documentation":"Documentation logicielle", "engineering-manuals":"Manuels d'ingÃ©nierie",
          "product-specs":"SpÃ©cifications produit", "api-guides":"Guides API",
          contracts:"Contrats", "terms-conditions":"Conditions gÃ©nÃ©rales", "compliance-docs":"Documents de conformitÃ©",
          "privacy-policies":"Politiques de confidentialitÃ©", constitutional:"Constitutionnel",
          "patient-friendly-explanation":"Explication accessible au patient", "research-abstracts":"RÃ©sumÃ©s de recherche",
          "clinical-documentation":"Documentation clinique", "health-campaigns":"Campagnes de santÃ©",
          "news-reports":"Comptesâ€‘rendus", "editorial-opinion":"Tribune/Opinion", "feature-articles":"Articles de fond",
          "press-releases":"CommuniquÃ©s de presse", "internal-communications":"Communications internes",
          "investor-relations":"Relations investisseurs", "annual-reports":"Rapports annuels",
          "professional-presentations":"PrÃ©sentations professionnelles",
          subtitling:"Sousâ€‘titres", screenwriting:"Ã‰criture de scÃ©nario", "script-adaptation":"Adaptation de script", "character-dialogue":"Dialogue de personnage",
          "e-learning":"Eâ€‘learning", "step-by-step-guides":"Guides pas Ã  pas", "academic-tutorials":"Tutoriels acadÃ©miques", "test-preparation":"PrÃ©paration aux examens"
        }
      },
      es: {
        style: {
          formal:"Formal", casual:"Casual", marketing:"Marketing", dubbing:"Doblaje",
          creative:"Creativo", technical:"TÃ©cnico", legal:"Legal", medical:"MÃ©dico",
          journalistic:"PeriodÃ­stico", corporate:"Corporativo", entertainment:"Entretenimiento", educational:"Educativo"
        },
        sub: {
          general:"General", academic:"AcadÃ©mico", scientific:"CientÃ­fico",
          chat:"Chat", gaming:"Videojuegos", "street-talk":"Jerga callejera", "social-media":"Redes sociales",
          promotional:"Promocional", persuasive:"Persuasivo", "product-descriptions":"Descripciones de producto",
          "brand-storytelling":"Narrativa de Marca",
          "seo-friendly":"Optimizado para SEO", "email-campaigns":"CampaÃ±as de correo",
          "event-promotion":"PromociÃ³n de eventos", "influencer-ugc-style":"Estilo influencer/UGC",
          dialogue:"DiÃ¡logo", narration:"NarraciÃ³n",
          "literary-adaptation":"AdaptaciÃ³n literaria", "slogan-tagline-writing":"Slogan/Tagline",
          "poetic-tone":"Tono poÃ©tico", "narrative-prose":"Prosa narrativa",
          "software-documentation":"DocumentaciÃ³n de software", "engineering-manuals":"Manuales de ingenierÃ­a",
          "product-specs":"Especificaciones de producto", "api-guides":"GuÃ­as de API",
          contracts:"Contratos", "terms-conditions":"TÃ©rminos y condiciones", "compliance-docs":"Documentos de cumplimiento",
          "privacy-policies":"PolÃ­ticas de privacidad", constitutional:"Constitucional",
          "patient-friendly-explanation":"ExplicaciÃ³n para pacientes", "research-abstracts":"ResÃºmenes de investigaciÃ³n",
          "clinical-documentation":"DocumentaciÃ³n clÃ­nica", "health-campaigns":"CampaÃ±as de salud",
          "news-reports":"Noticias", "editorial-opinion":"OpiniÃ³n editorial", "feature-articles":"ArtÃ­culos de fondo",
          "press-releases":"Notas de prensa", "internal-communications":"Comunicaciones internas",
          "investor-relations":"Relaciones con inversionistas", "annual-reports":"Informes anuales",
          "professional-presentations":"Presentaciones profesionales",
          subtitling:"Subtitulado", screenwriting:"Guion cinematogrÃ¡fico", "script-adaptation":"AdaptaciÃ³n de guion", "character-dialogue":"DiÃ¡logo de personaje",
          "e-learning":"Eâ€‘learning", "step-by-step-guides":"GuÃ­as paso a paso", "academic-tutorials":"Tutoriales acadÃ©micos", "test-preparation":"PreparaciÃ³n para exÃ¡menes"
        }
      }
    };
    // Full microcopy dictionary (EN/ID/ZH/FR/ES)
window.STYLE_MICROCOPY = {
  en: {
    formal: {
      general: "For professional documents and public communication.",
      academic: "For research papers, articles, theses, and books.",
      scientific: "For research papers, abstracts, lab reports, and methods."
    },
    casual: {
      general: "For everyday messages that read simple and friendly.",
      "social-media": "For captions and posts with short lines and hashtags.",
      chat: "For quick, conversational replies. Emojis allowed.",
      gaming: "For gamer slang, short callouts, and team banter.",
      "street-talk": "For casual slang and local flavor. Keep it respectful.",
    },
    marketing: {
      general: "For on-brand marketing text across channels.",
      promotional: "For offers and sales. Clear headlines and urgency.",
      persuasive: "For benefit-focused copy with a strong call to action.",
      "product-descriptions": "For product titles, features, specs, and benefits on product detail pages.",
      "brand-storytelling": "For About pages and campaign narratives with emotion.",
      "seo-friendly": "For keyword-smart copy, meta fields, and web/app copywriting.",
      "social-media": "For posts and ads. Hooks, hashtags, and short lines.",
      "email-campaigns": "For subject lines and body that drive clicks.",
      "event-promotion": "For invites and landing pages with dates, venue, and CTA.",
      "influencer-ugc-style": "For first-person, authentic voice that feels like real users."
    },
    dubbing: {
      general: "For dubbing with natural flow, concise lines, and clean timing.",
      dialogue: "For character lines that fit lip movements and match the scene pace.",
      narration: "For voiceover scripts with smooth pacing and clear emphasis."
    },
    creative: {
      general: "For imaginative writing with a natural, readable voice.",
      "literary-adaptation": "For stories rewritten across languages while preserving tone and imagery.",
      "slogan-tagline-writing": "For short, memorable lines that carry brand voice.",
      "poetic-tone": "For lyrical wording with rhythm and vivid images.",
      "narrative-prose": "For novel-style narration, short stories, and other scene-driven prose with smooth flow."
    },
    technical: {
      general: "For precise technical writing with plain language and correct terms.",
      "software-documentation": "For software user guides and release notes with steps and examples.",
      "engineering-manuals": "For procedures and safety notes with parts, tolerances, and diagrams.",
      "product-specs": "For spec sheets with measurements, materials, and limits.",
      "api-guides": "For endpoints and parameters with example requests and response schemas."
    },
    legal: {
      general: "For formal legal writing that is precise, consistent, and citation ready.",
      contracts: "For clauses, definitions, obligations, and remedies with exact terms.",
      "terms-conditions": "For service terms, acceptable use, warranties, and limitations of liability.",
      "compliance-docs": "For policies and reports that meet regulatory requirements.",
      "privacy-policies": "For data collection, use, retention, and user rights stated clearly.",
      constitutional: "For constitutional text and laws with exact wording and article references."
    },
    medical: {
      general: "For medical content with accurate terms and clear structure.",
      "patient-friendly-explanation": "For plain language instructions and health info patients can act on.",
      "research-abstracts": "For concise summaries of background, methods, results, and conclusions.",
      "clinical-documentation": "For Electronic Health Record notes, discharge summaries, and prescriptions.",
      "health-campaigns": "For public health messages and social posts."
    },
    journalistic: {
      general: "For factual writing with neutral tone and verified sources.",
      "news-reports": "For timely updates that lead with who, what, when, where, and why.",
      "editorial-opinion": "For argued viewpoints with evidence, context, and a clear stance.",
      "feature-articles": "For in-depth stories with background, human detail, and narrative flow.",
      "press-releases": "For organization announcements with key facts, quotes, and contact info."
    },
    corporate: {
      general: "For business writing that is clear, concise, and on brand.",
      "internal-communications": "For memos, announcements, and policy updates.",
      "investor-relations": "For earnings updates, KPIs, and risk disclosures.",
      "annual-reports": "For performance summaries, strategy, and ESG sections.",
      "professional-presentations": "For slide titles, speaker notes, and takeaways."
    },
    entertainment: {
      general: "For film, series, and content with engaging tone and steady pacing.",
      subtitling: "For captions with correct timing, line breaks, and reading speed.",
      screenwriting: "For scene headings, action lines, and dialogue in standard format.",
      "script-adaptation": "For localized scripts that keep plot, humor, and intent.",
      "character-dialogue": "For voices that fit each character and match scene timing."
    },
    educational: {
      general: "For teaching materials with clear structure and plain language.",
      "e-learning": "For online modules, slides, and voiceover scripts in an active tone.",
      "step-by-step-guides": "For how-to instructions with numbered steps and simple wording.",
      "academic-tutorials": "For lecture notes and walkthroughs that explain concepts with examples.",
      "test-preparation": "For practice questions, answer keys, and tips that build exam confidence."
    }
  },

  id: {
    formal: {
      general: "Untuk dokumen profesional dan komunikasi publik.",
      academic: "Untuk makalah riset, artikel, tesis, dan buku.",
      scientific: "Untuk makalah riset, abstrak, laporan laboratorium, dan metode."
    },
    casual: {
      general: "Untuk pesan sehari-hari yang mudah dibaca dan terasa ramah.",
      "social-media": "Untuk caption dan posting dengan kalimat pendek serta tagar.",
      chat: "Untuk balasan singkat dan mengalir seperti obrolan. Emoji diperbolehkan.",
      gaming: "Untuk istilah gamer, seruan singkat, dan canda tim.",
      "street-talk": "Untuk bahasa gaul santai dengan rasa lokal. Tetap sopan.",
    },
    marketing: {
      general: "Untuk teks pemasaran yang konsisten dengan brand di berbagai kanal.",
      promotional: "Untuk promo dan diskon. Judul jelas dengan rasa urgensi.",
      persuasive: "Untuk copy berfokus manfaat dengan ajakan bertindak yang kuat.",
      "product-descriptions": "Untuk judul produk, fitur, spesifikasi, dan manfaat di halaman produk.",
      "brand-storytelling": "Untuk halaman profil dan narasi kampanye yang menyentuh emosi.",
      "seo-friendly": "Untuk copy ramah kata kunci, meta field, dan copywriting web/aplikasi.",
      "social-media": "Untuk posting dan iklan. Hook, tagar, dan kalimat pendek.",
      "email-campaigns": "Untuk subjek dan isi email yang mendorong klik.",
      "event-promotion": "Untuk undangan dan landing page dengan tanggal, lokasi, dan CTA.",
      "influencer-ugc-style": "Untuk suara orang pertama yang autentik seperti pengguna sungguhan."
    },
    dubbing: {
      general: "Untuk dubbing yang mengalir natural, ringkas, dan tepat waktu.",
      dialogue: "Untuk dialog karakter yang pas dengan gerak bibir dan tempo adegan.",
      narration: "Untuk naskah sulih suara dengan ritme mulus dan penekanan jelas."
    },
    creative: {
      general: "Untuk tulisan imajinatif dengan suara yang natural dan mudah dibaca.",
      "literary-adaptation": "Untuk cerita lintas bahasa yang menjaga nada dan imagery.",
      "slogan-tagline-writing": "Untuk kalimat sangat singkat yang mudah diingat dan mewakili brand.",
      "poetic-tone": "Untuk diksi puitis dengan ritme dan gambaran yang hidup.",
      "narrative-prose": "Untuk narasi gaya novel, cerita pendek, dan prosa bercerita lain dengan alur yang halus."
    },
    technical: {
      general: "Untuk tulisan teknis presisi dengan bahasa lugas dan istilah tepat.",
      "software-documentation": "Untuk panduan pengguna perangkat lunak dan rilis fitur dengan langkah dan contoh.",
      "engineering-manuals": "Untuk prosedur dan catatan keselamatan dengan bagian, toleransi, dan diagram.",
      "product-specs": "Untuk lembar spesifikasi: ukuran, material, dan batasan.",
      "api-guides": "Untuk endpoint dan parameter dengan contoh permintaan dan skema respons."
    },
    legal: {
      general: "Untuk tulisan hukum formal yang presisi, konsisten, dan siap sitasi.",
      contracts: "Untuk klausul, definisi, kewajiban, dan pemulihan dengan istilah tepat.",
      "terms-conditions": "Untuk syarat layanan, penggunaan yang diterima, garansi, dan pembatasan tanggung jawab.",
      "compliance-docs": "Untuk kebijakan dan laporan yang memenuhi regulasi.",
      "privacy-policies": "Untuk pernyataan pengumpulan, penggunaan, retensi data, dan hak pengguna.",
      constitutional: "Untuk teks konstitusi dan perundangan dengan redaksi tepat dan rujukan pasal."
    },
    medical: {
      general: "Untuk konten medis dengan istilah akurat dan struktur jelas.",
      "patient-friendly-explanation": "Untuk instruksi sederhana dan informasi kesehatan yang bisa ditindaklanjuti.",
      "research-abstracts": "Untuk ringkasan padat mencakup latar, metode, hasil, dan kesimpulan.",
      "clinical-documentation": "Untuk catatan rekam medis, ringkasan pulang, dan resep.",
      "health-campaigns": "Untuk pesan kesehatan publik dan posting sosial."
    },
    journalistic: {
      general: "Untuk tulisan faktual dengan nada netral dan sumber terverifikasi.",
      "news-reports": "Untuk kabar terkini yang diawali siapa, apa, kapan, di mana, dan mengapa.",
      "editorial-opinion": "Untuk opini yang berargumen dengan bukti, konteks, dan sikap jelas.",
      "feature-articles": "Untuk liputan mendalam dengan latar, sisi manusia, dan alur naratif.",
      "press-releases": "Untuk pengumuman organisasi dengan fakta kunci, kutipan, dan kontak."
    },
    corporate: {
      general: "Untuk tulisan bisnis yang jelas, ringkas, dan sesuai brand.",
      "internal-communications": "Untuk memo, pengumuman, dan pembaruan kebijakan.",
      "investor-relations": "Untuk ringkasan kinerja, KPI, dan pengungkapan risiko.",
      "annual-reports": "Untuk ringkasan kinerja, strategi, dan bagian ESG.",
      "professional-presentations": "Untuk judul slide, catatan pembicara, dan poin utama."
    },
    entertainment: {
      general: "Untuk film, serial, dan konten dengan nada menarik dan tempo stabil.",
      subtitling: "Untuk teks layar dengan timing, pemenggalan baris, dan kecepatan baca yang tepat.",
      screenwriting: "Untuk heading adegan, aksi, dan dialog dalam format standar.",
      "script-adaptation": "Untuk naskah terlokalisasi yang menjaga alur, humor, dan maksud.",
      "character-dialogue": "Untuk suara karakter yang pas dan sesuai tempo adegan."
    },
    educational: {
      general: "Untuk materi ajar dengan struktur jelas dan bahasa sederhana.",
      "e-learning": "Untuk modul online, slide, dan naskah voice-over berton aktif.",
      "step-by-step-guides": "Untuk petunjuk langkah demi langkah dengan penomoran dan diksi sederhana.",
      "academic-tutorials": "Untuk catatan kuliah dan walkthrough yang menjelaskan konsep dengan contoh.",
      "test-preparation": "Untuk soal latihan, kunci jawaban, dan tips yang membangun kepercayaan diri ujian."
    }
  },

  zh: {
    formal: {
      general: "ç”¨äºŽä¸“ä¸šæ–‡ä»¶ä¸Žå…¬å…±æ²Ÿé€šåœºæ™¯ã€‚",
      academic: "ç”¨äºŽç ”ç©¶è®ºæ–‡ã€å­¦æœ¯æ–‡ç« ã€è®ºæ–‡ä¸Žä¹¦ç±ã€‚",
      scientific: "ç”¨äºŽç ”ç©¶è®ºæ–‡ã€æ‘˜è¦ã€å®žéªŒæŠ¥å‘Šä¸Žæ–¹æ³•éƒ¨åˆ†ã€‚"
    },
    casual: {
      general: "ç”¨äºŽæ—¥å¸¸ä¿¡æ¯ï¼Œè¯»èµ·æ¥è‡ªç„¶å‹å¥½ã€‚",
      "social-media": "ç”¨äºŽé…æ–‡ä¸Žå¸–å­ï¼Œè¡Œæ–‡çŸ­ä¿ƒå¹¶å¯æ­é…è¯é¢˜æ ‡ç­¾ã€‚",
      chat: "ç”¨äºŽç®€çŸ­çš„å¯¹è¯å¼å›žå¤ï¼Œå¯é€‚å½“ä½¿ç”¨è¡¨æƒ…ç¬¦å·ã€‚",
      gaming: "ç”¨äºŽçŽ©å®¶ä¿šè¯­ã€ç®€çŸ­å‘¼å«ä¸Žé˜Ÿå†…çŽ©æ¢—ã€‚",
      "street-talk": "ç”¨äºŽè½»æ¾å£è¯­ä¸Žæœ¬åœ°åŒ–è¡¨è¾¾ï¼Œè¯·ä¿æŒç¤¼è²Œã€‚",
    },
    marketing: {
      general: "ç”¨äºŽå„æ¸ é“ä¸€è‡´çš„å“ç‰Œè¥é”€æ–‡æ¡ˆã€‚",
      promotional: "ç”¨äºŽä¼˜æƒ ä¸Žä¿ƒé”€ã€‚æ ‡é¢˜æ¸…æ™°å¹¶è¥é€ ç´§è¿«æ„Ÿã€‚",
      persuasive: "ç”¨äºŽä»¥æ”¶ç›Šä¸ºæ ¸å¿ƒå¹¶å¸¦æœ‰å¼ºåŠ›è¡ŒåŠ¨å·å¬çš„æ–‡æ¡ˆã€‚",
      "product-descriptions": "ç”¨äºŽäº§å“æ ‡é¢˜ã€ç‰¹æ€§ã€è§„æ ¼ä¸Žå–ç‚¹ï¼Œé€‚é…å•†å“è¯¦æƒ…é¡µã€‚",
      "brand-storytelling": "ç”¨äºŽ\"å…³äºŽæˆ‘ä»¬\"ä¸Žæ´»åŠ¨å™äº‹ï¼Œæ³¨é‡æƒ…æ„Ÿå…±é¸£ã€‚",
      "seo-friendly": "ç”¨äºŽå…³é”®è¯ä¼˜åŒ–æ–‡æ¡ˆã€å…ƒä¿¡æ¯å­—æ®µå’Œç½‘ç«™/åº”ç”¨æ–‡æ¡ˆã€‚",
      "social-media": "ç”¨äºŽå¸–å­ä¸Žå¹¿å‘Šï¼Œè®²æ±‚å¼€å¤´æŠ“äººã€è¯é¢˜æ ‡ç­¾ä¸ŽçŸ­å¥ã€‚",
      "email-campaigns": "ç”¨äºŽæå‡ç‚¹å‡»çŽ‡çš„ä¸»é¢˜ä¸Žæ­£æ–‡ã€‚",
      "event-promotion": "ç”¨äºŽé‚€è¯·ä¸Žè½åœ°é¡µï¼Œæ¸…æ™°å‘ˆçŽ°æ—¥æœŸã€åœ°ç‚¹ä¸Ž CTAã€‚",
      "influencer-ugc-style": "ç”¨äºŽç¬¬ä¸€äººç§°ã€çœŸå®žæ„Ÿå¼ºçš„\"åƒç”¨æˆ·å†™çš„\"å†…å®¹ã€‚"
    },
    dubbing: {
      general: "ç”¨äºŽé…éŸ³å°è¯ï¼Œè‡ªç„¶é¡ºç•…ã€å¥å­ç²¾ç‚¼ã€æ—¶åºå¹²å‡€ã€‚",
      dialogue: "ç”¨äºŽäººç‰©å¯¹ç™½ï¼Œè´´åˆå£åž‹å¹¶åŒ¹é…åœºæ™¯èŠ‚å¥ã€‚",
      narration: "ç”¨äºŽæ—ç™½ç¨¿ï¼ŒèŠ‚å¥å¹³ç¨³ã€é‡éŸ³æ¸…æ™°ã€‚"
    },
    creative: {
      general: "ç”¨äºŽå¯Œæœ‰æƒ³è±¡åŠ›ä¸”å¯è¯»æ€§å¼ºçš„åˆ›ä½œæ€§æ–‡å­—ã€‚",
      "literary-adaptation": "ç”¨äºŽè·¨è¯­æ”¹å†™æ•…äº‹ï¼Œä¿ç•™è¯­æ°”ä¸Žæ„è±¡ã€‚",
      "slogan-tagline-writing": "ç”¨äºŽæžçŸ­ä¸”æ˜“è®°çš„å“ç‰Œè¯­å¥ã€‚",
      "poetic-tone": "ç”¨äºŽå…·èŠ‚å¥ä¸Žé²œæ´»æ„è±¡çš„æŠ’æƒ…è¡¨è¾¾ã€‚",
      "narrative-prose": "ç”¨äºŽå°è¯´å¼å™è¿°ã€çŸ­ç¯‡æ•…äº‹å’Œå…¶ä»–ä»¥åœºæ™¯æŽ¨è¿›çš„å™äº‹æ€§æ–‡å­—ä¸Žé¡ºæ»‘æ–‡æ°”ã€‚"
    },
    technical: {
      general: "ç”¨äºŽæŠ€æœ¯å†™ä½œï¼Œæœ¯è¯­å‡†ç¡®ã€è¯­è¨€ç®€æ˜Žã€‚",
      "software-documentation": "ç”¨äºŽè½¯ä»¶ç”¨æˆ·æŒ‡å—ä¸Žæ›´æ–°è¯´æ˜Žï¼ŒåŒ…å«æ­¥éª¤ä¸Žç¤ºä¾‹ã€‚",
      "engineering-manuals": "ç”¨äºŽæµç¨‹ä¸Žå®‰å…¨æç¤ºï¼ŒåŒ…å«éƒ¨ä»¶ã€å…å·®ä¸Žç¤ºæ„å›¾ã€‚",
      "product-specs": "ç”¨äºŽè§„æ ¼è¡¨ï¼ŒåŒ…å«å°ºå¯¸ã€æè´¨ä¸Žç•Œé™å€¼ã€‚",
      "api-guides": "ç”¨äºŽç«¯ç‚¹ä¸Žå‚æ•°è¯´æ˜Žï¼Œé…è¯·æ±‚ç¤ºä¾‹ä¸Žå“åº”æ¨¡å¼ã€‚"
    },
    legal: {
      general: "ç”¨äºŽæ­£å¼æ³•å¾‹å†™ä½œï¼Œè¡¨è¿°ç²¾å‡†ã€ä¸€è‡´å¹¶å¯ä¾›å¼•ç”¨ã€‚",
      contracts: "ç”¨äºŽæ¡æ¬¾ã€å®šä¹‰ã€ä¹‰åŠ¡ä¸Žæ•‘æµŽï¼Œæœ¯è¯­ä¸¥è°¨ã€‚",
      "terms-conditions": "ç”¨äºŽæœåŠ¡æ¡æ¬¾ã€å¯æŽ¥å—ä½¿ç”¨ã€ä¿è¯ä¸Žè´£ä»»é™åˆ¶ã€‚",
      "compliance-docs": "ç”¨äºŽæ»¡è¶³ç›‘ç®¡è¦æ±‚çš„æ”¿ç­–ä¸ŽæŠ¥å‘Šã€‚",
      "privacy-policies": "ç”¨äºŽæ¸…æ™°è¯´æ˜Žæ•°æ®æ”¶é›†ã€ä½¿ç”¨ã€ä¿ç•™ä¸Žç”¨æˆ·æƒåˆ©ã€‚",
      constitutional: "ç”¨äºŽå®ªæ³•ä¸Žæ³•å¾‹æ–‡æœ¬ï¼ŒæŽªè¾žç²¾ç¡®å¹¶å«æ¡æ¬¾å¼•ç”¨ã€‚"
    },
    medical: {
      general: "ç”¨äºŽåŒ»å­¦å†…å®¹ï¼Œæœ¯è¯­å‡†ç¡®ã€ç»“æž„æ¸…æ™°ã€‚",
      "patient-friendly-explanation": "ç”¨äºŽé€šä¿—æŒ‡å¼•ä¸Žå¯è¡ŒåŠ¨çš„å¥åº·ä¿¡æ¯ã€‚",
      "research-abstracts": "ç”¨äºŽç®€æ´æ¦‚è¿°ï¼šèƒŒæ™¯ã€æ–¹æ³•ã€ç»“æžœä¸Žç»“è®ºã€‚",
      "clinical-documentation": "ç”¨äºŽç—…åŽ†è®°å½•ã€å‡ºé™¢å°ç»“ä¸Žå¤„æ–¹ã€‚",
      "health-campaigns": "ç”¨äºŽå…¬å…±å¥åº·ä¿¡æ¯ä¸Žç¤¾äº¤åª’ä½“ä¼ æ’­ã€‚"
    },
    journalistic: {
      general: "ç”¨äºŽåŸºäºŽäº‹å®žã€è¯­æ°”ä¸­ç«‹å¹¶ç»æ ¸å®žçš„ä¿¡æ¯å†™ä½œã€‚",
      "news-reports": "ç”¨äºŽåŠæ—¶æŠ¥é“ï¼Œä»¥\"äº”ä½•\"å¼€ç¯‡ï¼ˆä½•äººä½•äº‹ä½•æ—¶ä½•åœ°ä¸ºä½•ï¼‰ã€‚",
      "editorial-opinion": "ç”¨äºŽè§‚ç‚¹æ˜Žç¡®ã€è¯æ®å……åˆ†ã€è„‰ç»œæ¸…æ™°çš„ç¤¾è®ºã€‚",
      "feature-articles": "ç”¨äºŽæ·±åº¦æŠ¥é“ï¼Œå…¼é¡¾èƒŒæ™¯ã€äººæƒ…ç»†èŠ‚ä¸Žå™äº‹æµç•…ã€‚",
      "press-releases": "ç”¨äºŽæœºæž„å…¬å‘Šï¼ŒåŒ…å«è¦ç‚¹ã€å¼•è¯­ä¸Žè”ç³»æ–¹å¼ã€‚"
    },
    corporate: {
      general: "ç”¨äºŽå•†åŠ¡å†™ä½œï¼Œè¡¨è¾¾æ¸…æ™°ã€ç®€æ´å¹¶ç¬¦åˆå“ç‰Œã€‚",
      "internal-communications": "ç”¨äºŽå¤‡å¿˜ã€å…¬å‘Šä¸Žæ”¿ç­–æ›´æ–°ã€‚",
      "investor-relations": "ç”¨äºŽä¸šç»©æ›´æ–°ã€å…³é”®æŒ‡æ ‡ä¸Žé£Žé™©æŠ«éœ²ã€‚",
      "annual-reports": "ç”¨äºŽç»©æ•ˆå›žé¡¾ã€æˆ˜ç•¥ä¸Ž ESG æ¿å—ã€‚",
      "professional-presentations": "ç”¨äºŽå¹»ç¯ç‰‡æ ‡é¢˜ã€è®²è€…ç¬”è®°ä¸Žè¦ç‚¹ã€‚"
    },
    entertainment: {
      general: "ç”¨äºŽå½±è§†ä¸Žå†…å®¹ï¼Œè¯­è°ƒå¸å¼•ã€èŠ‚å¥ç¨³å®šã€‚",
      subtitling: "ç”¨äºŽå­—å¹•ï¼Œæ—¶é—´è½´å‡†ç¡®ã€æ–­è¡Œæ°å½“ã€é˜…è¯»é€Ÿåº¦åˆå®œã€‚",
      screenwriting: "ç”¨äºŽåœºæ™¯æ ‡å¤´ã€åŠ¨ä½œä¸Žå¯¹ç™½çš„æ ‡å‡†å‰§æœ¬æ ¼å¼ã€‚",
      "script-adaptation": "ç”¨äºŽæœ¬åœ°åŒ–å‰§æœ¬ï¼Œä¿ç•™æƒ…èŠ‚ã€ç¬‘ç‚¹ä¸Žæ„å›¾ã€‚",
      "character-dialogue": "ç”¨äºŽè§’è‰²è´´è„¸çš„å°è¯ä¸Žåœºæ™¯èŠ‚å¥åŒ¹é…ã€‚"
    },
    educational: {
      general: "ç”¨äºŽæ•™å­¦ææ–™ï¼Œç»“æž„æ¸…æ™°ã€ç”¨è¯­æœ´å®žã€‚",
      "e-learning": "ç”¨äºŽåœ¨çº¿æ¨¡å—ã€å¹»ç¯ç‰‡ä¸Žé…éŸ³ç¨¿ï¼Œè¯­æ°”ä¸»åŠ¨ã€‚",
      "step-by-step-guides": "ç”¨äºŽåˆ†æ­¥æŒ‡å¼•ï¼Œç¼–å·æ¸…æ¥šã€æŽªè¾žç®€æ´ã€‚",
      "academic-tutorials": "ç”¨äºŽè®²ä¹‰ä¸Žæ¼”ç»ƒï¼Œç»“åˆç¤ºä¾‹è§£é‡Šæ¦‚å¿µã€‚",
      "test-preparation": "ç”¨äºŽç»ƒä¹ é¢˜ã€ç­”æ¡ˆä¸Žå¤‡è€ƒæŠ€å·§ï¼Œå¢žå¼ºåº”è¯•ä¿¡å¿ƒã€‚"
    }
  },

  fr: {
    formal: {
      general: "Pour les documents professionnels et la communication publique.",
      academic: "Pour les articles de recherche, mÃ©moires, thÃ¨ses et ouvrages.",
      scientific: "Pour les articles scientifiques, rÃ©sumÃ©s, rapports et mÃ©thodes."
    },
    casual: {
      general: "Pour des messages du quotidien, simples et chaleureux.",
      "social-media": "Pour des lÃ©gendes et posts, lignes courtes et hashtags.",
      chat: "Pour des rÃ©ponses rapides au ton conversationnel. Ã‰mojis autorisÃ©s.",
      gaming: "Pour l'argot gamer, les appels courts et l'esprit d'Ã©quipe.",
      "street-talk": "Pour un parler courant et local. Restez respectueux.",
    },
    marketing: {
      general: "Pour un texte marketing cohÃ©rent avec la marque sur tous les canaux.",
      promotional: "Pour les offres et promotions. Titres clairs et sentiment d'urgence.",
      persuasive: "Pour un discours centrÃ© bÃ©nÃ©fices avec un appel Ã  l'action fort.",
      "product-descriptions": "Pour titres, fonctionnalitÃ©s, spÃ©cifications et bÃ©nÃ©fices sur les pages produit.",
      "brand-storytelling": "Pour les pages \"Ã€ propos\" et des rÃ©cits de campagne Ã©motionnels.",
      "seo-friendly": "Pour un contenu optimisÃ© mots-clÃ©s, champs mÃ©ta et rÃ©daction web/app.",
      "social-media": "Pour posts et annonces. Accroches, hashtags, lignes courtes.",
      "email-campaigns": "Pour objets et corps d'e-mail qui incitent au clic.",
      "event-promotion": "Pour invitations et landing pages avec date, lieu et CTA.",
      "influencer-ugc-style": "Pour une voix Ã  la premiÃ¨re personne authentique, faÃ§on utilisateur rÃ©el."
    },
    dubbing: {
      general: "Pour un doublage fluide, des lignes concises et un timing propre.",
      dialogue: "Pour des rÃ©pliques adaptÃ©es au mouvement des lÃ¨vres et au rythme des scÃ¨nes.",
      narration: "Pour des voix off au dÃ©bit rÃ©gulier et Ã  l'accentuation claire."
    },
    creative: {
      general: "Pour une Ã©criture imaginative Ã  la voix naturelle et lisible.",
      "literary-adaptation": "Pour rÃ©Ã©crire des histoires en prÃ©servant le ton et les images.",
      "slogan-tagline-writing": "Pour des lignes trÃ¨s courtes, mÃ©morables et fidÃ¨les Ã  la marque.",
      "poetic-tone": "Pour une langue lyrique, rythmÃ©e et Ã©vocatrice.",
      "narrative-prose": "Pour narration style roman, nouvelles et autres proses narratives axÃ©es sur les scÃ¨nes et le flux."
    },
    technical: {
      general: "Pour une rÃ©daction technique prÃ©cise avec langage clair et termes justes.",
      "software-documentation": "Pour guides utilisateur logiciel et notes de version avec Ã©tapes et exemples.",
      "engineering-manuals": "Pour procÃ©dures et consignes de sÃ©curitÃ© avec piÃ¨ces, tolÃ©rances et schÃ©mas.",
      "product-specs": "Pour fiches techniques avec mesures, matÃ©riaux et limites.",
      "api-guides": "Pour endpoints et paramÃ¨tres avec requÃªtes d'exemple et schÃ©mas de rÃ©ponse."
    },
    legal: {
      general: "Pour une Ã©criture juridique formelle, prÃ©cise, cohÃ©rente et citable.",
      contracts: "Pour clauses, dÃ©finitions, obligations et recours aux termes exacts.",
      "terms-conditions": "Pour conditions d'utilisation, garanties et limitations de responsabilitÃ©.",
      "compliance-docs": "Pour politiques et rapports conformes aux exigences.",
      "privacy-policies": "Pour collecte, usage, conservation des donnÃ©es et droits des utilisateurs.",
      constitutional: "Pour textes constitutionnels et lois avec formulation exacte et renvois aux articles."
    },
    medical: {
      general: "Pour du contenu mÃ©dical avec terminologie exacte et structure claire.",
      "patient-friendly-explanation": "Pour des consignes simples et des informations actionnables.",
      "research-abstracts": "Pour des rÃ©sumÃ©s concis : contexte, mÃ©thodes, rÃ©sultats, conclusions.",
      "clinical-documentation": "Pour dossiers mÃ©dicaux, comptes rendus de sortie et prescriptions.",
      "health-campaigns": "Pour messages de santÃ© publique et posts sociaux."
    },
    journalistic: {
      general: "Pour une Ã©criture factuelle au ton neutre avec sources vÃ©rifiÃ©es.",
      "news-reports": "Pour des actualitÃ©s qui ouvrent sur qui, quoi, quand, oÃ¹, pourquoi.",
      "editorial-opinion": "Pour des points de vue argumentÃ©s, contextualisÃ©s et assumÃ©s.",
      "feature-articles": "Pour des sujets de fond avec contexte, tÃ©moignages et narration.",
      "press-releases": "Pour des annonces institutionnelles avec faits clÃ©s, citations et contact."
    },
    corporate: {
      general: "Pour une Ã©criture d'entreprise claire, concise et conforme Ã  la marque.",
      "internal-communications": "Pour notes, annonces et mises Ã  jour de politique interne.",
      "investor-relations": "Pour rÃ©sultats, indicateurs et informations sur les risques.",
      "annual-reports": "Pour bilans de performance, stratÃ©gie et chapitres ESG.",
      "professional-presentations": "Pour titres de diapositives, notes orateur et messages clÃ©s."
    },
    entertainment: {
      general: "Pour film, sÃ©rie et contenus au ton engageant et au rythme rÃ©gulier.",
      subtitling: "Pour sous-titres avec timing, cÃ©sures et vitesse de lecture corrects.",
      screenwriting: "Pour en-tÃªtes de scÃ¨ne, actions et dialogues au format standard.",
      "script-adaptation": "Pour des scripts localisÃ©s qui gardent intrigue, humour et intention.",
      "character-dialogue": "Pour des voix cohÃ©rentes avec chaque personnage et le rythme des scÃ¨nes."
    },
    educational: {
      general: "Pour supports pÃ©dagogiques Ã  la structure claire et au langage simple.",
      "e-learning": "Pour modules en ligne, diapositives et voix off au ton actif.",
      "step-by-step-guides": "Pour guides pas Ã  pas, numÃ©rotÃ©s et formulÃ©s simplement.",
      "academic-tutorials": "Pour notes de cours et pas-Ã -pas expliquant les concepts par l'exemple.",
      "test-preparation": "Pour exercices, corrigÃ©s et conseils renforÃ§ant la confiance Ã  l'examen."
    }
  },

  es: {
    formal: {
      general: "Para documentos profesionales y comunicaciÃ³n pÃºblica.",
      academic: "Para artÃ­culos de investigaciÃ³n, tesis y libros.",
      scientific: "Para artÃ­culos, resÃºmenes, informes de laboratorio y mÃ©todos."
    },
    casual: {
      general: "Para mensajes cotidianos que suenen simples y cercanos.",
      "social-media": "Para leyendas y posts con frases cortas y hashtags.",
      chat: "Para respuestas rÃ¡pidas y conversacionales. Se permiten emojis.",
      gaming: "Para jerga gamer, llamados breves y camaraderÃ­a de equipo.",
      "street-talk": "Para lenguaje coloquial con sabor local. MantÃ©n el respeto.",
    },
    marketing: {
      general: "Para textos de marketing alineados con la marca en todos los canales.",
      promotional: "Para ofertas y rebajas. Titulares claros y sentido de urgencia.",
      persuasive: "Para copys centrados en beneficios con un CTA contundente.",
      "product-descriptions": "Para tÃ­tulos, funciones, especificaciones y beneficios en pÃ¡ginas de producto.",
      "brand-storytelling": "Para pÃ¡ginas \"Sobre nosotros\" y narrativas de campaÃ±a con emociÃ³n.",
      "seo-friendly": "Para textos con palabras clave, campos meta y copywriting web/app.",
      "social-media": "Para posts y anuncios. Ganchos, hashtags y lÃ­neas cortas.",
      "email-campaigns": "Para asuntos y cuerpos que impulsen los clics.",
      "event-promotion": "Para invitaciones y landing pages con fecha, lugar y CTA.",
      "influencer-ugc-style": "Para voz en primera persona, autÃ©ntica y cercana, como de usuario real."
    },
    dubbing: {
      general: "Para doblaje con flujo natural, lÃ­neas concisas y timing limpio.",
      dialogue: "Para diÃ¡logos que se ajusten al movimiento labial y al ritmo de la escena.",
      narration: "Para locuciones con ritmo fluido y Ã©nfasis claro."
    },
    creative: {
      general: "Para escritura imaginativa con voz natural y legible.",
      "literary-adaptation": "Para reescritura de historias preservando tono e imÃ¡genes.",
      "slogan-tagline-writing": "Para lÃ­neas muy cortas, memorables y fieles a la marca.",
      "poetic-tone": "Para un registro lÃ­rico con ritmo e imÃ¡genes vÃ­vidas.",
      "narrative-prose": "Para narraciÃ³n estilo novela, cuentos cortos y otras prosas narrativas basadas en escenas y un flujo suave."
    },
    technical: {
      general: "Para redacciÃ³n tÃ©cnica precisa con lenguaje claro y tÃ©rminos correctos.",
      "software-documentation": "Para guÃ­as de usuario de software y notas de versiÃ³n con pasos y ejemplos.",
      "engineering-manuals": "Para procedimientos y seguridad con piezas, tolerancias y diagramas.",
      "product-specs": "Para fichas tÃ©cnicas con medidas, materiales y lÃ­mites.",
      "api-guides": "Para endpoints y parÃ¡metros con solicitudes de ejemplo y esquemas de respuesta."
    },
    legal: {
      general: "Para textos legales formales, precisos, consistentes y listos para cita.",
      contracts: "Para clÃ¡usulas, definiciones, obligaciones y remedios con tÃ©rminos exactos.",
      "terms-conditions": "Para tÃ©rminos de servicio, uso aceptable, garantÃ­as y limitaciones de responsabilidad.",
      "compliance-docs": "Para polÃ­ticas e informes que cumplan normativas.",
      "privacy-policies": "Para explicar recolecciÃ³n, uso, retenciÃ³n de datos y derechos del usuario.",
      constitutional: "Para textos constitucionales y leyes con redacciÃ³n exacta y referencias a artÃ­culos."
    },
    medical: {
      general: "Para contenido mÃ©dico con tÃ©rminos precisos y estructura clara.",
      "patient-friendly-explanation": "Para instrucciones sencillas e informaciÃ³n accionable para pacientes.",
      "research-abstracts": "Para resÃºmenes concisos de antecedentes, mÃ©todos, resultados y conclusiones.",
      "clinical-documentation": "Para notas clÃ­nicas, resÃºmenes de alta y recetas.",
      "health-campaigns": "Para mensajes de salud pÃºblica y publicaciones en redes."
    },
    journalistic: {
      general: "Para escritura factual con tono neutral y fuentes verificadas.",
      "news-reports": "Para novedades oportunas que abren con quiÃ©n, quÃ©, cuÃ¡ndo, dÃ³nde y por quÃ©.",
      "editorial-opinion": "Para posturas argumentadas con evidencia, contexto y posiciÃ³n clara.",
      "feature-articles": "Para reportajes en profundidad con contexto, enfoque humano y narrativa.",
      "press-releases": "Para anuncios institucionales con datos clave, citas y contacto."
    },
    corporate: {
      general: "Para textos empresariales claros, concisos y alineados con la marca.",
      "internal-communications": "Para memorandos, anuncios y actualizaciones de polÃ­ticas.",
      "investor-relations": "Para resultados, KPIs y revelaciones de riesgo.",
      "annual-reports": "Para resÃºmenes de desempeÃ±o, estrategia y secciones ESG.",
      "professional-presentations": "Para tÃ­tulos de diapositivas, notas del ponente y conclusiones clave."
    },
    entertainment: {
      general: "Para cine, series y contenidos con tono atractivo y ritmo constante.",
      subtitling: "Para subtÃ­tulos con timing correcto, cortes de lÃ­nea y velocidad de lectura adecuada.",
      screenwriting: "Para encabezados de escena, acciones y diÃ¡logos en formato estÃ¡ndar.",
      "script-adaptation": "Para guiones localizados que mantengan trama, humor e intenciÃ³n.",
      "character-dialogue": "Para voces acordes a cada personaje y el ritmo de la escena."
    },
    educational: {
      general: "Para materiales de enseÃ±anza con estructura clara y lenguaje sencillo.",
      "e-learning": "Para mÃ³dulos en lÃ­nea, diapositivas y guiones de voz con tono activo.",
      "step-by-step-guides": "Para instrucciones paso a paso con numeraciÃ³n y redacciÃ³n simple.",
      "academic-tutorials": "Para apuntes y recorridos que expliquen conceptos con ejemplos.",
      "test-preparation": "Para ejercicios, claves y consejos que fortalezcan la confianza en exÃ¡menes."
    }
  }
};
    /* =======================
       1) Core helpers
       ======================= */
    let heightRO=null;
    const $=s=>document.querySelector(s);
    const $$=s=>Array.from(document.querySelectorAll(s));
    const slug=t=>String(t).toLowerCase().replace(/[^\w]+/g,'-').replace(/(^-|-$)/g,'');
    const getContentH=el=>el?Math.ceil(el.scrollHeight):0;

    // RTL detection based on script ranges, not language codes.
    // Covers: Arabic (0600-06FF, 0750-077F, 08A0-08FF), Hebrew (0590-05FF),
    // Thaana (0780-07BF). This catches: ar, fa, ur, ps, sd, ug, ku-Sorani, yi, dv, iw.
    const RTL_RANGES=[/[\u0590-\u05FF]/,/[\u0600-\u06FF]/,/[\u0750-\u077F]/,/[\u08A0-\u08FF]/,/[\u0780-\u07BF]/];
    function isRTLString(s=''){const str=String(s||''); return RTL_RANGES.some(re=>re.test(str));}
    function applyContentDirection(){
      try{
        const d=currentDoc?.()||{};
        const srcText = (d.text ?? $('#inputText')?.value) || '';
        const outText = (d.output ?? $('#outputText')?.value ?? $('#outputRich')?.textContent) || '';
        const srcRTL = isRTLString(srcText);
        const tgtRTL = (String(targetLanguage||'')==='Arabic') || isRTLString(outText);

        const inEl=$('#inputText'); if(inEl){ inEl.classList.toggle('rtl', srcRTL); }
        const outTa=$('#outputText'); if(outTa){ outTa.classList.toggle('rtl', tgtRTL); }
        const outRich=$('#outputRich'); if(outRich){ outRich.classList.toggle('rtl', tgtRTL); }
        // Split view boxes
        $$('#segSrcBox .segtext').forEach(el=>el.classList.toggle('rtl', srcRTL));
        $$('#segTgtBox .segtext').forEach(el=>el.classList.toggle('rtl', tgtRTL));
        $$('#segTgtBox .segtext-textarea').forEach(el=>el.classList.toggle('rtl', tgtRTL));
        $$('#segTgtBox textarea[data-srt]').forEach(el=>el.classList.toggle('rtl', tgtRTL));
      }catch{}
    }

    /* ---------- Targets & Styles ---------- */
    const TARGET_KEYS=['Arabic','Bahasa','Chinese','Danish','Dutch','English','French','German','Hindi','Italian','Japanese','Malay','Portuguese','Russian','Spanish','Swedish','Thai','Turkish'];
    const STYLE_DEF={
      formal:{subs:['general','academic','scientific']},
      casual:{subs:['general','chat','gaming','street-talk','social-media']},
      marketing:{subs:['general','promotional','persuasive','product-descriptions','brand-storytelling','seo-friendly','social-media','email-campaigns','event-promotion','influencer-ugc-style']},
      dubbing:{subs:['general','dialogue','narration']},
      creative:{subs:['general','literary-adaptation','slogan-tagline-writing','poetic-tone','narrative-prose']},
      technical:{subs:['general','software-documentation','engineering-manuals','product-specs','api-guides']},
      legal:{subs:['general','contracts','terms-conditions','compliance-docs','privacy-policies','constitutional']},
      medical:{subs:['general','patient-friendly-explanation','research-abstracts','clinical-documentation','health-campaigns']},
      journalistic:{subs:['general','news-reports','editorial-opinion','feature-articles','press-releases']},
      corporate:{subs:['general','internal-communications','investor-relations','annual-reports','professional-presentations']},
      entertainment:{subs:['general','subtitling','screenwriting','script-adaptation','character-dialogue']},
      educational:{subs:['general','e-learning','step-by-step-guides','academic-tutorials','test-preparation']}
    };

    const SUBSTYLE_ALIASES={
      'formal:business':['corporate','general'],
      'formal:financial':['corporate','investor-relations'],
      'formal:dialogue':['dubbing','dialogue'],
      'casual:dialogue':['entertainment','character-dialogue'],
      'casual:social-media':['marketing','social-media'],
      'marketing:descriptive':['marketing','product-descriptions'],
      'marketing:pitching':['marketing','persuasive'],
      'marketing:social-media-marketing':['marketing','social-media'],
      'dubbing:narrative':['dubbing','narration'],
      'dubbing:historical':['dubbing','narration'],
      'dubbing:kids':['dubbing','narration'],
      'creative:storytelling':['creative','narrative-prose']
    };
    const resolveAlias=(mode,sub)=>{const key=`${slug(mode)}:${slug(sub||'general')}`;const hit=SUBSTYLE_ALIASES[key];return hit?{mode:hit[0],subStyle:hit[1]}:{mode,subStyle:sub}};

    /* ---------- UI Strings ---------- */
    const LOCALES={
      en:{title:"AI Localization Prototype",input_label:"Input Text",input_ph:"Paste or write your text hereâ€¦",target_lang:"Target Language",loc_style:"Localization Style",substyle:"Sub-style",substyle_for:"Sub-style for",no_substyle:"No sub-style",submit:"Submit",result_label:"Result",split_view:"Split View",back:"Back",copy:"Copy",copied:"Copied!",pane_input:"Input",pane_result:"Result",clear_highlights:"Clear Highlights",rephrase:"Rephrase",choose_lang:"Select your language",toast_enter_text:"Please enter some text first.",toast_choose_target:"Choose a target language or Rephrase.",toast_choose_style:"Please choose a localization style.",toast_error_generic:"Something went wrong. Please try again.",or:"Or",upload_hint:"Drag & drop a .txt, .docx, .pdf, or .srt here",upload_sub:"â€¦or click to browse",download_localized:"Download localized",download_all_zip:"Download all (.zip)",new_tab:"New Tab",open_files:"Open files",translate_all:"Translate all",export:"Export",export_pdf:"Export as PDF",export_docx:"Export as DOCX",export_txt:"Export as TXT"},
      id:{title:"Prototipe Lokalisasi AI",input_label:"Teks Masukan",input_ph:"Tempel atau tulis teks di siniâ€¦",target_lang:"Bahasa Tujuan",loc_style:"Gaya Lokalisasi",substyle:"Sub-gaya",substyle_for:"Sub-gaya untuk",no_substyle:"Tanpa sub-gaya",submit:"Kirim",result_label:"Hasil",split_view:"Tampilan Terpisah",back:"Kembali",copy:"Salin",copied:"Tersalin!",pane_input:"Masukan",pane_result:"Hasil",clear_highlights:"Hapus Sorotan",rephrase:"Parafrase",choose_lang:"Pilih bahasa antarmuka",toast_enter_text:"Mohon isi teks terlebih dahulu.",toast_choose_target:"Pilih bahasa tujuan atau Parafrase.",toast_choose_style:"Pilih gaya lokalisasi.",toast_error_generic:"Terjadi kesalahan. Coba lagi.",or:"Atau",upload_hint:"Seret & lepas berkas .txt, .docx, .pdf, atau .srt",upload_sub:"â€¦atau klik untuk memilih",download_localized:"Unduh hasil",download_all_zip:"Unduh semua (.zip)",new_tab:"Tab Baru",open_files:"Buka berkas",translate_all:"Terjemahkan semua",export:"Ekspor",export_pdf:"Ekspor ke PDF",export_docx:"Ekspor ke DOCX",export_txt:"Ekspor ke TXT"},
      zh:{title:"AI æœ¬åœ°åŒ–åŽŸåž‹",input_label:"è¾“å…¥æ–‡æœ¬",input_ph:"åœ¨æ­¤ç²˜è´´æˆ–è¾“å…¥æ–‡æœ¬â€¦",target_lang:"ç›®æ ‡è¯­è¨€",loc_style:"æœ¬åœ°åŒ–é£Žæ ¼",substyle:"å­é£Žæ ¼",substyle_for:"å­é£Žæ ¼ï¼š",no_substyle:"æ— å­é£Žæ ¼",submit:"æäº¤",result_label:"ç»“æžœ",split_view:"åˆ†å±è§†å›¾",back:"è¿”å›ž",copy:"å¤åˆ¶",copied:"å·²å¤åˆ¶ï¼",pane_input:"è¾“å…¥",pane_result:"ç»“æžœ",clear_highlights:"æ¸…é™¤é«˜äº®",rephrase:"æ”¹å†™",choose_lang:"é€‰æ‹©ç•Œé¢è¯­è¨€",toast_enter_text:"è¯·å…ˆè¾“å…¥æ–‡æœ¬ã€‚",toast_choose_target:"è¯·é€‰æ‹©ç›®æ ‡è¯­è¨€æˆ–æ”¹å†™ã€‚",toast_choose_style:"è¯·é€‰æ‹©æœ¬åœ°åŒ–é£Žæ ¼ã€‚",toast_error_generic:"å‡ºé”™äº†ï¼Œè¯·é‡è¯•ã€‚",or:"æˆ–",upload_hint:"æ‹–æ‹½ .txtã€.docxã€.pdf æˆ– .srt åˆ°æ­¤å¤„",upload_sub:"â€¦æˆ–ç‚¹å‡»é€‰æ‹©",download_localized:"ä¸‹è½½æœ¬åœ°åŒ–æ–‡ä»¶",download_all_zip:"å…¨éƒ¨ä¸‹è½½ (.zip)",new_tab:"æ–°å»ºæ ‡ç­¾",open_files:"æ‰“å¼€æ–‡ä»¶",translate_all:"å…¨éƒ¨ç¿»è¯‘",export:"å¯¼å‡º",export_pdf:"å¯¼å‡ºä¸º PDF",export_docx:"å¯¼å‡ºä¸º DOCX",export_txt:"å¯¼å‡ºä¸º TXT"},
      fr:{title:"Prototype de Localisation IA",input_label:"Texte d'entrÃ©e",input_ph:"Collez ou saisissez votre texte iciâ€¦",target_lang:"Langue cible",loc_style:"Style de localisation",substyle:"Sous-style",substyle_for:"Sous-style pour",no_substyle:"Aucun sous-style",submit:"Envoyer",result_label:"RÃ©sultat",split_view:"Vue scindÃ©e",back:"Retour",copy:"Copier",copied:"CopiÃ© !",pane_input:"EntrÃ©e",pane_result:"RÃ©sultat",clear_highlights:"Effacer les surlignages",rephrase:"Reformuler",choose_lang:"Choisissez votre langue",toast_enter_text:"Veuillez d'abord saisir du texte.",toast_choose_target:"Choisissez une langue cible ou Reformuler.",toast_choose_style:"Choisissez un style de localisation.",toast_error_generic:"Un problÃ¨me est survenu. RÃ©essayez.",or:"Ou",upload_hint:"Glissez-dÃ©posez un .txt, .docx, .pdf ou .srt",upload_sub:"â€¦ou cliquez pour parcourir",download_localized:"TÃ©lÃ©charger la version localisÃ©e",download_all_zip:"Tout tÃ©lÃ©charger (.zip)",new_tab:"Nouvel onglet",open_files:"Ouvrir des fichiers",translate_all:"Tout traduire",export:"Exporter",export_pdf:"Exporter en PDF",export_docx:"Exporter en DOCX",export_txt:"Exporter en TXT"},
      es:{title:"Prototipo de LocalizaciÃ³n IA",input_label:"Texto de entrada",input_ph:"Pega o escribe tu texto aquÃ­â€¦",target_lang:"Idioma de destino",loc_style:"Estilo de localizaciÃ³n",substyle:"Subestilo",substyle_for:"Subestilo para",no_substyle:"Sin subestilo",submit:"Enviar",result_label:"Resultado",split_view:"Vista dividida",back:"Volver",copy:"Copiar",copied:"Â¡Copiado!",pane_input:"Entrada",pane_result:"Resultado",clear_highlights:"Borrar resaltados",rephrase:"Reformular",choose_lang:"Selecciona tu idioma",toast_enter_text:"Primero escribe algÃºn texto.",toast_choose_target:"Elige un idioma objetivo o Reformular.",toast_choose_style:"Elige un estilo de localizaciÃ³n.",toast_error_generic:"Algo saliÃ³ mal. IntÃ©ntalo de nuevo.",or:"O",upload_hint:"Arrastra y suelta un .txt, .docx, .pdf o .srt",upload_sub:"â€¦o haz clic para elegir",download_localized:"Descargar localizado",download_all_zip:"Descargar todo (.zip)",new_tab:"Nueva pestaÃ±a",open_files:"Abrir archivos",translate_all:"Traducir todo",export:"Exportar",export_pdf:"Exportar a PDF",export_docx:"Exportar a DOCX",export_txt:"Exportar a TXT"}
    };
    const DEFAULT_LANG='en';
    const UI_LANGS=[{code:'en',label:'English'},{code:'id',label:'Bahasa Indonesia'},{code:'zh',label:'ä¸­æ–‡'},{code:'fr',label:'FranÃ§ais'},{code:'es',label:'EspaÃ±ol'}];
    const face=code=>({en:'En',id:'Id',zh:'Zh',fr:'Fr',es:'Es'})[code]||code.toUpperCase();
    const t=key=>{const lang=localStorage.getItem('uiLang')||DEFAULT_LANG;return (LOCALES[lang]&&LOCALES[lang][key])||LOCALES[DEFAULT_LANG][key]||key};

    const LANG_LABELS={
      en:{
        Bahasa:'Bahasa',Chinese:'Chinese',English:'English',French:'French',Spanish:'Spanish',
        Arabic:'Arabic',Danish:'Danish',Dutch:'Dutch',German:'German',Hindi:'Hindi',Italian:'Italian',Japanese:'Japanese',Malay:'Malay',Portuguese:'Portuguese',Russian:'Russian',Swedish:'Swedish',Thai:'Thai',Turkish:'Turkish'
      },
      id:{
        Bahasa:'Bahasa Indonesia',Chinese:'Tionghoa',English:'Inggris',French:'Prancis',Spanish:'Spanyol',
        Arabic:'Arab',Danish:'Denmark',Dutch:'Belanda',German:'Jerman',Hindi:'Hindi',Italian:'Italia',Japanese:'Jepang',Malay:'Melayu',Portuguese:'Portugis',Russian:'Rusia',Swedish:'Swedia',Thai:'Thai',Turkish:'Turki'
      },
      zh:{
        Bahasa:'å°å°¼è¯­',Chinese:'ä¸­æ–‡',English:'è‹±è¯­',French:'æ³•è¯­',Spanish:'è¥¿ç­ç‰™è¯­',
        Arabic:'é˜¿æ‹‰ä¼¯è¯­',Danish:'ä¸¹éº¦è¯­',Dutch:'è·å…°è¯­',German:'å¾·è¯­',Hindi:'å°åœ°è¯­',Italian:'æ„å¤§åˆ©è¯­',Japanese:'æ—¥è¯­',Malay:'é©¬æ¥è¯­',Portuguese:'è‘¡è„ç‰™è¯­',Russian:'ä¿„è¯­',Swedish:'ç‘žå…¸è¯­',Thai:'æ³°è¯­',Turkish:'åœŸè€³å…¶è¯­'
      },
      fr:{
        Bahasa:'IndonÃ©sien',Chinese:'Chinois',English:'Anglais',French:'FranÃ§ais',Spanish:'Espagnol',
        Arabic:'Arabe',Danish:'Danois',Dutch:'NÃ©erlandais',German:'Allemand',Hindi:'Hindi',Italian:'Italien',Japanese:'Japonais',Malay:'Malais',Portuguese:'Portugais',Russian:'Russe',Swedish:'SuÃ©dois',Thai:'ThaÃ¯',Turkish:'Turc'
      },
      es:{
        Bahasa:'Indonesio',Chinese:'Chino',English:'InglÃ©s',French:'FrancÃ©s',Spanish:'EspaÃ±ol',
        Arabic:'Ãrabe',Danish:'DanÃ©s',Dutch:'NeerlandÃ©s',German:'AlemÃ¡n',Hindi:'Hindi',Italian:'Italiano',Japanese:'JaponÃ©s',Malay:'Malayo',Portuguese:'PortuguÃ©s',Russian:'Ruso',Swedish:'Sueco',Thai:'TailandÃ©s',Turkish:'Turco'
      }
    };
    const langLabel=k=>{const lang=localStorage.getItem('uiLang')||DEFAULT_LANG;return (LANG_LABELS[lang]?.[k])||(LANG_LABELS[DEFAULT_LANG]?.[k])||k};

    const STYLE_I18N = window.STYLE_I18N || {};
    const nicify = s => String(s).replace(/-/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
    const styleLabel = k => {
      const L = localStorage.getItem('uiLang') || DEFAULT_LANG;
      return (STYLE_I18N?.[L]?.style?.[k]) || (STYLE_I18N?.en?.style?.[k]) || nicify(k);
    };
    const subLabel = k => {
      const L = localStorage.getItem('uiLang') || DEFAULT_LANG;
      return (STYLE_I18N?.[L]?.sub?.[k]) || (STYLE_I18N?.en?.sub?.[k]) || nicify(k);
    };

    const STYLE_MICROCOPY = window.STYLE_MICROCOPY || {};
    const microcopyText = (mode, sub) => {
      const L = localStorage.getItem('uiLang') || DEFAULT_LANG;
      const m = STYLE_MICROCOPY?.[L]?.[mode]?.[sub];
      if (m) return m;
      return STYLE_MICROCOPY?.[DEFAULT_LANG]?.[mode]?.[sub] || "";
    };

    /* ---------------- State ---------------- */
    let selectedMode="",targetLanguage="",selectedSubStyle="",rephrase=false,splitView=false;

    // === Tabs/documents state ===
    const docs=[]; // {id,name,ext,size,mime,text,cues,srtTranslations,lastAlignedTgt,output,isSrt}
    const exportMenus=[];
    let activeId=null;
    let seq=1; // for Untitled counters

    const COPY_SVG='<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="3"></rect><rect x="2" y="2" width="13" height="13" rx="3"></rect></svg>';
    const CHECK_SVG='<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"></path></svg>';
    const GLOBE_SVG='<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M3 12h18M12 3a12 12 0 0 1 0 18M12 3a12 12 0 0 0 0 18"></path></svg>';

    /* UI helpers */
    function autosizeTextarea(el){
      if(!el) return;
      const cap = Number(el.dataset.maxh || 420);
      el.style.height='auto';
      const h = Math.max(44, el.scrollHeight);
      const finalH = Math.min(cap, h);
      el.style.height = finalH + 'px';
      if (h > cap) { el.style.overflowY = 'auto'; }
      else { el.style.overflowY = 'hidden'; }
    }
    function setLoaderText(msg){
      // Bridge old loader updates to new status tab
      setStatus(msg||'Localizingâ€¦');
      const n=$('#glassLoader .glass-text');
      if(n){ n.textContent = msg || 'Localizingâ€¦'; }
    }
    function showLoader(disableBtn,msg){
      // Redirect loader to status tab per new UX
      if(disableBtn){$('#submitBtn')?.setAttribute('disabled','true');$('#submitAllBtn')?.setAttribute('disabled','true')}
      showStatus(msg||'Workingâ€¦');
    }
    function hideLoader(enableBtn){
      // Smoothly delay hide so user can read the final status
      setTimeout(()=>hideStatus(),1300);
      $('#cardRoot')?.setAttribute('aria-busy','false');
      if(enableBtn){$('#submitBtn')?.removeAttribute('disabled');$('#submitAllBtn')?.removeAttribute('disabled')}
    }
    // Upload progress functions
    function showUploadProgress(){
      console.log('ðŸ”„ showUploadProgress called');
      let progressBar = $('#uploadProgressBar');
      if (!progressBar) {
        console.log('ðŸ“Š Creating new progress bar');
        // Create progress bar if it doesn't exist
        let targetContainer = $('#tabsContainer');
        console.log('ðŸ“ Tabs container:', targetContainer);
        
        // Fallback containers if tabs container not found
        if (!targetContainer) {
          targetContainer = $('.card') || $('#cardRoot') || document.body;
          console.log('ðŸ“ Using fallback container:', targetContainer);
        }
        
        if (targetContainer) {
          progressBar = document.createElement('div');
          progressBar.id = 'uploadProgressBar';
          progressBar.className = 'upload-progress-bar';
          progressBar.innerHTML = `
            <div class="upload-progress-text">Uploading...</div>
            <div class="upload-progress-track">
              <div class="upload-progress-fill"></div>
            </div>
          `;
          
          // Insert after tabs container or at the beginning of fallback container
          if (targetContainer.id === 'tabsContainer') {
            targetContainer.parentNode.insertBefore(progressBar, targetContainer.nextSibling);
          } else {
            targetContainer.insertBefore(progressBar, targetContainer.firstChild);
          }
          console.log('ðŸ“Š Progress bar created and inserted');
        } else {
          console.error('âŒ No suitable container found');
        }
      } else {
        console.log('ðŸ“Š Using existing progress bar');
      }
      if (progressBar) {
        progressBar.classList.add('show');
        progressBar.classList.add('is-busy');
        const fill = progressBar.querySelector('.upload-progress-fill');
        if (fill) fill.style.width = '0%';
        console.log('ðŸ“Š Progress bar shown');
      } else {
        console.error('âŒ Progress bar not found after creation attempt');
      }
    }
    
    function hideUploadProgress(){
      const progressBar = $('#uploadProgressBar');
      if (progressBar) {
        progressBar.classList.remove('is-busy');
        // keep visible for a short pause, then collapse
        setTimeout(()=>{ progressBar.classList.remove('show'); }, 1200);
        setTimeout(() => {
          const fill = progressBar.querySelector('.upload-progress-fill');
          if (fill) fill.style.width = '0%';
        }, 1600);
      }
    }
    
    function updateUploadProgress(current, total, fileName = ''){
      console.log(`ðŸ“Š updateUploadProgress: ${current}/${total}, file: ${fileName}`);
      const progressBar = $('#uploadProgressBar');
      if (progressBar) {
        const percentage = Math.round((current / total) * 100);
        const fill = progressBar.querySelector('.upload-progress-fill');
        const text = progressBar.querySelector('.upload-progress-text');
        if (fill) {
          fill.style.width = percentage + '%';
          console.log(`ðŸ“Š Progress updated to ${percentage}%`);
        }
        if (text) {
          if (fileName) {
            text.textContent = `Uploading ${fileName}... ${current}/${total}`;
          } else {
            text.textContent = `Uploading... ${current}/${total}`;
          }
          console.log(`ðŸ“Š Progress text updated: ${text.textContent}`);
        }
      } else {
        console.error('âŒ Progress bar not found in updateUploadProgress');
      }
    }
    
    function setUploadProgressText(message){
      const progressBar = $('#uploadProgressBar');
      if (progressBar) {
        const text = progressBar.querySelector('.upload-progress-text');
        if (text){
          // Extract base message without trailing dots or ellipsis, then add animated dots via CSS
          const base = String(message||'').replace(/[\.\u2026]+\s*$/,'');
          text.textContent = base + ' ';
          text.setAttribute('data-ellipsis','');
        }
      }
    }
    // Generic status helpers (centralized status tab)
    function showStatus(message){ showUploadProgress(); setUploadProgressText(message||'Workingâ€¦'); }
    function setStatus(message){ setUploadProgressText(message||''); const el=$('#uploadProgressBar'); if(el){ if(/done|complete|success/i.test(message||'')){ el.classList.remove('is-busy'); } else { el.classList.add('is-busy'); } } }
    function hideStatus(){ hideUploadProgress(); }
    
    // Process file operations in chunks to prevent UI freezing
    async function processFileInChunks(parsed) {
      console.log(`ðŸ“„ Processing file in chunks: ${parsed.originalName}`);
      
      // Yield before DOM operations
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Add document in chunks
      addDocFromFile(parsed);
      
      // Yield after DOM operations
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Update badge
      setBadge({name:parsed.originalName, ext:parsed.ext, size:parsed.size});
      
      // Final yield
      await new Promise(resolve => setTimeout(resolve, 50));
      
      console.log(`ðŸ“„ File processing completed: ${parsed.originalName}`);
    }
    function hasAnyResult(){
      const d = currentDoc();
      if(!d) return false;
      if(d.isSrt) return (d.srtTranslations||[]).some(x => (x||'').trim().length>0);
      return !!((d.output||'').trim());
    }
    function updateActionButtonsEnabled(){
      const hasOutput = docs.some(d=>{
        if(!d) return false;
        if(d.isSrt) return (d.srtTranslations||[]).some(x=>x && x.trim());
        return (d.output||'').trim().length>0;
      });
      ['#downloadInlineBtn','#downloadAllInlineBtn','#downloadSplitBtn','#downloadAllSplitBtn'].forEach(sel=>{
        const el=$(sel); if(!el) return;
        el.toggleAttribute('disabled', !hasOutput);
      });
      const splitToggle=$('#toggleSplit');
      if(splitToggle) splitToggle.disabled=!hasAnyResult();
      const activeDoc=currentDoc();
      const hasInput = activeDoc ? buildSourceExportText(activeDoc).trim().length>0 : false;
      ['#exportInlineToggle','#exportSplitToggle'].forEach(sel=>{
        const toggle=$(sel); if(!toggle) return;
        if(hasInput){
          toggle.removeAttribute('disabled');
          toggle.classList.remove('is-disabled');
        }else{
          toggle.setAttribute('disabled','true');
          toggle.classList.add('is-disabled');
          const root = toggle.closest('.export-menu');
          if(root) closeExportMenu(root);
        }
      });
    }
    function updateSplitButton(){
      const btn=$('#toggleSplit');
      btn.disabled=!hasAnyResult();
      btn.textContent=splitView?t('back'):t('split_view');
      updateActionButtonsEnabled();
    }
    function maybeShowSubmitAll(){
      const multi = docs.length>1;
      $('#submitAllBtn')?.classList.toggle('is-hidden', !multi);
    }
    function animateCopy(btn){const original=btn._originalHTML||btn.innerHTML;btn._originalHTML=original;btn.classList.add('copied');btn.innerHTML=CHECK_SVG+'<span>'+t('copied')+'</span>';clearTimeout(btn._t);btn._t=setTimeout(()=>{btn.classList.remove('copied');btn.innerHTML=original},1100)}
    function escapeHTML(s=''){return s.replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))}
    const NOTIFICATION_ICONS = {
      info: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>',
      success: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="m9 12 2 2 4-4"></path></svg>',
      warning: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="m10.29 3.86-8.47 14.14A2 2 0 0 0 3.53 21h16.94a2 2 0 0 0 1.71-2.99L13.71 3.86a2 2 0 0 0-3.42 0Z"></path><path d="M12 9v4"></path><path d="M12 17h.01"></path></svg>',
      error: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="m15 9-6 6"></path><path d="m9 9 6 6"></path></svg>'
    };

    class NotificationCenter {
      constructor() {
        this.maxVisible = 3;
        this.queue = [];
        this.active = new Map();
        this.counter = 0;
        this.host = null;
        this.ensureHost();
      }

      ensureHost() {
        if (this.host && document.body && document.body.contains(this.host)) {
          return this.host;
        }
        let host = document.getElementById('notificationHost');
        if (!host) {
          host = document.createElement('div');
          host.id = 'notificationHost';
          host.className = 'notification-host';
          host.setAttribute('aria-live', 'polite');
          host.setAttribute('aria-atomic', 'true');
          (document.body || document.documentElement).appendChild(host);
        }
        this.host = host;
        return host;
      }

      normaliseTone(tone) {
        const value = (tone || 'info').toLowerCase();
        return ['success', 'error', 'warning', 'info'].includes(value) ? value : 'info';
      }

      getAutoDuration(payload) {
        if (typeof payload.duration === 'number') {
          return Math.max(0, payload.duration);
        }
        const length = (payload.message || '').length;
        const estimate = 3500 + (length * 60) + (payload.title ? 1000 : 0);
        return Math.max(3500, Math.min(8000, estimate));
      }

      push(config = {}) {
        const host = this.ensureHost();
        if (!host) return null;
        const tone = this.normaliseTone(config.tone);
        const id = `notification-${++this.counter}`;
        const item = {
          id,
          title: (config.title || '').trim(),
          message: config.message ? String(config.message) : '',
          tone,
          dismissible: config.dismissible !== false,
          persist: !!(config.persist || config.sticky),
          duration: config.persist || config.sticky ? 0 : this.getAutoDuration(config),
          role: tone === 'error' ? 'alert' : 'status'
        };

        if (this.active.size >= this.maxVisible) {
          this.queue.push(item);
        } else {
          this.mount(item);
        }
        return id;
      }

      mount(item) {
        const element = this.buildElement(item);
        this.ensureHost().appendChild(element);
        const record = {
          item,
          element,
          timer: null,
          remaining: item.duration,
          dismissAt: item.duration ? performance.now() + item.duration : null
        };
        this.active.set(item.id, record);

        if (item.duration > 0) {
          record.timer = setTimeout(() => this.dismiss(item.id), item.duration);
        }

        element.addEventListener('mouseenter', () => this.pause(item.id));
        element.addEventListener('mouseleave', () => this.resume(item.id));
      }

      buildElement(item) {
        const card = document.createElement('div');
        card.className = `notification-card notification-card--${item.tone}`;
        card.dataset.notificationId = item.id;
        card.setAttribute('role', item.role);

        const iconWrap = document.createElement('span');
        iconWrap.className = 'notification-card__icon';
        iconWrap.innerHTML = NOTIFICATION_ICONS[item.tone] || NOTIFICATION_ICONS.info;

        const body = document.createElement('div');
        body.className = 'notification-card__body';

        if (item.title) {
          const titleEl = document.createElement('div');
          titleEl.className = 'notification-card__title';
          titleEl.textContent = item.title;
          body.appendChild(titleEl);
        }

        if (item.message) {
          const messageEl = document.createElement('div');
          messageEl.className = 'notification-card__message';
          messageEl.textContent = item.message;
          body.appendChild(messageEl);
        }

        card.appendChild(iconWrap);
        card.appendChild(body);

        if (item.dismissible) {
          const close = document.createElement('button');
          close.className = 'notification-card__close';
          close.type = 'button';
          close.setAttribute('aria-label', 'Dismiss notification');
          close.textContent = '\u00D7';
          close.addEventListener('click', () => this.dismiss(item.id));
          card.appendChild(close);
        }

        return card;
      }

      pause(id) {
        const record = this.active.get(id);
        if (!record || record.item.duration <= 0) return;
        if (record.timer) {
          clearTimeout(record.timer);
          record.timer = null;
        }
        record.remaining = Math.max(0, (record.dismissAt || 0) - performance.now());
      }

      resume(id) {
        const record = this.active.get(id);
        if (!record || record.item.duration <= 0) return;
        const remaining = record.remaining ?? record.item.duration;
        if (remaining <= 0) {
          this.dismiss(id);
          return;
        }
        record.dismissAt = performance.now() + remaining;
        record.timer = setTimeout(() => this.dismiss(id), remaining);
      }

      dismiss(id) {
        const record = this.active.get(id);
        if (!record) {
          const idx = this.queue.findIndex(entry => entry.id === id);
          if (idx !== -1) this.queue.splice(idx, 1);
          return;
        }
        if (record.timer) {
          clearTimeout(record.timer);
        }
        const { element } = record;
        if (!element) {
          this.active.delete(id);
          this.flush();
          return;
        }

        const finish = () => {
          element.removeEventListener('animationend', finish);
          if (element.parentElement) {
            element.parentElement.removeChild(element);
          }
          this.active.delete(id);
          this.flush();
        };

        element.classList.add('notification-leave');
        element.addEventListener('animationend', finish, { once: true });
        setTimeout(() => {
          if (element.isConnected) {
            finish();
          }
        }, 350);
      }

      flush() {
        if (this.queue.length === 0) return;
        if (this.active.size >= this.maxVisible) return;
        const next = this.queue.shift();
        if (next) {
          this.mount(next);
        }
      }

      clearAll() {
        Array.from(this.active.keys()).forEach(id => this.dismiss(id));
        this.queue.length = 0;
      }
    }

    const notificationCenter = new NotificationCenter();
    window.notificationCenter = notificationCenter;

    function showToast(message, options = {}) {
      if (typeof options === 'string') {
        options = { tone: options };
      }
      const config = options && typeof options === 'object' ? options : {};
      notificationCenter.push({
        title: config.title || '',
        message: message != null ? String(message) : '',
        tone: config.tone || config.type || 'warning',
        duration: config.duration,
        dismissible: config.dismissible !== false,
        persist: !!(config.persist || config.sticky)
      });
    }
    window.showToast = showToast;

    window.showNotification = function(title, message, type = 'info', options = {}) {
      const config = options && typeof options === 'object' ? options : {};
      notificationCenter.push({
        title: title != null ? String(title) : '',
        message: message != null ? String(message) : '',
        tone: config.tone || type || 'info',
        duration: config.duration,
        dismissible: config.dismissible !== false,
        persist: !!(config.persist || config.sticky)
      });
    };

    function pulse(el){if(!el)return;el.classList.add('field-pulse');setTimeout(()=>el.classList.remove('field-pulse'),900)}

    /* ---------- Tabs ---------- */
    function currentDoc(){ return docs.find(d=>d.id===activeId) || null; }
    function addTextTab(){
      const doc={ id:'d'+Date.now()+Math.random().toString(36).slice(2),
        name:`Untitled ${seq++}`, ext:'txt', size:0, mime:'text/plain',
        text:'', cues:[], srtTranslations:[], lastAlignedTgt:[], output:'', isSrt:false
      };
      docs.push(doc);
      activeId = doc.id;
      renderTabs(); loadDocToUI(doc); maybeShowSubmitAll();
      $('#inputText')?.focus();
    }
    function addDocFromFile(parsed){
      const ext=(parsed.ext||'').replace(/^\./,'').toLowerCase();
      const doc={ id:'d'+Date.now()+Math.random().toString(36).slice(2),
        name: parsed.originalName || parsed.name || 'file',
        ext, size: parsed.size||0, mime: parsed.mime||'',
        text: parsed.text||'',
        cues: Array.isArray(parsed.cues)?parsed.cues:[],
        srtTranslations: Array.isArray(parsed.cues)?new Array(parsed.cues.length).fill(''):[],
        lastAlignedTgt:[], output:'', isSrt: (ext==='srt')
      };
      docs.push(doc); activeId=doc.id;
      renderTabs(); loadDocToUI(doc); maybeShowSubmitAll();
      
      // Update character count after file is loaded
      setTimeout(() => {
        if (window.updateCharacterCount) {
          window.updateCharacterCount();
        }
      }, 100);
    }
    function closeDoc(id){
      const idx=docs.findIndex(d=>d.id===id);
      if(idx<0) return;
      docs.splice(idx,1);
      if(!docs.length){ addTextTab(); } else {
        if(activeId===id){ activeId = docs[Math.max(0, idx-1)].id; }
        renderTabs(); loadDocToUI(currentDoc());
      }
      maybeShowSubmitAll();
    }
    function renderTabs(){
      const bar=$('#tabBar'); if(!bar) return;
      bar.innerHTML = docs.map(d=>{
        return `<button class="tab ${d.id===activeId?'active':''}" role="tab" aria-selected="${d.id===activeId?'true':'false'}" data-id="${d.id}" title="${escapeHTML(d.name)}">
                  <span class="tab-title">${escapeHTML(d.name)}</span>
                  <span class="tab-ext">${escapeHTML((d.ext||'').toUpperCase())}</span>
                  <span class="tab-close" data-close="${d.id}" title="Close">Ã—</span>
                </button>`;
      }).join('');
      // Click to activate (defer to allow double-click detection)
      bar.querySelectorAll('.tab').forEach(el=>{
        el.addEventListener('click',e=>{
          if(e.target && e.target.matches('.tab-close')) return;
          // Ignore clicks while renaming
          if(el.classList.contains('renaming')) { clearTimeout(el._singleTimer); return; }
          if(e.target && (e.target.tagName==='INPUT' || e.target.closest('input'))) { clearTimeout(el._singleTimer); return; }
          clearTimeout(el._singleTimer);
          el._singleTimer = setTimeout(()=>{
            const id=el.getAttribute('data-id');
            if(id){ activeId=id; renderTabs(); loadDocToUI(currentDoc()); }
          }, 200);
        });

        // Doubleâ€‘click to rename (cancel single-click)
        el.addEventListener('dblclick', e=>{
          clearTimeout(el._singleTimer);
          const tab=el; const id=tab.getAttribute('data-id'); if(!id) return;
          if(e.target && e.target.matches('.tab-close')) return;
          const doc=docs.find(d=>d.id===id); if(!doc) return;
          const titleSpan=tab.querySelector('.tab-title'); if(!titleSpan) return;
          const old=doc.name||'';
          const titleStyle = getComputedStyle(titleSpan);
          const input=document.createElement('input');
          input.type='text';
          input.value=old;
          input.className='tab-rename';
          input.setAttribute('aria-label','Rename tab');
          input.style.border='1px solid var(--border)';
          input.style.borderRadius='8px';
          input.style.font='inherit';
          input.style.fontSize='13px';
          input.style.padding='2px 6px';
          input.style.minWidth='20px';
          input.style.maxWidth='320px';
          input.style.background='#fff';
          input.style.outline='none';
          input.style.width = Math.min(320, Math.max(20, measureTextWidth(old, titleStyle) + 14)) + 'px';
          // Mark tab as editing and replace title with input
          tab.classList.add('renaming');
          titleSpan.replaceWith(input);
          input.focus();
          input.select();

          const commit=(val)=>{
            const name=(val||'').trim()||old;
            if(name!==doc.name){ doc.name=name; }
            // Re-render tabs to restore normal DOM and ensure ext/close remain
            renderTabs();
            // Keep the same active document
            loadDocToUI(currentDoc());
          };
          const cancel=()=>{ renderTabs(); loadDocToUI(currentDoc()); };

          // Prevent parent button activation while editing
          ['click','mousedown','mouseup','dblclick'].forEach(evt=>{
            input.addEventListener(evt, ev=>{ ev.stopPropagation(); }, true);
          });
          
          input.addEventListener('keydown', ev=>{
            // Handle commit/cancel and keep events local to the input
            ev.stopPropagation();
            if(ev.key==='Enter'){ ev.preventDefault(); ev.stopPropagation(); commit(input.value); }
            else if(ev.key==='Escape'){ ev.preventDefault(); ev.stopPropagation(); cancel(); }
          });
          input.addEventListener('blur', ()=>commit(input.value));

          // Live resize while typing
          input.addEventListener('input', ()=>{
            const px = Math.min(320, Math.max(20, measureTextWidth(input.value, titleStyle) + 14));
            input.style.width = px + 'px';
          });
        });
      });
      // Click to close
      bar.querySelectorAll('.tab .tab-close').forEach(el=>{
        el.addEventListener('click', e=>{e.stopPropagation(); closeDoc(el.getAttribute('data-close'));});
      });
      enableDragScroll(bar);
      updateSplitButton();
    }
    // Measure text width with current styles to auto-size rename input / tab
    function measureTextWidth(text, style){
      try{
        const canvas = measureTextWidth._c || (measureTextWidth._c=document.createElement('canvas'));
        const ctx = canvas.getContext('2d');
        const font = `${style.fontWeight||'normal'} ${style.fontSize||'13px'} ${style.fontFamily||'Inter, system-ui, sans-serif'}`;
        ctx.font = font;
        return ctx.measureText(String(text||'')).width;
      }catch(_){
        // Fallback approximate width per char
        return String(text||'').length * 7;
      }
    }
    /* Grab-to-scroll for tabs â€” fixed so clicks still work */
    function enableDragScroll(node){
      if(!node || node._dragWired) return;
      let isDown=false, isDragging=false, startX=0, scrollLeft=0;
      node.addEventListener('pointerdown',e=>{
        if(e.button!==0) return;
        isDown=true; isDragging=false; node.classList.add('grabbing');
        startX=e.clientX; scrollLeft=node.scrollLeft;
      });
      node.addEventListener('pointermove',e=>{
        if(!isDown) return;
        const dx=e.clientX-startX;
        if(Math.abs(dx)>3) isDragging=true;      // threshold to count as drag
        if(isDragging) node.scrollLeft=scrollLeft-dx;
      });
      const end=(e)=>{
        if(!isDown) return;
        if(isDragging){ e?.preventDefault?.(); e?.stopPropagation?.(); }
        isDown=false; isDragging=false; node.classList.remove('grabbing');
      };
      node.addEventListener('pointerup',end); node.addEventListener('pointercancel',end);
      node._dragWired=true;
    }

    /* ---------- Build language/style controls ---------- */
    function buildLangButtons(){
      const row=$('#langButtonsRow'); if(!row) return;
      const current=targetLanguage;
      const sorted=[...TARGET_KEYS].sort((a,b)=>langLabel(a).localeCompare(langLabel(b)));
      let html=`<button id="btnRephrase" class="btn toggle-btn" type="button" data-kind="rephrase">${t('rephrase')}</button>`;
      html+=sorted.map(k=>`<button class="btn toggle-btn lang-btn" type="button" data-lang="${k}">${langLabel(k)}</button>`).join('');
      row.innerHTML=html;
      $('#btnRephrase')?.addEventListener('click',toggleRephrase);
      $$('.lang-btn').forEach(b=>b.addEventListener('click',()=>selectTarget(b.dataset.lang)));
      if(rephrase) $('#btnRephrase')?.classList.add('active');
      $$('.lang-btn').forEach(b=>b.classList.toggle('active',b.dataset.lang===current));
    }
    function buildStyleButtons(){
      const row=$('#styleButtonsRow'); if(!row) return;
      const current=selectedMode;
      const keys=Object.keys(STYLE_DEF);
      row.innerHTML=keys.map(k=>`<button class="btn style-btn" data-mode="${k}" type="button">${styleLabel(k)}</button>`).join('');
      $$('.style-btn').forEach(b=>b.addEventListener('click',()=>setMode(b.dataset.mode)));
      if(current){document.querySelector(`.style-btn[data-mode="${current}"]`)?.classList.add('active')}
    }

    /* ---------- Language modal ---------- */
    function renderLangGrid(){const grid=$('#langGrid');if(!grid) return;const cur=localStorage.getItem('uiLang')||DEFAULT_LANG;grid.innerHTML=UI_LANGS.map(item=>`<div class="lang-item${item.code===cur?' active':''}" data-code="${item.code}" role="button" tabindex="0" aria-label="${item.label}"><div>${item.label}</div><div class="lang-code">${face(item.code)} <span class="lang-check">âœ“</span></div></div>`).join('')}
    function openLangModal(){const ov=$('#langOverlay'); if(!ov) return; ov.classList.add('show'); ov.setAttribute('aria-hidden','false'); $('#uiLangBtn')?.setAttribute('aria-expanded','true'); const onKey=e=>{if(e.key==='Escape')closeLangModal()}; const onClick=e=>{if(e.target.id==='langOverlay')closeLangModal()}; ov._onKey=onKey; ov._onClick=onClick; document.addEventListener('keydown',onKey); ov.addEventListener('click',onClick); $('#langGrid')?.addEventListener('click',ov._onPick=evt=>{const it=evt.target.closest('.lang-item'); if(!it) return; setUiLang(it.dataset.code); closeLangModal()})}
    function closeLangModal(){const ov=$('#langOverlay'); if(!ov) return; ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); $('#uiLangBtn')?.setAttribute('aria-expanded','false'); document.removeEventListener('keydown',ov._onKey||(()=>{})); ov.removeEventListener('click',ov._onClick||(()=>{})); $('#langGrid')?.removeEventListener('click',ov._onPick||(()=>{}))}

    function applyI18n(){
      document.title=t('title');
      document.documentElement.lang=localStorage.getItem('uiLang')||DEFAULT_LANG;
      $$('.title,[data-i18n="title"]').forEach(n=>n.textContent=t('title'));
      $$('[data-i18n]').forEach(n=>{const k=n.getAttribute('data-i18n'); if(k && k!=='title') n.textContent=t(k)});
      $('#inputText')?.setAttribute('placeholder',t('input_ph'));
      const code=localStorage.getItem('uiLang')||DEFAULT_LANG;
      const faceBtn=$('#uiLangBtn'); if(faceBtn){faceBtn.innerHTML=`${GLOBE_SVG}<span>${face(code)}</span>`; faceBtn.title=t('choose_lang')}
      const tl=targetLanguage, mode=selectedMode, sub=selectedSubStyle, wasRephrase=rephrase;
      buildLangButtons(); buildStyleButtons();
      if(wasRephrase) $('#btnRephrase')?.classList.add('active');
      if(tl){$$('.lang-btn').forEach(b=>b.classList.toggle('active',b.dataset.lang===tl))}
      if(mode){renderSubstyles(mode); if(sub) setSubStyle(sub); }
      renderLangGrid();
      updateSplitButton();
      applyContentDirection();
    }
    function setUiLang(lang){localStorage.setItem('uiLang',lang); document.documentElement.dir=['ar','he','fa','ur'].includes(lang)?'rtl':'ltr'; applyI18n()}

    document.addEventListener('click', event=>{
      if(!exportMenus.length) return;
      exportMenus.forEach(menu=>{
        if(menu.root?.dataset?.open==='true' && !menu.root.contains(event.target)){
          menu.close();
        }
      });
    });

  document.addEventListener('DOMContentLoaded',()=>{
      document.body.classList.remove('no-js');
      const saved=localStorage.getItem('uiLang')||DEFAULT_LANG; setUiLang(saved);
      buildLangButtons(); buildStyleButtons();

      injectHistoryButton();

      $('#uiLangBtn')?.addEventListener('click',()=>{renderLangGrid(); openLangModal()});
      $('#langCloseBtn')?.addEventListener('click',closeLangModal);

      $('#substyleTrigger')?.addEventListener('click',()=>{toggleSubstylePanel();adjustWrapHeight()});

      $('#submitBtn')?.addEventListener('click',()=>submitActiveDoc());
      $('#submitAllBtn')?.addEventListener('click',translateAllTabs);
      $('#toggleSplit')?.addEventListener('click',toggleSplitView);
      $('#addTextTabBtn')?.addEventListener('click',addTextTab);

      // Inline output actions
      $('#copyBtn')?.addEventListener('click',()=>copyText('#outputText','#copyBtn'));
      $('#copySplitBtn')?.addEventListener('click',()=>copyText('#outputText','#copySplitBtn'));
      $('#downloadInlineBtn')?.addEventListener('click',()=>downloadLocalized(currentDoc()));
      $('#downloadAllInlineBtn')?.addEventListener('click',downloadAllZip);
      $('#downloadSplitBtn')?.addEventListener('click',()=>downloadLocalized(currentDoc()));
      $('#downloadAllSplitBtn')?.addEventListener('click',downloadAllZip);

      wireExportMenu('exportInlineMenu');
      wireExportMenu('exportSplitMenu');
      
      // (removed Edit Mode toggle)

      // Input bindings save to active doc
      $('#inputText')?.addEventListener('input',()=>{
        const d=currentDoc(); if(!d) return;
        d.lastAlignedTgt=[]; d.text=$('#inputText').value;
        autosizeTextarea($('#inputText'));
        if(splitView && !d.isSrt) renderSegmentBoxes(d); adjustWrapHeight(); applyContentDirection();
        updateActionButtonsEnabled();
      });
      $('#outputText')?.addEventListener('input',()=>{
        const d=currentDoc(); if(!d) return;
        d.lastAlignedTgt=[]; d.output=$('#outputText').value;
        autosizeTextarea($('#outputText'));
        if(splitView) renderSegmentBoxes(d); adjustWrapHeight(); applyContentDirection()
      });
      $('#outputRich')?.addEventListener('input',()=>{
        const d=currentDoc(); if(!d) return;
        d.lastAlignedTgt=[]; syncRichToHidden();
        d.output=$('#outputText').value;
        if(splitView && !d.isSrt) renderSegmentBoxes(d); updateSplitButton(); applyContentDirection()
      });

      $('#subStyleContainer')?.classList.add('is-hidden'); setChevron(false); renderSubstyles("");
      initDropzone();
      autosizeTextarea($('#inputText'));
      autosizeTextarea($('#outputText'));
      applyContentDirection();
      // First tab
      addTextTab();

      adjustWrapHeight(); updateSplitButton();
      
      // Initialize Max Localization toggle
      initMaxToggle();
      // Re-evaluate toggle visibility when user tier changes (after async profile fetch)
      setTimeout(() => {
        try { 
          window.addEventListener('user-updated', initMaxToggle);
          // Safe localStorage override to detect user updates
          if (!window._lsPatched) {
            const _lsSet = localStorage.setItem.bind(localStorage);
            localStorage.setItem = function(k, v){
              _lsSet(k, v);
              if (k === 'user') {
                setTimeout(() => {
                  try { window.dispatchEvent(new CustomEvent('user-updated')); } catch {}
                }, 10);
              }
            };
            window._lsPatched = true;
          }
        } catch(e) { console.warn('localStorage patch failed:', e); }
      }, 100);
      
      window.addEventListener('resize',debounce(()=>{if(splitView)equalizeRowHeights();adjustWrapHeight(true)},120));
    });
    /* ---------------- History (client-side only) ---------------- */
    const HISTORY_KEY='locHistory';
    const HISTORY_MAX=30;
    const CLOCK_SVG = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M12 7v6l4 2"></path></svg>';

    function injectHistoryButton(){
      const tb=document.querySelector('#toolbarRow1');
      if(!tb || document.getElementById('historyBtn')) return;
      const btn=document.createElement('button');
      btn.id='historyBtn';
      btn.className='btn face-btn';
      btn.title='Recent runs';
      btn.innerHTML = CLOCK_SVG + '<span>History</span>';
      btn.addEventListener('click',openHistoryModal);
      const langBtn = document.getElementById('uiLangBtn');
      if (langBtn) tb.insertBefore(btn, langBtn);
      else tb.appendChild(btn);
      ensureHistoryOverlay();
    }
    function readHistory(){try{return JSON.parse(localStorage.getItem(HISTORY_KEY)||'[]')}catch{return []}}
    function pushHistory(entry){
      const arr=readHistory();
      arr.unshift(entry);
      while(arr.length>HISTORY_MAX) arr.pop();
      localStorage.setItem(HISTORY_KEY,JSON.stringify(arr));
    }
    const HISTORY_SECURE = true; // store payloads only in sessionStorage
    function makeHistoryEntryFromDoc(doc){
      const id = 'h'+Date.now().toString(36)+Math.random().toString(36).slice(2,8);
      const payloadKey = 'HIST_PAYLOAD:'+id;
      const payload = doc.isSrt ? {
        type:'srt', text: doc.text||'', cues: Array.isArray(doc.cues)?doc.cues:[],
        srtTranslations: Array.isArray(doc.srtTranslations)?doc.srtTranslations:[],
        output: doc.output||''
      } : { type:'text', text: doc.text||'', output: doc.output||'' };
      try{ sessionStorage.setItem(payloadKey, JSON.stringify(payload)); }catch{}
      return {
        id, payloadKey,
        ts: Date.now(),
        docId: doc.id,
        name: doc.name||'Untitled',
        ext: doc.ext||'txt',
        isSrt: !!doc.isSrt,
        mode: selectedMode, subStyle: selectedSubStyle,
        targetLanguage, rephrase,
        srcChars: (doc.isSrt ? (doc.text || (doc.cues||[]).map(c=>c.text).join('\n') || '').length : (doc.text||'').length),
        outChars: (doc.output||'').length
      };
    }
    function recallHistory(index){
      const items = readHistory();
      const meta = items[Number(index)];
      if(!meta){ return; }
      const key = meta.payloadKey || ('HIST_PAYLOAD:'+ (meta.id||''));
      let payload = null; try{ payload = JSON.parse(sessionStorage.getItem(key)||'null'); }catch{}
      if(!payload){
        showToast('This history is from a previous session. Content not stored.');
        // Still set UI selections for convenience
        selectedMode = meta.mode||selectedMode; selectedSubStyle = meta.subStyle||''; targetLanguage = meta.targetLanguage||targetLanguage; rephrase = !!meta.rephrase;
        buildStyleButtons(); if(selectedSubStyle) setSubStyle(selectedSubStyle); buildLangButtons();
        return;
      }
      // Restore UI selections
      selectedMode = meta.mode||selectedMode; selectedSubStyle = meta.subStyle||''; targetLanguage = meta.targetLanguage||targetLanguage; rephrase = !!meta.rephrase;
      buildStyleButtons(); if(selectedSubStyle) setSubStyle(selectedSubStyle); buildLangButtons();

      // Find existing doc, else create
      let doc = docs.find(d=>d.id===meta.docId);
      const createdNew = !doc;
      if(!doc){
        doc = {
          id:'d'+Date.now()+Math.random().toString(36).slice(2),
          name: meta.name||'Untitled', ext: meta.ext||'txt', size:0, mime:'',
          text:'', cues:[], srtTranslations:[], lastAlignedTgt:[], output:'', isSrt: !!(payload.type==='srt' || meta.isSrt)
        };
        docs.push(doc);
      }
      // Restore snapshot
      if(payload.type==='srt' || doc.isSrt){
        doc.isSrt = true;
        doc.text = payload.text||'';
        doc.cues = Array.isArray(payload.cues)?payload.cues:[];
        doc.srtTranslations = Array.isArray(payload.srtTranslations)?payload.srtTranslations:[];
        doc.output = payload.output || (doc.srtTranslations||[]).join('\n');
      }else{
        doc.isSrt = false;
        doc.text = payload.text||'';
        doc.output = payload.output||'';
      }
      // Activate tab and render
      activeId = doc.id;
      renderTabs();
      loadDocToUI(doc);
      if(splitView){ if(doc.isSrt) renderSrtBoxes(doc); else renderSegmentBoxes(doc); }
      // Flash highlight
      const ot=$('#outputText'); if(ot){ ot.classList.add('field-pulse'); setTimeout(()=>ot.classList.remove('field-pulse'),900); }
      closeHistoryModal();
      // If we created a new tab, ensure submit all visibility
      maybeShowSubmitAll();
    }
    function ensureHistoryOverlay(){
      if(document.getElementById('histOverlay')) return;
      ensureHistoryStyles();
      const wrap=document.createElement('div');
      wrap.id='histOverlay';
      wrap.className='lang-overlay';
      wrap.setAttribute('role','dialog');
      wrap.setAttribute('aria-modal','true');
      wrap.setAttribute('aria-hidden','true');
      wrap.innerHTML=`
        <div class="lang-sheet" role="document">
          <div class="lang-head">
            <div class="lang-title">Recent runs</div>
            <div style="display:flex;gap:8px">
              <button class="lang-close" id="histClearBtn" title="Clear history"><span>Clear history</span></button>
              <button class="lang-close" id="histCloseBtn" aria-label="Close">âœ•</button>
            </div>
          </div>
          <div class="lang-grid" id="histGrid"></div>
        </div>`;
      document.body.appendChild(wrap);
      document.getElementById('histCloseBtn').addEventListener('click',closeHistoryModal);
      document.getElementById('histClearBtn').addEventListener('click',()=>{localStorage.removeItem(HISTORY_KEY);renderHistoryGrid();});
    }
    function ensureHistoryStyles(){
      if(document.getElementById('histOverlayStyles')) return;
      const css = `
        #histOverlay .lang-grid { grid-template-columns: 1fr; max-height: min(60vh, 560px); overflow: auto; }
        #histOverlay .lang-item { 
          display:flex; flex-direction:column; align-items:flex-start; gap:6px; 
          padding:16px 18px; font-size:15px; line-height:1.5; cursor:pointer; 
          transition:all .18s var(--ease); border-radius:8px; margin:2px 4px;
        }
        #histOverlay .lang-item:hover { 
          background:var(--accent-weak); 
          border-color:var(--accent);
          color:var(--accent);
          transform:translateX(3px);
          box-shadow:0 2px 8px rgba(0,122,255,.12);
        }
        #histOverlay .lang-item .lang-code { opacity:.78; font-size:13px; transition:opacity .18s var(--ease); }
        #histOverlay .lang-item:hover .lang-code { opacity:1; }
        #histOverlay .lang-close#histClearBtn { font-weight:500; padding:6px 12px; border-radius:10px; }
      `;
      const style = document.createElement('style');
      style.id = 'histOverlayStyles';
      style.textContent = css;
      document.head.appendChild(style);
    }
    function renderHistoryGrid(){
      const grid=$('#histGrid'); if(!grid) return;
      let items=readHistory();
      if(!items.length){
        grid.innerHTML=`<div class="lang-item"><div>No history yet</div><div class="lang-code">â€”</div></div>`;
        return;
      }
      
      // Determine per-session dominant source language (cluster by createdAt within 2 minutes)
      const WINDOW = 2 * 60 * 1000; // 2 minutes
      const sorted = (items||[]).slice().sort((a,b)=> (a.createdAt||0) - (b.createdAt||0));
      const groups = [];
      let cur = [];
      let prevTs = null;
      for(const it of sorted){
        const ts = Number(it.createdAt||0);
        if(prevTs!==null && (ts - prevTs) > WINDOW){ groups.push(cur); cur = []; }
        cur.push(it); prevTs = ts;
      }
      if(cur.length) groups.push(cur);

      const dominantById = {};
      for(const g of groups){
        const counts = {};
        for(const it of g){
          const base = (it.srcLang && it.srcLang !== 'Auto') ? it.srcLang : detectLanguageName(it.srcText||'');
          const key = base || 'Auto'; counts[key] = (counts[key]||0) + 1;
        }
        const dominant = Object.entries(counts).sort((a,b)=> b[1]-a[1])[0]?.[0] || 'Auto';
        for(const it of g){ dominantById[String(it.id)] = (dominant === 'Auto' ? '' : dominant); }
      }

      items = items.map(it=>{
        const explicit = (it.srcLang && it.srcLang!=='Auto') ? it.srcLang : '';
        const guess = detectLanguageName(it.srcText||'');
        const dom = dominantById[String(it.id)] || '';
        const lang = explicit || guess || dom || 'Auto';
        return { ...it, srcLang: lang };
      });
      
      grid.innerHTML = items.map((h,i)=>{
        const d=new Date(h.ts);
        const meta = [
          `${h.mode}/${h.subStyle||'general'}`,
          h.rephrase ? 'rephrase' : (h.targetLanguage||''),
          `${h.srcChars}â†’${h.outChars}`,
          h.fileName? h.fileName : null
        ].filter(Boolean).join(' Â· ');
        return `<div class="lang-item" data-index="${i}" role="button" tabindex="0" aria-label="Recall ${escapeHTML(meta)}">
                  <div>${escapeHTML(d.toLocaleString())}</div>
                  <div class="lang-code">${escapeHTML(meta)}</div>
                </div>`;
      }).join('');
      // Wire recall interaction
      grid.querySelectorAll('.lang-item[data-index]').forEach(it=>{
        it.addEventListener('click',()=>{ const idx=Number(it.getAttribute('data-index')); recallHistory(idx); });
        it.addEventListener('keydown',e=>{ if(e.key==='Enter'||e.key===' ') { e.preventDefault(); const idx=Number(it.getAttribute('data-index')); recallHistory(idx); } });
      });
    }
    function openHistoryModal(){ensureHistoryOverlay();renderHistoryGrid();const ov=$('#histOverlay'); if(!ov) return; ov.classList.add('show'); ov.setAttribute('aria-hidden','false'); ov._onKey=e=>{if(e.key==='Escape')closeHistoryModal()}; ov._onClick=e=>{if(e.target.id==='histOverlay')closeHistoryModal()}; document.addEventListener('keydown',ov._onKey); ov.addEventListener('click',ov._onClick);}
    function closeHistoryModal(){const ov=$('#histOverlay'); if(!ov) return; ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',ov._onKey||(()=>{})); ov.removeEventListener('click',ov._onClick||(()=>{}));}

    /* ---------------- Dropzone & file handling ---------------- */
    function initDropzone(){
      const dz=$('#dropzone'), input=$('#fileInput');
      const onOver=e=>{e.preventDefault();dz.classList.add('drag')};
      const onLeave=e=>{e.preventDefault();dz.classList.remove('drag')};
      const onDrop=e=>{
        e.preventDefault(); dz.classList.remove('drag');
        const files=Array.from(e.dataTransfer.files||[]); if(files.length) handleFiles(files);
      };
      dz.addEventListener('dragover',onOver);
      dz.addEventListener('dragleave',onLeave);
      dz.addEventListener('drop',onDrop);
      input.addEventListener('change',e=>{const files=Array.from(e.target.files||[]); if(files.length) handleFiles(files)});
      $('#clearFile')?.addEventListener('click',()=>{ if(currentDoc()) closeDoc(currentDoc().id) });
    }
    function setBadge(meta){
      $('#fileMeta').innerHTML = `<b>${escapeHTML(meta.name)}</b> Â· ${escapeHTML((meta.ext||'').toUpperCase())} Â· ${Math.round((meta.size||0)/1024)} KB`;
      $('#fileBadgeWrap').classList.add('is-hidden'); // tabs supersede it
    }
    // Track active uploads to prevent duplicates
    let uploadInProgress = false;
    const uploadedFiles = new Set(); // Track uploaded file names
    
    async function handleFiles(files){
      if (uploadInProgress) {
        console.log('Upload already in progress, ignoring duplicate request');
        return;
      }
      
      // Check tier restrictions for multiple files
      const user = JSON.parse(localStorage.getItem('user') || '{}');
      const isGuest = user.isGuest === true;
      const tier = user.tier || 'free';
      
      console.log('ðŸ” File upload tier check:', { user, isGuest, tier, filesCount: files.length });
      
      if ((isGuest || tier === 'free') && files.length > 1) {
        console.log('âŒ Multiple file upload blocked for tier:', tier);
        showToast('Multiple file uploads require Pro or Business tier. Sign in to upgrade!');
        return;
      }
      
      uploadInProgress = true;
      console.log('ðŸš€ Starting file upload process');
      showStatus('Preparing uploadâ€¦');
      
      // Filter out already uploaded files
      const newFiles = files.filter(file => {
        const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
        if (uploadedFiles.has(fileKey)) {
          console.log(`Skipping duplicate file: ${file.name}`);
          return false;
        }
        uploadedFiles.add(fileKey);
        return true;
      });
      
      if (newFiles.length === 0) {
        uploadInProgress = false;
        hideUploadProgress();
        return;
      }
      
      console.log(`ðŸ“ Processing ${newFiles.length} new files...`);
      
      // No popup notifications; status tab is the single source of truth
      setStatus(`Uploadingâ€¦ 0/${newFiles.length}`);
      
      const results = [];
      let successCount = 0;
      let errorCount = 0;
      
      try{
        for(const [index, file] of newFiles.entries()){
          console.log(`ðŸ“„ Starting upload ${index + 1}/${newFiles.length}: ${file.name}`);
          
          // Update progress with file name for better feedback
          updateUploadProgress(index, newFiles.length, file.name);
          setStatus(`Uploading ${file.name}â€¦ ${index}/${newFiles.length}`);
          
          // Show processing message for large files
          if (file.size > 5 * 1024 * 1024) { // > 5MB
            setUploadProgressText(`Processing large file: ${file.name}...`);
          }
          // Yield to main thread to prevent UI freezing
          await new Promise(resolve => setTimeout(resolve, 50));
          
          try {
            const fd=new FormData(); fd.append('file',file);
            
            // Add authentication token if available
            const headers = {};
            const token = localStorage.getItem('authToken');
            const guestId = localStorage.getItem('guestId');
            
            if (token) {
              headers['Authorization'] = `Bearer ${token}`;
            } else if (guestId) {
              headers['X-Guest-ID'] = guestId;
            }
            
            // Show upload in progress
            setStatus(`Uploading ${file.name}â€¦`);
            
            const res=await fetch('/api/upload',{
              method:'POST',
              headers: headers,
              body:fd
            });
            
            if(!res.ok) {
              const errorData = await res.json().catch(() => ({}));
              throw new Error(errorData.error || `Upload failed with status ${res.status}`);
            }
            
            // Show processing message
            setStatus(`Processing ${file.name}â€¦`);
            
            // Yield to main thread during JSON parsing for large responses
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const data=await res.json();
            console.log(`ðŸ“„ Server response received for ${file.name}`);
            
            // Yield before heavy processing
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const f=data.file||{};
            const ext=((f.ext||data.ext||file.name.split('.').pop()||'txt')||'').replace(/^\./,'').toLowerCase();
            const parsed={
              originalName: f.originalName || data.name || file.name,
              size: f.size || data.size || file.size,
              mime: f.mime || data.mime || file.type,
              text: data.text || '',
              cues: Array.isArray(data.cues)?data.cues:[],
              ext
            };
            // Show completion message
            setStatus(`Finalizing ${file.name}â€¦`);
            
            // Yield to main thread during DOM operations - this is the critical part
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Process DOM operations in chunks to prevent freezing
            await processFileInChunks(parsed);
            
            results.push({ file: parsed, success: true });
            successCount++;
            
            console.log(`âœ… File processed: ${parsed.originalName}`);
            
            // Update character count after file processing
            setTimeout(() => {
              if (window.updateCharacterCount) {
                window.updateCharacterCount();
              }
            }, 150);
            
          } catch (fileError) {
            console.error(`âŒ Failed to upload ${file.name}:`, fileError);
            results.push({ file: { originalName: file.name }, success: false, error: fileError.message });
            errorCount++;
          }
          // Yield between files
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Final progress update
        updateUploadProgress(newFiles.length, newFiles.length);
        setStatus('Upload complete');
        
        // End state summary via status tab only
        if (errorCount === 0) setStatus('Upload complete');
        else if (successCount === 0) setStatus('Upload failed');
        else setStatus(`Upload complete â€¢ ${successCount} succeeded, ${errorCount} failed`);
        
      }catch(e){ 
        console.error('File upload error:', e); 
        setStatus('Upload failed');
      }
      finally{
        uploadInProgress = false;
        hideStatus();
        
        // Clear uploaded files tracking after delay (allow for duplicate detection)
        setTimeout(() => {
          uploadedFiles.clear();
        }, 5000);
      }
    }

    /* ---------- Substyles ---------- */
    function renderSubstyles(modeId){
      const subs=(STYLE_DEF[modeId]||{subs:[]}).subs;
      const title=$('#substyleTitle'); if(title){ title.textContent = subs.length ? (t('substyle_for')+' '+styleLabel(modeId)) : t('substyle'); }
      const wrap=$('#chipsWrap'); if(!wrap) return;

      let chips=`<button class="chip active" data-val="" type="button" title="${escapeHTML(t('no_substyle'))}" aria-label="${escapeHTML(t('no_substyle'))}">${t('no_substyle')}</button>`;
      subs.forEach(id=>{
        const label=subLabel(id);
        const tip=microcopyText(modeId,id);
        const aria=tip?`${label}: ${tip}`:label;
        chips+=`<button class="chip" data-val="${id}" type="button" title="${escapeHTML(tip||label)}" aria-label="${escapeHTML(aria)}">${label}</button>`;
      });
      wrap.innerHTML=chips;
      $$('.chip').forEach(ch=>ch.addEventListener('click',()=>setSubStyle(ch.dataset.val)));
      selectedSubStyle="";

      const panel=$('#subStylePanel');
      if(panel && !$('#substyleNote')){
        const note=document.createElement('div');
        note.id='substyleNote'; note.className='substyle-note'; note.setAttribute('aria-live','polite');
        panel.appendChild(note);
      }
      updateSubstyleNote();
    }
    function toggleSubstylePanel(){const panel=$('#subStylePanel');const open=panel&&!panel.classList.contains('open');panel?.classList.toggle('open',open);setChevron(!!open)}
    function setChevron(open){const chev=$('#substyleChevron');if(chev){chev.classList.toggle('up',open);chev.textContent='â–¾'}}

    function updateSubstyleNote(){
      const el=$('#substyleNote'); if(!el) return;
      const sel=selectedSubStyle||'';
      const canon=resolveAlias(selectedMode, sel);
      const text=(sel && canon.subStyle)?microcopyText(canon.mode, canon.subStyle):'';
      const label=sel?`${subLabel(canon.subStyle)}:`:'';
      if(text && sel){el.innerHTML=`<b>${escapeHTML(label)}</b> ${escapeHTML(text)}`; el.classList.add('show');}
      else{el.textContent=''; el.classList.remove('show');}
      adjustWrapHeight();
    }
    function setSubStyle(val){
      selectedSubStyle=(selectedSubStyle===val)?"":val;
      clearChipSelection();
      const sel=selectedSubStyle===""?'.chip[data-val=""]':`.chip[data-val="${selectedSubStyle}"]`;
      $$(sel).forEach(el=>el.classList.add('active'));
      updateSubstyleNote();
      adjustWrapHeight();
    }
    function clearChipSelection(){$$('.chip').forEach(el=>el.classList.remove('active'))}

    /* ---------- Global sentence splitter helpers ---------- */
    function splitGlobal(text){
      if(!text) return [];
      let chunks=[];
      try{
        const seg = new Intl.Segmenter('und',{granularity:'sentence'});
        chunks = Array.from(seg.segment(text)).map(s=>s.segment);
      }catch{
        const rx=/[^.!?â€¦ã€‚ï¼ï¼Ÿ]+(?:\.\.\.|[.!?â€¦ã€‚ï¼ï¼Ÿ])*/g;
        chunks = (String(text).match(rx)||[]);
      }
      return chunks.map(s=>s.trim()).filter(Boolean);
    }
    function endsWithEllipsis(s){ return /\.\.\.$|â€¦$/.test((s||'').trim()); }
    function isInterjection(s){
      const x=(s||'').trim();
      if(/^(ah|oh|uh|um|erm?|eh|hmm|huh|well|hey|yo|oi|aduh|waduh|yah|ya|loh|lah|nah|duh|whoa|wow|alas|sob|hiks|uy|ehh|bah|euh|oula|hala)[.!?â€¦]*$/i.test(x)) return true;
      if(/^[å•Šå‘€å“Žå”‰å—¯å‘ƒå””å“¦å™¢å“‡å˜¿å™—å—¨æ¬¸ã€œï½žâ€¦ï¼]*$/.test(x)) return true;
      return false;
    }
    function wordCount(s){return (String(s).trim().match(/[^\s]+/g)||[]).length}
    function charCount(s){return (String(s)||'').replace(/\s/g,'').length}
    function shouldMerge(prev,next){
      const a=(prev||'').trim(),b=(next||'').trim(); if(!a||!b) return false;
      if(isInterjection(a)) return true;
      const trailing=/(?:\.\.\.|\.|â€¦|ã€‚|ï¼|ï¼Ÿ|!|\?)\s*$/.test(a);
      const shortWords = wordCount(a)<=3;
      const shortChars = charCount(a)<=12;
      if(trailing && (shortWords || shortChars)) return true;
      if(endsWithEllipsis(a)) return true;
      return false;
    }
    function normalizeBookText(text){
      let s = String(text || '');
      // Remove soft hyphen character
      s = s.replace(/\u00AD/g, '');
      // Join hyphenated line breaks: word-\nword -> wordword
      s = s.replace(/([A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿])\-\s*\n\s*([A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿])/g, '$1$2');
      // Join single in-paragraph newlines to spaces (keep paragraph breaks as double newlines)
      s = s.replace(/([^\n])\n(?!\n)/g, '$1 ');
      // Normalize excessive blank lines
      s = s.replace(/\n{3,}/g, '\n\n');
      return s;
    }
    function segmentText(text){
      const raw = splitGlobal(normalizeBookText(text));
      if(!raw.length) return [];
      const healed = [];
      for(const cur of raw){
        const last = healed[healed.length-1];
        if(last && shouldMerge(last, cur)){
          healed[healed.length-1] = (last + ' ' + cur).replace(/\s+/g,' ').trim();
        }else{
          healed.push(cur.trim());
        }
      }
      const joined = [];
      for(const cur of healed){
        const prev = joined[joined.length-1];
        if(prev && /[,;:]$/.test(prev) && /^[""'']/.test(cur)){
          joined[joined.length-1] = (prev + ' ' + cur).replace(/\s+/g,' ').trim();
        }else{
          joined.push(cur);
        }
      }
      return joined;
    }
    function pickSplitPoint(s){
      const str = String(s);
      if(str.length < 24) return -1;
      const halfway = Math.floor(str.length * 0.45);
      const candidates = /[.!?ã€‚ï¼ï¼Ÿâ€¦]+/g;
      let m, best=-1;
      while((m=candidates.exec(str))){
        const i = candidates.lastIndex;
        if(i >= halfway){ best = i; break; }
      }
      if(best>0) return best;
      const commas = /[,;ã€ï¼ŒØ›]/g;
      while((m=commas.exec(str))){
        const i = commas.lastIndex;
        if(i >= halfway){ best = i; break; }
      }
      if(best>0) return best;
      const space = str.indexOf(' ', Math.max(halfway, 8));
      return space>0 ? space : -1;
    }
    function alignToSource(targetText, src){
      const srcCount = Array.isArray(src) ? src.length : Number(src)||0;
      const srcLens = Array.isArray(src) ? src.map(s=>charCount(s||'')).filter(n=>n>0).sort((a,b)=>a-b) : [];
      const medianSrcLen = srcLens.length ? srcLens[Math.floor(srcLens.length/2)] : 60;

      let segs = segmentText(targetText).slice();

      // Phase A: if too few target segments, split longest first
      let guard = 0;
      while(segs.length < srcCount && guard++ < 200){
        // choose the longest segment above 0.8 * median source length
        let li = -1, longest = 0;
        for(let i=0;i<segs.length;i++){
          const len = charCount(segs[i]);
          if(len > longest){ longest = len; li = i; }
        }
        if(longest < Math.max(20, Math.floor(medianSrcLen*0.8))) break;
        const cut = pickSplitPoint(segs[li]);
        if(cut>0){
          const a = segs[li].slice(0,cut).trim();
          const b = segs[li].slice(cut).trim();
          segs.splice(li,1,a,b);
        } else {
          break;
        }
      }

      // Phase B: if too many target segments, merge only short ones
      guard = 0;
      while(segs.length > srcCount && guard++ < 200){
        let idx = -1; let shortest = Infinity;
        for(let i=0;i<segs.length;i++){
          const len = charCount(segs[i]);
          if(len < shortest){ shortest = len; idx = i; }
        }
        // Merge a very short/micro segment into neighbor, favor previous
        if(idx <= 0) idx = 1;
        if(shortest > Math.max(15, Math.floor(medianSrcLen*0.35))) {
          // if nothing qualifies as short, merge the smallest anyway
        }
        segs[idx-1] = (segs[idx-1] + ' ' + segs[idx]).replace(/\s+/g,' ').trim();
        segs.splice(idx,1);
      }

      // Phase C: equalize count exactly (no blanks)
      if(segs.length < srcCount){
        // best-effort split again using any possible cut
        guard = 0;
        while(segs.length < srcCount && guard++ < 200){
          let li = -1, longest = 0;
          for(let i=0;i<segs.length;i++){
            const len = charCount(segs[i]);
            if(len > longest){ longest = len; li = i; }
          }
          const cut = pickSplitPoint(segs[li]);
          if(cut>0){
            const a = segs[li].slice(0,cut).trim();
            const b = segs[li].slice(cut).trim();
            segs.splice(li,1,a,b);
          } else {
            // replicate smallest neighbor to avoid creating empty trailing blanks
            segs.splice(li+1,0,segs[li].slice(0, Math.min(20, segs[li].length)).trim());
          }
        }
      }

      // Trim any residual overage conservatively
      while(segs.length > srcCount){
        segs.splice(segs.length-2,1, (segs[segs.length-2] + ' ' + segs[segs.length-1]).replace(/\s+/g,' ').trim());
        segs.pop();
      }

      return segs;
    }
    function buildRowHTML(text, idx, isTarget = false){
      const s = String(text || '');
      const words = (s.trim().match(/[^\s]+/g) || []).length;
      const chars = s.replace(/\s/g,'').length;
      
      if (isTarget) {
        // Use textarea for target segments to avoid contenteditable issues
        return `
          <div class="segrow" data-idx="${idx}">
            <div class="lineno">${idx+1}</div>
            <div class="segcontent">
              <textarea class="segtext-textarea" data-idx="${idx}" rows="2">${escapeHTML(s)}</textarea>
              <div class="segmeta">${words} words Â· ${chars} chars</div>
            </div>
          </div>`;
      } else {
        return `
          <div class="segrow" data-idx="${idx}">
            <div class="lineno">${idx+1}</div>
            <div class="segcontent">
              <div class="segtext">${escapeHTML(s)}</div>
              <div class="segmeta">${words} words Â· ${chars} chars</div>
            </div>
          </div>`;
      }
    }
    /** Wire textarea editors for target segments */
    function wireSegmentEditors(){
      const d = currentDoc(); if(!d) return;
      const textareas = Array.from(document.querySelectorAll('#segTgtBox .segtext-textarea'));
      if (!Array.isArray(d.lastAlignedTgt) || d.lastAlignedTgt.length !== textareas.length) {
        // Initialize target cache from current DOM
        d.lastAlignedTgt = textareas.map(ta => ta.value || '');
        d.output = d.lastAlignedTgt.join('\n');
      }

      textareas.forEach(textarea => {
        const idx = Number(textarea.getAttribute('data-idx')||'0');
        const row = textarea.closest('.segrow');
        const metaEl = row?.querySelector('.segmeta');
        
        // Auto-resize textarea (robust for long content & font reflow)
        const autoResize = () => {
          textarea.style.height = 'auto';
          textarea.style.overflowY = 'hidden';
          const h = Math.max(40, textarea.scrollHeight);
          textarea.style.height = h + 'px';
        };

        // Initial grow and after paint (handles long initial values)
        autoResize();
        requestAnimationFrame(autoResize);
        setTimeout(autoResize, 50);

        const onEdit = () => {
          const val = textarea.value || '';
          d.lastAlignedTgt[idx] = val;
          d.output = d.lastAlignedTgt.join('\n');
          
          // Update word/char count
          if (metaEl){
            const w = (val.trim().match(/[^\s]+/g) || []).length;
            const c = val.replace(/\s/g,'').length;
            metaEl.textContent = `${w} words Â· ${c} chars`;
          }
          
          autoResize();
          // Keep paired rows height-aligned while typing
          try { equalizeRowHeightsAtIndex(idx); } catch {}
          try { adjustWrapHeight(); } catch {}
        };

        // Resize on all common input-style events
        ;['input','change','cut','paste','drop','keydown'].forEach(ev=>{
          textarea.addEventListener(ev, onEdit, { passive: true });
        });
      });
    }
    function renderSegmentBoxes(doc){
      const d = doc || currentDoc(); if(!d) return;
      if(d.isSrt){ renderSrtBoxes(d); return; }

      const srcSegs=segmentText(d.text||'');
      const nSrc = srcSegs.length;

      let tgtSegs;
      if(Array.isArray(d.lastAlignedTgt) && d.lastAlignedTgt.length === nSrc){
        tgtSegs = d.lastAlignedTgt.slice();
      }else{
        const tgtVal = d.output || '';
        tgtSegs = alignToSource(tgtVal, srcSegs);
      }

      const n=Math.max(srcSegs.length,tgtSegs.length);
      const src=$('#segSrcBox'),tgt=$('#segTgtBox'); if(!src||!tgt) return;
      const savedSrc=src.scrollTop, savedTgt=tgt.scrollTop;
      src.innerHTML=''; tgt.innerHTML='';
      for(let i=0;i<n;i++){
        src.insertAdjacentHTML('beforeend',buildRowHTML(srcSegs[i]||'',i, false));
        tgt.insertAdjacentHTML('beforeend',buildRowHTML(tgtSegs[i]||'',i, true));
      }
      wireSegmentEditors();
      equalizeRowHeights(); syncScroll(src,tgt); adjustWrapHeight();
      applyContentDirection();
      // Restore scroll positions to avoid anchoring shifts on re-render
      src.scrollTop=savedSrc; tgt.scrollTop=savedTgt;
    }
    function equalizeRowHeights(){
      const srcRows=$('#segSrcBox')?$('#segSrcBox').querySelectorAll('.segrow'):[];
      const tgtRows=$('#segTgtBox')?$('#segTgtBox').querySelectorAll('.segrow'):[];
      const n=Math.max(srcRows.length,tgtRows.length);
      for(let i=0;i<n;i++){
        equalizeRowHeightsAtIndex(i, srcRows[i], tgtRows[i]);
      }
    }
    function equalizeRowHeightsAtIndex(i, aEl, bEl){
      const a = aEl || document.querySelector(`#segSrcBox .segrow[data-idx="${i}"]`);
      const b = bEl || document.querySelector(`#segTgtBox .segrow[data-idx="${i}"]`);
      if(!a||!b) return;
      // Reset constraints for these two rows only
      a.style.minHeight='unset'; b.style.minHeight='unset';
      a.style.height='auto';     b.style.height='auto';
      a.style.width='auto';      b.style.width='auto';
      a.style.maxHeight='none';  b.style.maxHeight='none';

      const aContent = a.querySelector('.segcontent');
      const bContent = b.querySelector('.segcontent');
      const aText = a.querySelector('.segtext');
      const bText = b.querySelector('.segtext');
      if (aContent){aContent.style.width='100%';aContent.style.height='auto';aContent.style.overflow='visible';aContent.style.minHeight='auto'}
      if (bContent){bContent.style.width='100%';bContent.style.height='auto';bContent.style.overflow='visible';bContent.style.minHeight='auto'}
      if (aText){aText.style.width='100%';aText.style.height='auto';aText.style.overflow='visible';aText.style.maxHeight='none'}
      if (bText){bText.style.width='100%';bText.style.height='auto';bText.style.overflow='visible';bText.style.maxHeight='none'}
      // Force layout calc for these rows only
      a.offsetHeight; b.offsetHeight;
      const ha = a.offsetHeight, hb = b.offsetHeight;
      const h = Math.max(ha, hb);
      // Only raise the shorter row to avoid reflow on both panes
      if(ha < h) a.style.minHeight = h+'px';
      if(hb < h) b.style.minHeight = h+'px';
    }
    function syncScroll(a,b){
      if(!a||!b||a._syncPartner===b) return;
      a._syncPartner=b; b._syncPartner=a;
      let lock=false;
      let isTyping=false;
      
      // Disable scroll sync while typing
      document.addEventListener('input',(e)=>{
        if(e.target.matches('#segTgtBox .segtext[contenteditable="true"]')){
          isTyping=true;
          clearTimeout(window._typingTimeout);
          window._typingTimeout=setTimeout(()=>isTyping=false,200);
        }
      });
      
      a.addEventListener('scroll',()=>{ if(lock||isTyping) return; lock=true; b.scrollTop=a.scrollTop; lock=false; },{passive:true});
      b.addEventListener('scroll',()=>{ if(lock||isTyping) return; lock=true; a.scrollTop=b.scrollTop; lock=false; },{passive:true});
    }
    function debounce(fn,ms){let t;return()=>{clearTimeout(t);t=setTimeout(fn,ms)}}
    /* (removed Edit Mode code) */

    function renderSrtBoxes(doc){
      const d=doc||currentDoc(); if(!d) return;
      const src=$('#segSrcBox'),tgt=$('#segTgtBox'); if(!src||!tgt) return;
      const cues = d.cues||[];
      src.innerHTML=''; tgt.innerHTML='';
      const useCues = cues.length>0 ? cues : ( (d.text||'').split(/\r?\n/).map(txt=>({text:txt,start:'',end:''})) );
      for(let i=0;i<useCues.length;i++){
        const c=useCues[i];
        const srcWords = wordCount(c.text||''); const srcChars = charCount(c.text||'');
        const srcHTML = `<div class="segrow" data-idx="${i}">
            <div class="lineno">${i+1}</div>
            <div class="segcontent">
              <div class="segtext">${escapeHTML(c.text||'')}</div>
              <div class="segmeta">${escapeHTML(c.start||'')} ${c.start||c.end ? 'â†’' : 'â€”'} ${escapeHTML(c.end||'')} Â· ${srcWords} words Â· ${srcChars} chars</div>
            </div>
          </div>`;
        // Normalize any HTML line breaks from upstream to real newlines so textarea grows correctly
        const tgtVal = (d.srtTranslations[i]||'').replace(/<br\s*\/?>(?=\s*|$)/gi,'\n');
        const tgtWords = wordCount(tgtVal); const tgtChars = charCount(tgtVal);
        const tgtHTML = `<div class="segrow" data-idx="${i}">
            <div class="lineno">${i+1}</div>
            <div class="segcontent">
              <textarea data-srt="${i}">${escapeHTML(tgtVal)}</textarea>
              <div class="segmeta" id="tmeta-${i}">${escapeHTML(c.start||'')} ${c.start||c.end?'â†’':'â€”'} ${escapeHTML(c.end||'')} Â· ${tgtWords} words Â· ${tgtChars} chars</div>
            </div>
          </div>`;
        src.insertAdjacentHTML('beforeend',srcHTML);
        tgt.insertAdjacentHTML('beforeend',tgtHTML);
      }
      $$('textarea[data-srt]').forEach(el=>{
        // Grow to fit content including explicit <br> from cues
        const autoGrow = (ta)=>{
          ta.style.height = 'auto';
          ta.style.overflowY = 'hidden';
          const h = Math.max(44, ta.scrollHeight);
          ta.style.height = h + 'px';
        };
        autoGrow(el);
        el.addEventListener('input',e=>{
          const idx=Number(e.target.getAttribute('data-srt'));
          d.srtTranslations[idx]=e.target.value;
          d.output = (d.srtTranslations||[]).join('\n');
          $('#outputText').value = d.output;
          const c = useCues[idx]||{};
          const w = wordCount(e.target.value), ch = charCount(e.target.value);
          const meta = $(`#tmeta-${idx}`); if(meta) meta.textContent = `${(c.start||'')} ${c.start||c.end?'â†’':'â€”'} ${(c.end||'')} Â· ${w} words Â· ${ch} chars`;
          autoGrow(e.target);
          equalizeRowHeights();
          updateSplitButton();
        });
        // Regrow on initial paint and when fonts load
        setTimeout(()=>autoGrow(el),50);
        window.addEventListener('resize',()=>autoGrow(el));
      });
      $('#outputText').value = d.output || (d.srtTranslations||[]).join('\n');
      autosizeTextarea($('#outputText'));
      equalizeRowHeights(); syncScroll(src,tgt); adjustWrapHeight();
      applyContentDirection();
      // Final pass: ensure every textarea height matches its scrollHeight
      requestAnimationFrame(()=>{
        $$('textarea[data-srt]').forEach(ta=>{
          ta.style.height='auto';
          ta.style.overflowY='hidden';
          ta.style.height=Math.max(44, ta.scrollHeight)+'px';
        });
        equalizeRowHeights();
      });
    }

    // Capture inline edits in split view target segments (non-SRT)
    function wireSplitEditHandlers(){
      try{
        document.querySelectorAll('#segTgtBox .segrow .segtext[contenteditable="true"]').forEach((el,idx)=>{
          if(el._wiredEdit) return; el._wiredEdit=true;
          const onInput=()=>{
            const doc=currentDoc(); if(!doc) return;
            const val=(el.textContent||'').replace(/\r/g,'');
            if(!Array.isArray(doc.lastAlignedTgt)) doc.lastAlignedTgt=[];
            doc.lastAlignedTgt[idx]=val;
            doc.output = (doc.lastAlignedTgt||[]).join('\n');
            const out=$('#outputText'); if(out){ out.value=doc.output; autosizeTextarea(out); }
          };
          el.addEventListener('input', onInput);
          el.addEventListener('blur', onInput);
        });
      }catch{}
    }

    /* ---------- Load/Save doc <-> UI ---------- */
    function loadDocToUI(doc){
      if(!doc) return;
      // Input
      $('#inputText').value = doc.text || '';
      autosizeTextarea($('#inputText'));
      // Update character count when loading new document
      setTimeout(() => {
        if (window.updateCharacterCount) {
          window.updateCharacterCount();
        }
      }, 10);
      // Output
      if(doc.isSrt){
        $('#outputRich').classList.add('is-hidden');
        $('#outputText').classList.remove('is-hidden');
        $('#outputText').value = (doc.srtTranslations||[]).join('\n');
        autosizeTextarea($('#outputText'));
      }else{
        $('#outputText').classList.add('is-hidden');
        $('#outputRich').classList.remove('is-hidden');
        $('#outputRich').textContent = doc.output || '';
        syncRichToHidden();
      }
      // Split view state
      if(splitView){ if(doc.isSrt) renderSrtBoxes(doc); else { renderSegmentBoxes(doc); wireSplitEditHandlers(); } }
      closeAllExportMenus();
      updateSplitButton();
      adjustWrapHeight();
      renderTabs();
      // Ensure content alignment is evaluated for the newly loaded document
      try{ applyContentDirection(); }catch{}
    }

    function syncRichToHidden(){
      const d=currentDoc(); if(!d) return;
      let val = $('#outputRich').textContent || '';
      let hidden = $('#outputText');
      if(hidden){ hidden.value = val; autosizeTextarea(hidden); }
    }

    /* ---------- Actions (translate / download) ---------- */
    function selectTarget(lang){if(targetLanguage===lang){targetLanguage=''; $$('.lang-btn').forEach(b=>{if(b.dataset.lang===lang)b.classList.remove('active')})}else{targetLanguage=lang; rephrase=false; $('#btnRephrase')?.classList.remove('active'); $$('.lang-btn').forEach(b=>b.classList.toggle('active',b.dataset.lang===lang))} adjustWrapHeight(); applyContentDirection()}
    function toggleRephrase(){rephrase=!rephrase; $('#btnRephrase')?.classList.toggle('active',rephrase); if(rephrase){targetLanguage=''; $$('.lang-btn').forEach(b=>b.classList.remove('active'))} adjustWrapHeight(); applyContentDirection()}

    // --- Max Localization toggle (Team-only) + hints ---
    function updateSubmitHints(){
      const hints = document.getElementById('submitHints'); if(!hints) return;
      const user = JSON.parse(localStorage.getItem('user')||'{}');
      const tierNow = String(user?.tier||'free').toLowerCase();
      const brandOn = readJSON('brandEnabled:v1', false)===true;
      // Check actual glossary toggle state from UI if available, fallback to storage
      const glSwitch = document.querySelector('#glSwitch');
      const glOn = glSwitch ? glSwitch.classList.contains('on') : (readJSON('glossaryEnabled:v1', false)===true);
      const maxBtn = document.getElementById('maxToggle');
      const maxStored = readJSON('maxEnabled:v1', false)===true;
      const maxOn = (tierNow==='business' || tierNow==='pro') && ((!!maxBtn && maxBtn.classList.contains('active')) || maxStored);
      const parts = [];
      if(maxOn) parts.push('Max on');
      if(brandOn) parts.push('Brand Kit on');
      if(glOn) parts.push('Glossary on');
      hints.style.display = parts.length? 'inline' : 'none';
      hints.textContent = parts.join('  Â·  ');
    }
    
    // Expose globally so Brand Kit and Glossary can update hints
    window.updateSubmitHints = updateSubmitHints;

    function initMaxToggle(){
      const section = document.getElementById('maxSection');
      const row = document.getElementById('maxRow');
      const btn = document.getElementById('maxToggle');
      if(!section||!row||!btn) return;
      const userNow = JSON.parse(localStorage.getItem('user')||'{}');
      const tierNow = String(userNow?.tier||'free').toLowerCase();
      section.style.display = (tierNow==='business' || tierNow==='pro') ? 'block' : 'none';
      // Restore previous state from storage
      const wasOn = readJSON('maxEnabled:v1', false)===true;
      const canUse = (tierNow==='business' || tierNow==='pro');
      btn.classList.toggle('active', canUse && wasOn);
      btn.setAttribute('aria-pressed', (canUse && wasOn)?'true':'false');
      // Overwrite previous handlers to avoid duplicates
      btn.onclick = function(){
        const u = JSON.parse(localStorage.getItem('user')||'{}');
        const tnow = String(u?.tier||'free').toLowerCase();
        if(!(tnow==='business' || tnow==='pro')){ showToast('Max Localization is available on Pro and Business'); return; }
        btn.classList.toggle('active');
        btn.setAttribute('aria-pressed', btn.classList.contains('active')?'true':'false');
        // Persist state
        writeJSON('maxEnabled:v1', btn.classList.contains('active'));
        updateSubmitHints();
      };
      updateSubmitHints();
    }

    function setMode(modeId){
      const container=$('#subStyleContainer'), panel=$('#subStylePanel');
      if(selectedMode===modeId){
        selectedMode=""; $$('.style-btn').forEach(b=>b.classList.remove('active'));
        container?.classList.add('is-hidden'); panel?.classList.remove('open'); setChevron(false);
        selectedSubStyle=""; clearChipSelection(); adjustWrapHeight(); return;
      }
      selectedMode=modeId;
      $$('.style-btn').forEach(b=>b.classList.remove('active'));
      document.querySelector(`.style-btn[data-mode="${modeId}"]`)?.classList.add('active');
      renderSubstyles(modeId);
      container?.classList.remove('is-hidden'); panel?.classList.remove('open'); setChevron(false);
      adjustWrapHeight();
    }
    async function submitActiveDoc(doc, opts={}){
      const d=doc||currentDoc(); if(!d) { showToast('No tab'); return; }
      if(d.isSrt){
        return submitSrtDoc(d, opts);
      }
      const input=(d.text||'').trim();
      if(!input){showToast(t('toast_enter_text'));pulse($('#inputText'));return}
      
      // Check character limit
      if (!(await window.checkCharacterLimit(input))) {
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        const tier = user.isGuest ? 'guest' : (user.tier || 'free');
        const tierConfig = window.getTierLimit(tier);
        
        if (user.isGuest) {
          showToast(`Text exceeds ${tierConfig.maxInputSize.toLocaleString()} character limit. Sign in to get higher limits!`);
          // Auto-open sign in modal for guests
          setTimeout(() => {
            if (typeof openAuth === 'function') openAuth('login');
          }, 1000);
        } else {
          showToast(`Text exceeds ${tierConfig.name} tier limit of ${tierConfig.maxInputSize.toLocaleString()} characters. Upgrade for higher limits!`);
        }
        
        pulse($('#inputText'));
        return;
      }
      
      if(!targetLanguage && !rephrase){showToast(t('toast_choose_target'));pulse($('#langButtonsRow'));return}
      if(!selectedMode){showToast(t('toast_choose_style'));pulse($('#styleButtonsRow'));return}

      updateSubmitHints();

      try{
        if(!opts.silent) showLoader(true,'Localizingâ€¦');
        await runTextDoc(d);
        (document.querySelector('#outputText')||document.querySelector('#outputRich'))?.scrollIntoView({behavior:'smooth',block:'center'});
      }catch(e){console.error(e);showToast(t('toast_error_generic'))}
      finally{
        if(!opts.silent){
          setStatus('Localization done');
          setTimeout(()=>hideLoader(true),120);
        }
      }
    }

    async function submitSrtDoc(d, opts={}){
      const items = (d.cues?.length?d.cues.map(c=>c.text):(d.text||'').split(/\r?\n/)).map(v=>v||'');
      if(!items.length){ showToast('No SRT cues'); return; }
      if(!targetLanguage && !rephrase){showToast(t('toast_choose_target'));pulse($('#langButtonsRow'));return}
      if(!selectedMode){showToast(t('toast_choose_style'));pulse($('#styleButtonsRow'));return}
      updateSubmitHints();
      try{
        if(!opts.silent) showLoader(true,'Localizingâ€¦');
        await runSrtDoc(d);
      }catch(e){ console.error(e); showToast(t('toast_error_generic')) }
      finally{ 
        if(!opts.silent){
          setStatus('Localization done');
          setTimeout(()=>hideLoader(true),120);
        }
      }
    }
    async function translateAllTabs(){
      if(!docs.length){ showToast('No tabs'); return; }
      if(!targetLanguage && !rephrase){showToast(t('toast_choose_target'));pulse($('#langButtonsRow'));return}
      if(!selectedMode){showToast(t('toast_choose_style'));pulse($('#styleButtonsRow'));return}

      // Only work on tabs that actually have content
      const work = docs.filter(d=>{
        if(d.isSrt){
          const items = (d.cues?.length?d.cues.map(c=>c.text):(d.text||'').split(/\r?\n/)).map(v=>(v||'').trim());
          return items.some(v=>v.length);
        }else{
          return (d.text||'').trim().length>0;
        }
      });
      if(!work.length){ showToast('Nothing to translate.'); return; }

      showLoader(true,`Localizing 0/${work.length}`);
      try{
        let i=0;
        for(const d of work){
          i++;
          const prettyName = (d.name || '').toString().trim() || (d.ext?`Untitled.${(d.ext||'').toUpperCase()}`:'Untitled');
          setLoaderText(`Localizing ${prettyName} ${i}/${work.length}`);
          setStatus(`Localizing ${prettyName} ${i}/${work.length}`);
          if(d.isSrt) await runSrtDoc(d);
          else await runTextDoc(d);
          setLoaderText(`Localizing ${prettyName} ${i}/${work.length}`);
          setStatus(`Localizing ${prettyName} ${i}/${work.length}`);
        }
      }catch(e){ console.error(e); showToast(t('toast_error_generic'))}
      finally{ setStatus('Localization done'); hideLoader(true); }
    }
    async function downloadLocalized(d){
      d = d || currentDoc(); if(!d) return;
      const base = (d.name||'output').replace(/\.[^.]+$/,'');
      if(d.isSrt){
        const cues = (d.cues||[]).map((c,i)=>({ start:c.start||'', end:c.end||'', text:(d.srtTranslations?.[i]||'') }));
        const payload = { format:'srt', filename:`${base}.localized`, cues, type:'srt', name:`${base}.localized.srt` };
        try{
          const res = await fetch('/api/download',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
          if(!res.ok) throw new Error('HTTP '+res.status);
          const blob = await res.blob();
          const url = URL.createObjectURL(blob); const a=document.createElement('a');
          a.href=url; a.download=`${base}.localized.srt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        }catch(e){ console.error(e); showToast(t('toast_error_generic')) }
        return;
      }

      const text = d.output || '';
      const ext = ['pdf','docx','txt'].includes((d.ext||'').toLowerCase()) ? d.ext.toLowerCase() : 'txt';
      const payload={ text, filename:`${base}.localized`, format:ext };
      try{
        const res = await fetch('/api/download',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `${base}.localized.${ext}`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }catch(e){ console.error(e); showToast(t('toast_error_generic')) }
    }
    async function downloadAllZip(){
      const files = docs.map(d=>{
        if(d.isSrt){
          const base=(d.name||'output').replace(/\.[^.]+$/,'');
          const cues = (d.cues||[]).map((c,i)=>({start:c.start||'', end:c.end||'', text:(d.srtTranslations?.[i]||'')}));
          const hasAny = cues.some(c=> (c.text||'').trim().length );
          if(!hasAny) return null;
          return { filename:`${base}.localized`, type:'srt', format:'srt', cues };
        }else{
          const out=(d.output||'').trim();
          if(!out) return null;
          const base=(d.name||'output').replace(/\.[^.]+$/,'');
          const ext = ['pdf','docx','txt'].includes((d.ext||'').toLowerCase())?d.ext.toLowerCase():'txt';
          return { filename:`${base}.localized`, format:ext, text:out };
        }
      }).filter(Boolean);

      if(!files.length){ showToast('Nothing to download yet.'); return; }
      try{
        
        // Add authentication headers
        const headers = {'Content-Type':'application/json'};
        const token = localStorage.getItem('authToken');
        const guestId = localStorage.getItem('guestId');
        
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        } else if (guestId) {
          headers['X-Guest-ID'] = guestId;
        }
        
        const res=await fetch('/api/download-zip',{method:'POST',headers:headers,body:JSON.stringify({zipname:'localized_bundle', files})});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const blob=await res.blob();
        const url=URL.createObjectURL(blob);
        const a=document.createElement('a');
        a.href=url; a.download='localized_bundle.zip';
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }catch(e){ console.error(e); showToast(t('toast_error_generic')) }
    }

    function buildSourceExportText(doc){
      if(!doc) return '';
      if(doc.isSrt){
        const cues = Array.isArray(doc.cues) ? doc.cues : [];
        if(cues.length){
          return cues.map((cue, idx)=>{
            const seq = String(idx+1);
            const start = (cue.start || '').trim();
            const end = (cue.end || '').trim();
            const text = (cue.text || '').toString();
            const timing = (start || end) ? `${start || ''} --> ${end || ''}`.trim() : '';
            const lines = [seq];
            if(timing) lines.push(timing);
            lines.push(text);
            return lines.join('\n').replace(/[ 	]+$/,'');
          }).join('\n\n');
        }
        return String(doc.text || '');
      }
      return String(doc.text || '');
    }

    function closeExportMenu(root, focusToggle){
      if(!root) return;
      const entry = exportMenus.find(menu=>menu.root===root);
      if(entry){
        entry.close(!!focusToggle);
        return;
      }
      if(root.dataset && root.dataset.open) delete root.dataset.open;
      const toggle = root.querySelector('.export-toggle');
      const dropdown = root.querySelector('.export-dropdown');
      if(toggle) toggle.setAttribute('aria-expanded','false');
      if(dropdown){
        dropdown.setAttribute('aria-hidden','true');
      }
      const card = root.closest('.card');
      if(card){
        card.classList.remove('export-open');
      }
      if(focusToggle && toggle){
        requestAnimationFrame(()=>toggle.focus());
      }
    }

    function closeAllExportMenus(except){
      exportMenus.forEach(menu=>{
        if(except && menu.root===except) return;
        menu.close();
      });
    }

    function wireExportMenu(id){
      const root=document.getElementById(id);
      if(!root) return;
      const toggle=root.querySelector('.export-toggle');
      const dropdown=root.querySelector('.export-dropdown');
      if(!toggle || !dropdown) return;
      const options=Array.from(dropdown.querySelectorAll('.export-option'));
      toggle.setAttribute('aria-expanded','false');
      dropdown.setAttribute('aria-hidden','true');
      const menu={
        root,
        toggle,
        dropdown,
        options,
        open(){
          if(toggle.disabled || toggle.classList.contains('is-disabled')) return;
          closeAllExportMenus(root);
          root.dataset.open='true';
          toggle.setAttribute('aria-expanded','true');
          dropdown.setAttribute('aria-hidden','false');
          const card = root.closest('.card');
          if(card){ card.classList.add('export-open'); }
        },
        close(focus){
          if(root.dataset.open) delete root.dataset.open;
          toggle.setAttribute('aria-expanded','false');
          dropdown.setAttribute('aria-hidden','true');
          const card = root.closest('.card');
          if(card){ card.classList.remove('export-open'); }
          if(focus){ requestAnimationFrame(()=>toggle.focus()); }
        },
        focusFirst(){
          const first=options.find(btn=>!btn.disabled);
          if(first) first.focus();
        }
      };
      toggle.addEventListener('click',e=>{
        e.preventDefault();
        if(toggle.disabled || toggle.classList.contains('is-disabled')) return;
        const isOpen=root.dataset.open==='true';
        if(isOpen){ menu.close(); } else { menu.open(); }
      });
      toggle.addEventListener('keydown',e=>{
        if(toggle.disabled || toggle.classList.contains('is-disabled')) return;
        if(e.key==='Enter' || e.key===' ' || e.key==='ArrowDown'){
          e.preventDefault();
          if(root.dataset.open!=='true'){ menu.open(); }
          menu.focusFirst();
        }else if(e.key==='Escape'){
          e.preventDefault();
          menu.close();
        }
      });
      options.forEach(btn=>{
        btn.addEventListener('click',async e=>{
          e.preventDefault();
          if(toggle.disabled || toggle.classList.contains('is-disabled')) return;
          menu.close();
          const fmt=(btn.dataset.format||'').toLowerCase();
          await exportSourceAs(fmt);
        });
        btn.addEventListener('keydown',e=>{
          if(e.key==='Escape'){
            e.preventDefault();
            menu.close(true);
          }
        });
      });
      exportMenus.push(menu);
    }

    async function exportSourceAs(format, doc){
      const allowed=['pdf','docx','txt'];
      const fmt=(format||'').toLowerCase();
      if(!allowed.includes(fmt)) return;
      const active=doc||currentDoc();
      if(!active) return;
      const text=buildSourceExportText(active).trim();
      if(!text){
        showToast(t('toast_enter_text'));
        return;
      }
      const rawName=(active.name||'input').toString().trim()||'input';
      const base=rawName.replace(/\.[^.]+$/, '')||'input';
      const safeBase=base.replace(/[\\/:*?"<>|]+/g,'-').replace(/\s+/g,'-').trim()||'input';
      const filenameBase=`${safeBase}.source`;
      const headers={'Content-Type':'application/json'};
      const token=localStorage.getItem('authToken');
      const guestId=localStorage.getItem('guestId');
      if(token) headers['Authorization']=`Bearer ${token}`;
      else if(guestId) headers['X-Guest-ID']=guestId;
      try{
        const res=await fetch('/api/download',{method:'POST',headers,body:JSON.stringify({ text, filename:filenameBase, format:fmt })});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const blob=await res.blob();
        const url=URL.createObjectURL(blob);
        const a=document.createElement('a');
        a.href=url;
        a.download=`${filenameBase}.${fmt}`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }catch(e){
        console.error('Export failed', e);
        showToast('Unable to export right now.', { tone:'error' });
      }
    }

    /* ---------- Split view ---------- */
    function toggleSplitView(){
      const has = hasAnyResult();
      const d=currentDoc();
      if(!splitView && !has) return;
      closeAllExportMenus();
      if(!splitView){
        if(d?.isSrt) renderSrtBoxes(d); else renderSegmentBoxes(d);
        splitView=true; updateSplitButton();
        crossfade('#stackArea','#splitArea',()=>{
          observeActiveHeight(); 
          
          // Fix text clipping in split view - ensure all text is visible
          setTimeout(() => {
            document.querySelectorAll('.view.split .segtext, #segSrcBox .segtext, #segTgtBox .segtext').forEach(el => {
              el.style.maxHeight = 'none';
              el.style.overflow = 'visible';
              el.style.height = 'auto';
              el.style.whiteSpace = 'pre-wrap';
            });
            
            document.querySelectorAll('.view.split .segcontent, #segSrcBox .segcontent, #segTgtBox .segcontent').forEach(el => {
              el.style.maxHeight = 'none';
              el.style.overflow = 'visible';
              el.style.height = 'auto';
            });
            
            document.querySelectorAll('.view.split .segrow, #segSrcBox .segrow, #segTgtBox .segrow').forEach(el => {
              el.style.maxHeight = 'none';
              el.style.height = 'auto';
              el.style.alignItems = 'stretch';
            });
            
            equalizeRowHeights();
            console.log('ðŸ“± Split view text clipping fixed');
          }, 100);
        })
      }else{
        splitView=false; updateSplitButton();
        crossfade('#splitArea','#stackArea',()=>{const wrap=$('#modeWrap');wrap.classList.remove('layered');wrap.style.height='';if(heightRO){heightRO.disconnect();heightRO=null}})
      }
    }
    function crossfade(fromSel,toSel,done){const wrap=$('#modeWrap'),from=$(fromSel),to=$(toSel); if(!wrap||!from||!to){done&&done();return} wrap.classList.add('layered'); const hFrom=getContentH(from); wrap.style.height=hFrom+'px'; to.classList.add('active'); from.classList.remove('active'); requestAnimationFrame(()=>{const hTo=getContentH(to); wrap.style.height=hTo+'px'; const finalize=()=>{wrap.removeEventListener('transitionend',onEnd);done&&done()}; const onEnd=e=>{if(e.propertyName!=='height')return;finalize()}; wrap.addEventListener('transitionend',onEnd); if(Math.abs(hTo-hFrom)<1) setTimeout(finalize,20)})}
    function observeActiveHeight(){const wrap=$('#modeWrap'),active=wrap?.querySelector('.view.active'); if(!wrap||!active) return; if(heightRO) heightRO.disconnect(); heightRO=new ResizeObserver(()=>{if(wrap.classList.contains('layered')){wrap.style.height=getContentH(active)+'px'}}); heightRO.observe(active)}
    function adjustWrapHeight(){
      const wrap=$('#modeWrap'),active=wrap?.querySelector('.view.active');
      if(!wrap||!active) return;
      if(wrap.classList.contains('layered')){wrap.style.height=getContentH(active)+'px'}else{wrap.style.height=''}
    }

        /* ---------- Copy helper ---------- */
    async function copyText(sel, btnSel){
      const n=$(sel);
      const v=n?.value ?? n?.textContent ?? '';
      const text=String(v||'');
      try{
        if(window.navigator?.clipboard?.writeText){
          await window.navigator.clipboard.writeText(text);
        }else{
          throw new Error('Clipboard API unavailable');
        }
      }catch{
        try{
          const ta=document.createElement('textarea');
          ta.value=text; ta.style.position='fixed'; ta.style.opacity='0'; ta.style.pointerEvents='none';
          document.body.appendChild(ta); ta.focus(); ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }catch{}
      }finally{
        const b=$(btnSel); if(b) animateCopy(b);
      }
    }

    // ===========================================================
// Brand Kit + Advanced Tools (Glossary & Phrasebook)
// ===========================================================

  /* ---------- Storage keys ---------- */
  const BRAND_KEY='brandKit:v2';              // bumped for UI change
  const GLOSSARY_KEY='glossary:v1';
  const GLOSSARY_ENABLED_KEY='glossaryEnabled:v1';

  /* ---------- Lightweight user account (UID) ---------- */
  const UID_KEY='locUID';
  function getUID(){
    let u=localStorage.getItem(UID_KEY);
    if(!u){ u='u_'+Math.random().toString(36).slice(2)+Date.now().toString(36); localStorage.setItem(UID_KEY,u); }
    return u;
  }

  /* ---------- Helpers ---------- */
  const readJSON=(k,f)=>{try{return JSON.parse(localStorage.getItem(k)||'null')??(typeof f==='function'?f():f)}catch{return (typeof f==='function'?f():f)}};
  const writeJSON=(k,v)=>localStorage.setItem(k,JSON.stringify(v||null));
  const defBrand=()=>({
    name:'',
    tone:[],
    audience:'',
    doList:'',
    dontList:'',
    examples:''
  });
  const defGlossary=()=>[];   // [{src:'Login', tgt:'Masuk', flags:{lock:true,case:'auto'}, notes:''}]

    /* ---------- Global style injector (fixes/clips/animations) ---------- */
  function ensureGlobalUIStyles(){
    if(document.getElementById('globalEnhanceCSS')) return;
    const css = `
      /* ====== TUNE HERE: Save bubble look ======
         Change these two variables to experiment.
         Example: --save-bubble-blur: 16px; --save-bubble-alpha: .72; */
      :root{
        --save-bubble-blur: 2px;
        --save-bubble-alpha: 0.40;
        --save-bubble-label-nudge: 1px; /* vertical fine-tune for label */
        /* NEW â€” tune modal sheet glass here (Brand/Advanced/History) */
        --sheet-glass-blur: var(--save-bubble-blur);   /* e.g. 4px */
        --sheet-glass-alpha: var(--save-bubble-alpha); /* e.g. .10 */
      }

            /* Glass look for modal sheets (Brand Kit, Advanced Tools, History, Language).
        Uses the same tuning vars as the save bubble by default. */
      #brandOverlay .lang-sheet,
      #advOverlay .lang-sheet,
      #histOverlay .lang-sheet,
      #langOverlay .lang-sheet{
        background: rgba(255,255,255,var(--sheet-glass-alpha));
        -webkit-backdrop-filter: blur(var(--sheet-glass-blur)) saturate(1.50);
        backdrop-filter: blur(var(--sheet-glass-blur)) saturate(1.50);
        border: 1px solid rgba(0,0,0,.08);
        box-shadow: 0 10px 40px rgba(0,0,0,.12);
}
      /* Save bubble â€“ glassy, never covers selection */
      .save-bubble{
        position:fixed;z-index:9999;transform:translate(-50%,-6px) scale(.98);opacity:0;
        background:rgba(255,255,255,var(--save-bubble-alpha));
        -webkit-backdrop-filter:blur(var(--save-bubble-blur));backdrop-filter:blur(var(--save-bubble-blur));
        border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:8px 12px;box-shadow:0 8px 28px rgba(0,0,0,.12);
        display:flex;align-items:center;gap:8px;font-size:13px;pointer-events:none;transition:opacity .16s var(--ease),transform .16s var(--ease);
        line-height:1; /* ensure vertical centering across inline elements */
      }
      .save-bubble.show{opacity:1;transform:translate(-50%,-10px) scale(1);pointer-events:auto}
      .save-bubble .label{display:inline-flex;align-items:center;justify-content:center;height:28px;line-height:1;padding:0}
      .save-bubble .act{border:1px solid var(--border);border-radius:10px;padding:6px 10px;background:#fff;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;height:28px}
      /* Left area to keep width stable between states */
      .save-bubble .left{position:relative;display:inline-flex;align-items:center;justify-content:center;height:28px;line-height:1;padding:0;transform:translateY(var(--save-bubble-label-nudge,1px));transition:min-width .12s var(--ease), width .12s var(--ease)}
      .save-bubble .left > .label,
      .save-bubble .left > .ok{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;white-space:nowrap;transition:opacity .10s var(--ease)}
      .save-bubble .ok{opacity:0;color:var(--accent)}
      .save-bubble.saved .ok{opacity:1}
      .save-bubble.saved .label{opacity:0}

      /* Prevent horizontal scrollbars inside overlays */
      #advOverlay .lang-sheet, #brandOverlay .lang-sheet{ overflow-x:hidden; box-sizing:border-box }

      /* Brand Kit form â€” fixed layout */
      #brandOverlay .lang-sheet{max-width:95vw; width:1200px; overflow-x:hidden}
      .brand-container{
        padding:24px 28px; margin:0;
      }
      .brand-top-section{
        display:grid; grid-template-columns:1fr auto; gap:20px; align-items:flex-start; margin-bottom:24px;
      }
      .brand-name-section{}
      .brand-toggle-section{display:flex; align-items:center; gap:12px}
      
      .brand-tones-section{margin-bottom:24px}
      
      .brand-bottom-grid{
        display:grid; grid-template-columns:1fr 1fr 1fr; gap:20px; margin-bottom:24px;
      }
      .brand-footer{
        display:flex; justify-content:flex-end; gap:12px; padding-top:20px; 
        border-top:1px solid #e5e7eb;
      }
      
      .brand-section-label{
        font-size:14px; font-weight:600; color:#1a1a1a; margin-bottom:8px; display:block;
      }
      .brand-input{
        width:300px; min-width:300px; max-width:100%; padding:12px 16px; border:1px solid #d1d5db; border-radius:12px; font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif; 
        background:#fff; font-size:14px; font-family:inherit;
        transition:border-color .2s ease, box-shadow .2s ease, width .2s ease;
      }
      .brand-input:focus{
        width:400px;
        outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak);
      }
      .brand-textarea{
        width:100%; min-height:140px; padding:12px 16px; border:1px solid #d1d5db; font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif; 
        border-radius:12px; background:#fff; font-size:14px; font-family:inherit; resize:vertical;
        transition:border-color .2s ease, box-shadow .2s ease;
      }
      .brand-textarea:focus{
        outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak);
      }

      /* Tone chips â€” exact design replica */
      .tones-grid{
        display:flex;
        flex-wrap:wrap;
        gap:8px;
        align-items:center;
        margin-top:8px;
      }
      .tone-chip{
        border:1px solid var(--border);
        background:#fafafa;
        border-radius:999px;
        padding:9px 18px;
        font-size:14px;
        font-weight:500;
        color:var(--text);
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:center;
        min-height:38px;
        white-space:nowrap;
        transition:background .18s var(--ease),border-color .18s var(--ease),box-shadow .18s var(--ease),color .18s var(--ease);
      }
      .tone-chip:hover,
      .tone-chip:focus-visible{
        background:#fff;
        border-color:var(--accent);
        box-shadow:0 0 0 2px var(--accent-weak);
        outline:none;
      }
      .tone-chip.active{
        background:var(--accent-weak);
        border-color:var(--accent);
        box-shadow:0 0 0 2px var(--accent-weak);
      }
      .tone-chip.active:hover,
      .tone-chip.active:focus-visible{
        background:var(--accent-weak);
        border-color:var(--accent);
        box-shadow:0 0 0 2px var(--accent-weak);
      }
      
      /* Brand toggle switch */
      .brand-toggle{
        position:relative; width:52px; height:28px; border-radius:20px; 
        background:#cbd5e1; cursor:pointer; transition:background .3s ease;
        border:none; outline:none;
      }
      .brand-toggle.active{background:var(--accent)}
      .brand-toggle::after{
        content:''; position:absolute; top:2px; left:2px; width:24px; height:24px;
        background:#fff; border-radius:50%; transition:transform .3s ease;
        box-shadow:0 1px 3px rgba(0,0,0,.3);
      }
      .brand-toggle.active::after{transform:translateX(24px)}
      
      .brand-toggle-label{
        font-size:13px; font-weight:500; color:#374151;
      }
      


      /* Advanced overlay + tabs */
      #advOverlay .lang-sheet{max-width:95vw; width:1100px; overflow-x:hidden;}
      .adv-tabs{display:flex;gap:8px;padding:10px 12px;border-bottom:1px solid rgba(0,0,0,0.08);position:sticky;top:0;background:rgba(255,255,255,0.1);backdrop-filter:blur(var(--sheet-glass-blur)) saturate(1.50);z-index:1}
      .adv-tab{border:1px solid rgba(0,0,0,0.08);background:rgba(255,255,255,0.2);backdrop-filter:blur(8px);border-radius:999px;padding:6px 12px;font-size:13px;font-family:"Inter",system-ui,-apple-system,BlinkMacSystemFont,sans-serif;cursor:pointer;transition:all .15s ease;}
      .adv-tab:hover{background:rgba(255,255,255,0.3);border-color:rgba(0,122,255,0.3);transform:translateY(-1px);}
      .adv-tab.active{background:rgba(255,255,255,0.4);border-color:var(--accent);box-shadow:0 0 0 2px var(--accent-weak);backdrop-filter:blur(12px);}

      .adv-pane{display:none;padding:14px 16px;}
      .adv-pane.active{display:block;}

      /* Glossary table â€” improved spacing and styling */
      .bp-table{ width:100%; border:1px solid var(--border); border-radius:12px; overflow:visible; background:#fff; box-shadow:var(--shadow-soft) }
      .bp-table table{ width:100%; border-collapse:collapse; font-size:14px }
      .bp-table th,.bp-table td{ border-top:1px solid #f0f0f3; padding:12px 16px; vertical-align:top; }
      .bp-table th:first-child{ border-top-left-radius:12px; }
      .bp-table th:last-child{ border-top-right-radius:12px; }
      .bp-table th{ background:#fafafa; font-weight:600; text-align:left; white-space:nowrap; font-size:14px; color:#1a1a1a; }
      .bp-table td input[type="text"]{ 
        width:100%; min-width:180px; padding:8px 12px; border:1px solid #d1d5db; 
        border-radius:8px; background:#fff; font-size:14px; font-family:inherit;
        transition:border-color .2s ease, box-shadow .2s ease;
      }
      .bp-table td input[type="text"]:focus{
        outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak);
      }
      .bp-table td select{ 
        min-width:160px; padding:8px 32px 8px 12px; border:1px solid #d1d5db; 
        border-radius:8px; background:#fff; font-size:14px; font-family:inherit;
        transition:border-color .2s ease, box-shadow .2s ease, background-position .2s ease;
        -webkit-appearance:none; -moz-appearance:none; appearance:none;
        background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 24 24" fill="none" stroke="%236b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>');
        background-repeat:no-repeat; background-position:right 12px center;
      }
      .bp-table td select:focus{
        outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak);
      }
      /* Hide default arrow for legacy Edge/IE */
      #advOverlay .bp-table td select::-ms-expand{ display:none; }
      .bp-table.is-disabled{ opacity:.6 }
      .bp-toolbar{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
      /* Align Glossary toolbar buttons with main toolbar styling */
      #advOverlay .bp-toolbar .mini{ 
        padding:10px 16px; border:1.5px solid #e5e7eb; border-radius:12px; background:#fff; 
        font-size:13px; font-weight:500; cursor:pointer; 
        transition:border-color .18s ease, background-color .18s ease; color:#374151; white-space:nowrap;
        text-align:center; box-shadow:none;
      }
      #advOverlay .bp-toolbar .mini:hover{
        background:#fff; border-color:var(--accent);
        box-shadow:none; transform:none; color:#374151;
      }

      /* Icon-only action within Glossary rows */
      #advOverlay .bp-table .gl-row-del{ 
        padding:6px; width:34px; height:34px; display:inline-flex; align-items:center; justify-content:center;
        border:1.5px solid #e5e7eb; border-radius:10px; background:#fff; box-shadow:none; cursor:pointer;
        transition:border-color .18s ease, background-color .18s ease;
      }
      #advOverlay .bp-table .gl-row-del:hover{ background:#fff; border-color:var(--accent); }
      .mini.primary{ 
        background:var(--accent); color:#fff; font-weight:600;
        border:2px solid var(--accent); 
        box-shadow:0 0 0 2px var(--accent-weak), 0 3px 12px rgba(0,122,255,.25);
      }
      .mini.primary:hover{
        background:#0056d6; border-color:#0056d6; transform:translateY(-1px);
        box-shadow:0 0 0 3px var(--accent-weak), 0 4px 16px rgba(0,122,255,.35);
      }

      /* Glossary ON/OFF switch - same as brand toggle */
      .gl-toggle{display:inline-flex;align-items:center;gap:12px;margin-left:4px}
      .gl-switch{
        position:relative; width:52px; height:28px; border-radius:20px; 
        background:#cbd5e1; cursor:pointer; transition:background .3s ease;
        border:none; outline:none;
      }
      .gl-switch.on{background:var(--accent)}
      .gl-switch::after{
        content:''; position:absolute; top:2px; left:2px; width:24px; height:24px;
        background:#fff; border-radius:50%; transition:transform .3s ease;
        box-shadow:0 1px 3px rgba(0,0,0,.3);
      }
      .gl-switch.on::after{transform:translateX(24px)}
      .gl-label{font-size:13px; font-weight:500; color:#374151;}
      /* Phrasebook Saved (refined) */
      .pb-wrap{ display:grid; grid-template-columns:1fr; gap:12px; }
      /* When Saved sidebar is shown, use 2-column layout */
      .pb-wrap[data-cols="2"]{ grid-template-columns:minmax(0,1fr) 480px; }
      .pb-wrap[data-cols="1"]{ grid-template-columns:1fr; }
      @media (max-width:980px){ .pb-wrap{ grid-template-columns:1fr } }
      /* Ensure phrasebook can expand to two columns when sidebar visible */
      #advPhrasebook .pb-wrap[data-cols="2"]{ grid-template-columns:minmax(0,1fr) 480px; }
      .pb-saved{ border:1px solid var(--border); border-radius:12px; box-shadow:var(--shadow-soft); background:#fff; overflow:hidden; transition:transform .18s var(--ease), opacity .18s var(--ease) }
      .pb-head{ display:flex; align-items:center; justify-content:space-between; padding:16px 20px; border-bottom:1px solid #f0f0f3; background:#fafafa; }
      .pb-head strong{ font-size:14px; font-weight:600; color:#1a1a1a; }
      .pb-head .pb-search, .pb-head .pb-sort{ height:32px; padding:0 12px; border:1px solid #d1d5db; border-radius:8px; background:#fff; font-size:14px; font-family:inherit; transition:border-color .2s ease, box-shadow .2s ease, background-position .2s ease; display:flex; align-items:center; line-height:1; }
      /* Align pb-sort caret like Glossary select */
      .pb-head .pb-sort{ -webkit-appearance:none; -moz-appearance:none; appearance:none; padding-right:32px; background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 24 24" fill="none" stroke="%236b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>'); background-repeat:no-repeat; background-position:right 10px center; }
      #advOverlay .pb-head .pb-sort::-ms-expand{ display:none; }
      .pb-head .pb-search:focus, .pb-head .pb-sort:focus{ outline:none; border-color:var(--accent) !important; box-shadow:0 0 0 3px var(--accent-weak) !important; }
      /* Emphasize pb-sort outline on hover to match glossary */
      .pb-head .pb-sort:hover{ border-color:var(--accent); background:#fff; transform:none; }
      .pb-list{ max-height:60vh; overflow:auto; padding:4px 4px }
      .pb-item{ display:flex; justify-content:space-between; align-items:center; padding:16px 20px; border-top:1px solid #f0f0f3; gap:12px; transition:background .15s ease; }
      .pb-item:hover{ background:#f8f9fa; }
      .pb-item:first-child{ border-top:none }
      .pb-meta{ font-size:12px; color:#6b7280; font-weight:400; }
      .pb-star{ border:1.5px solid #e5e7eb; background:#fff; border-radius:10px; width:34px; height:34px; padding:0; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; color:#374151; transition:border-color .15s ease, background-color .15s ease; }
      .pb-star:hover{ border-color:var(--accent); background:#fff; transform:none; }
      .pb-empty{ padding:20px; color:#6b7280; font-size:14px; text-align:center; background:#f8f9fa; border-radius:8px; margin:12px 0; }

      /* Slide-open affordance for small screens */
      .pb-saved.is-hidden{ opacity:0; pointer-events:none; }
      .pb-saved{ opacity:1; }

      /* Brand save animation */
      .flash-save{ animation:flash 900ms var(--ease) 1 }
      @keyframes flash{ 0%{box-shadow:0 0 0 0 rgba(0,122,255,.35)} 100%{box-shadow:0 0 0 0 transparent} }

      /* Compact Usage Meter */
      .usage-mini{ display:inline-flex; align-items:center; gap:10px; border:1px solid var(--border); background:var(--card); border-radius:10px; padding:8px 10px; box-shadow:var(--shadow-soft); position:relative; cursor:pointer; transition:transform .12s var(--ease), box-shadow .12s var(--ease), border-color .12s var(--ease); z-index:1010 }
      .usage-mini:hover{ transform:translateY(-1px); border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak), var(--shadow-soft) }
      .usage-mini:focus{ outline:none; box-shadow:0 0 0 3px var(--accent-weak), var(--shadow-soft) }
      .usage-mini-main{ display:flex; align-items:center; gap:10px }
      .usage-mini-label{ font-family:-apple-system,BlinkMacSystemFont,'SF Pro Text','Inter','Helvetica Neue',Arial,system-ui,sans-serif; font-size:13px; font-weight:600; color:var(--text) }
      .usage-mini-track{ width:120px; height:8px; background:#EFF2F7; border-radius:999px; overflow:hidden }
      .usage-mini-bar{ height:100%; width:0%; background:var(--accent); border-radius:999px; transition:width .35s cubic-bezier(.22,.61,.36,1) }
      .usage-mini[data-variant="warning"] .usage-mini-bar{ background:#d97706 }
      .usage-mini[data-variant="critical"] .usage-mini-bar{ background:#dc2626 }
      .usage-mini-dropdown{ position:absolute; right:0; top:calc(100% + 8px); min-width:260px; background:var(--card); border:0 solid var(--border); border-radius:12px; box-shadow:var(--shadow); overflow:hidden; max-height:0; opacity:0; pointer-events:none; transition:max-height .28s var(--ease), opacity .16s var(--ease), border-width .16s var(--ease); z-index:1020 }
      /* Remove seam line per request */
      .usage-mini-seam{ display:none }
      .usage-mini[aria-expanded="true"] .usage-mini-dropdown{ max-height:220px; opacity:1; border-width:1px; pointer-events:auto }
      .usage-mini[aria-expanded="true"] .usage-mini-seam{ opacity:1 }
      .usage-mini-panel{ display:grid; grid-template-columns:1fr auto; gap:16px; align-items:center; padding:16px 16px }
      .usage-mini-plan{ font-size:14px; font-weight:700; color:var(--text) }
      .usage-mini-reset{ font-size:14px; line-height:20px; margin:0; color:var(--muted) }
      .usage-mini-left{ display:flex; flex-direction:column; gap:4px }
      .usage-mini-right{ text-align:right; padding-right:0; display:flex; align-items:center; gap:6px }
      .usage-mini-pct{ font-size:32px; line-height:36px; font-weight:700 }
      .usage-mini-suffix{ font-size:14px; font-weight:500; color:var(--text); margin-left:4px }

      /* Prevent accidental browser selection handle from covering bubble on mobile */
      @media (pointer:coarse){
        .save-bubble{ transform:translate(-50%,-2px) scale(1) }
      }

      /* Close button hover for Advanced Tools */
      #advOverlay .lang-close{ border:1px solid var(--border); border-radius:10px; padding:6px 10px; background:#fff; color:#6b7280; transition:border-color .18s ease, color .18s ease; }
      #advOverlay .lang-close:hover{ border-color:var(--accent); color:var(--accent); }
      /* Close button hover for History and Brand Kit */
      #histOverlay .lang-close{ border:1px solid var(--border); border-radius:10px; padding:6px 10px; background:#fff; color:#6b7280; transition:border-color .18s ease, color .18s ease; }
      #histOverlay .lang-close:hover{ border-color:var(--accent); color:var(--accent); }
      #brandOverlay .lang-close{ border:1px solid var(--border); border-radius:10px; padding:6px 10px; background:#fff; color:#6b7280; transition:border-color .18s ease, color .18s ease; }
      #brandOverlay .lang-close:hover{ border-color:var(--accent); color:var(--accent); }

      /* Brand Kit Reset button style */
      #brandOverlay .mini{ border:1px solid var(--border); background:#fff; border-radius:12px; padding:8px 16px; cursor:pointer; font-size:13px; font-weight:500; color:var(--text); display:inline-flex; align-items:center; justify-content:center; min-height:36px; line-height:1; gap:6px; transition:border-color .18s var(--ease),color .18s var(--ease),background .18s var(--ease); }
      #brandOverlay .mini:hover,
      #brandOverlay .mini:focus-visible{ border-color:var(--accent); outline:none; }

      /* Phrasebook Clear button */
      .pb-head .pb-clear{ height:32px; padding:0 12px; border:1.5px solid #e5e7eb; border-radius:8px; background:#fff; font-size:13px; font-weight:500; color:#374151; cursor:pointer; transition:border-color .18s ease; }
      .pb-head .pb-clear:hover{ border-color:var(--accent); }

      /* Brand Kit Save button â€” match main Submit */
      #brandOverlay #bpSave{ position:relative; display:grid; place-items:center; background:var(--accent); color:#fff; border:1px solid var(--accent); border-radius:12px; padding:8px 20px; min-width:96px; font-weight:600; line-height:1; box-shadow:none !important; transform:none !important; transition:background .18s var(--ease), color .18s var(--ease), border-color .18s var(--ease); }
      #brandOverlay #bpSave:hover,
      #brandOverlay #bpSave:focus-visible{ background:#fff; color:var(--accent); border-color:var(--accent); outline:none; }
      #brandOverlay #bpSave .btn-label{ grid-area:1/1; display:inline-flex; align-items:center; justify-content:center; gap:6px; transition:opacity .18s var(--ease); }
      #brandOverlay #bpSave .btn-label-success{ opacity:0; }
      #brandOverlay #bpSave.is-saved .btn-label-success{ opacity:1; }
      #brandOverlay #bpSave.is-saved .btn-label-default{ opacity:0; }
      #brandOverlay #bpSave .btn-check{ display:inline-flex; align-items:center; justify-content:center; font-size:16px; line-height:1; }
    `;
    const st=document.createElement('style'); st.id='globalEnhanceCSS'; st.textContent=css; document.head.appendChild(st);
  }

  /* ---------- Toolbar buttons ---------- */
  const SPARKLE_SVG = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.75" aria-hidden="true"><path d="M12 3l2.2 4.6L19 10l-4.6 2.2L12 17l-2.2-4.8L5 10l4.8-2.4L12 3z"></path></svg>';
  const WRENCH_SVG = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.8"><path d="M21 3l-6 6M3 21l6-6M3 3l6 6M21 21l-6-6"></path></svg>';

  function injectBrandButton(){
    const tb=document.querySelector('#toolbarRow2'); if(!tb || document.getElementById('brandBtn')) return;
    const btn=document.createElement('button');
    btn.id='brandBtn';
    btn.className='btn face-btn';
    btn.title='Brand Kit';
    btn.innerHTML = SPARKLE_SVG + '<span>Brand Kit</span>';
    btn.addEventListener('click',openBrandOverlay);
    // Place after Split View and before Usage Meter to form second row order
    const usageMini = document.getElementById('usageMini');
    if (usageMini) tb.insertBefore(btn, usageMini);
    else tb.appendChild(btn);
    ensureBrandOverlay();
    // Keep hover consistent: border only, no face text color change
    btn.addEventListener('mouseenter',()=>{ btn.style.borderColor='var(--accent)'; btn.style.boxShadow='none'; });
    btn.addEventListener('mouseleave',()=>{ btn.style.borderColor=''; btn.style.boxShadow=''; });
  }

  function injectAdvancedButton(){
    const tb=document.querySelector('#toolbarRow2'); if(!tb || document.getElementById('advBtn')) return;
    const btn=document.createElement('button');
    btn.id='advBtn';
    btn.className='btn face-btn';
    btn.title='Advanced Tools (Glossary, Phrasebook)';
    btn.innerHTML = WRENCH_SVG + '<span>Advanced Tools</span>';
    btn.addEventListener('click',openAdvancedOverlay);
    // Place after Brand Kit and before Usage Meter
    const usageMini = document.getElementById('usageMini');
    if (usageMini) tb.insertBefore(btn, usageMini);
    else tb.appendChild(btn);
    ensureAdvancedOverlay();
    // Keep hover consistent: border only, no face text color change
    btn.addEventListener('mouseenter',()=>{ btn.style.borderColor='var(--accent)'; btn.style.boxShadow='none'; });
    btn.addEventListener('mouseleave',()=>{ btn.style.borderColor=''; btn.style.boxShadow=''; });
  }
    /* ---------- Brand overlay (standalone) ---------- */
  function ensureBrandOverlay(){
    if(document.getElementById('brandOverlay')) return;

    const wrap=document.createElement('div');
    wrap.id='brandOverlay';
    wrap.className='lang-overlay';
    wrap.setAttribute('role','dialog');
    wrap.setAttribute('aria-modal','true');
    wrap.setAttribute('aria-hidden','true');

    wrap.innerHTML = `
      <div class="lang-sheet" role="document">
        <div class="lang-head">
          <div class="lang-title" style="font-size:18px;font-weight:700;color:#1a1a1a">Brand Kit</div>
          <div style="display:flex;gap:8px">
            <button class="lang-close" id="brandCloseBtn" aria-label="Close" style="font-size:16px;color:#6b7280;padding:8px 10px">âœ•</button>
          </div>
        </div>

        <div class="brand-container">
          <!-- Top Section: Brand Name + Toggle -->
          <div class="brand-top-section">
            <div class="brand-name-section">
              <label class="brand-section-label">Brand names</label>
              <input id="bpName" class="brand-input" type="text" placeholder="">
            </div>
            <div class="brand-toggle-section">
              <button id="brandToggle" class="brand-toggle" type="button"></button>
              <span class="brand-toggle-label">Brand Injection On/Off</span>
            </div>
          </div>

          <!-- Tones Section -->
          <div class="brand-tones-section">
            <label class="brand-section-label">Tones</label>
            <div class="tones-grid" id="bpTones"></div>
          </div>

          <!-- Bottom Grid -->
          <div class="brand-bottom-grid">
            <div>
              <label class="brand-section-label">Target Audience</label>
              <textarea id="bpAudience" class="brand-textarea" rows="6" placeholder="Who are you writing for? (e.g., new customers, developers, parents, executives)"></textarea>
            </div>
            <div>
              <label class="brand-section-label">Brand Examples</label>
              <textarea id="bpExamples" class="brand-textarea" rows="6" placeholder="Share a few brand-perfect example sentences that capture your voice and style"></textarea>
            </div>
            <div>
              <label class="brand-section-label">Things to Avoid</label>
              <textarea id="bpAvoid" class="brand-textarea" rows="6" placeholder="Words, phrases, or tones to avoid (e.g., jargon, overpromises, corporate speak)"></textarea>
            </div>
          </div>

          <!-- Footer -->
          <div class="brand-footer">
            <button class="mini" id="bpReset">Reset</button>
            <button class="mini primary" id="bpSave">Save</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(wrap);

    const saveBtn = wrap.querySelector('#bpSave');
    if (saveBtn) {
      saveBtn.innerHTML = '<span class="btn-label btn-label-default">Save</span><span class="btn-label btn-label-success" aria-hidden="true"><span class="btn-check" aria-hidden="true">âœ“</span> Saved</span>';
      saveBtn.setAttribute('aria-live', 'polite');
      saveBtn.setAttribute('aria-label', 'Save brand kit');
    }

    // Close/open
    const close=()=>{wrap.classList.remove('show'); wrap.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',onKey)};
    const onKey=e=>{if(e.key==='Escape') close()};
    wrap.querySelector('#brandCloseBtn').addEventListener('click',close);
    wrap.addEventListener('click',e=>{ if(e.target.id==='brandOverlay') close(); });

    // Populate tones in grid layout
    const tones=['Friendly','Clear','Professional','Premium','Warm','Confident','Playful','Minimalist','Bold','Humble'];
    const toneWrap=wrap.querySelector('#bpTones');
    tones.forEach(tok=>{
      const el=document.createElement('button');
      el.className='tone-chip'; el.type='button'; el.textContent=tok; el.dataset.val=tok;
      el.addEventListener('click',()=>{
        el.classList.toggle('active');
      });
      toneWrap.appendChild(el);
    });

    // Brand toggle functionality
    const brandToggle = wrap.querySelector('#brandToggle');
    const brandToggleLabel = wrap.querySelector('.brand-toggle-label');
    let brandEnabled = readJSON('brandEnabled:v1', false);
    
    function updateBrandToggle(enabled) {
      brandEnabled = enabled;
      brandToggle.classList.toggle('active', enabled);
      brandToggleLabel.textContent = enabled ? 'Brand Injection On' : 'Brand Injection Off';
      writeJSON('brandEnabled:v1', enabled);
      if (window.updateSubmitHints) window.updateSubmitHints();
    }
    
    updateBrandToggle(brandEnabled);
    brandToggle.addEventListener('click', () => {
      updateBrandToggle(!brandEnabled);
    });



    // Restore
    const b=readJSON(BRAND_KEY, defBrand);
    wrap.querySelector('#bpName').value=b.name||'';
    wrap.querySelector('#bpAudience').value=b.audience||'';
    wrap.querySelector('#bpAvoid').value=b.dontList||'';
    wrap.querySelector('#bpExamples').value=b.examples||'';
    (b.tone||[]).forEach(t=>{
      const chip = toneWrap.querySelector(`[data-val="${t}"]`);
      if(chip) chip.classList.add('active');
    });

    // Save/reset
    wrap.querySelector('#bpSave').addEventListener('click', async (e)=>{
      const btn = e.currentTarget;
      const next={
        name: wrap.querySelector('#bpName').value.trim(),
        tone: Array.from(toneWrap.querySelectorAll('.tone-chip.active')).map(x=>x.dataset.val),
        audience: wrap.querySelector('#bpAudience').value.trim(),
        dontList: wrap.querySelector('#bpAvoid').value.trim(),
        examples: wrap.querySelector('#bpExamples').value.trim(),
        enabled: brandEnabled
      };
      // Persist locally
      writeJSON(BRAND_KEY,next);
      // Optimistic feedback without layout shift
      if (btn) {
        btn.classList.add('is-saved');
        btn.setAttribute('aria-label', 'Brand kit saved');
        if (btn._resetTimer) clearTimeout(btn._resetTimer);
        btn._resetTimer = setTimeout(()=>{
          btn.classList.remove('is-saved');
          btn.setAttribute('aria-label', 'Save brand kit');
          btn._resetTimer = null;
        }, 1400);
      }

      // Sync to server (upsert first kit for this user)
      try{
        const headers = { 'Content-Type':'application/json' };
        const token = localStorage.getItem('authToken');
        const guestId = localStorage.getItem('guestId');
        
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        } else if (guestId) {
          headers['X-Guest-ID'] = guestId;
        }
        const payload = {
          name: next.name || 'My Brand',
          tone: next.tone || [],
          forbidden_words: (next.dontList||'').split(/[\n,]+/).map(s=>s.trim()).filter(Boolean),
          style_notes: JSON.stringify({ audience: next.audience||'', examples: next.examples||'', enabled: !!next.enabled })
        };
        const list = await fetch('/api/brand-kits', { headers });
        if (list.ok){
          const data = await list.json();
          const exist = (data.items||[])[0];
          if (exist && exist.id){
            await fetch(`/api/brand-kits/${exist.id}`, { method:'PUT', headers, body: JSON.stringify(payload) });
          } else {
            await fetch('/api/brand-kits', { method:'POST', headers, body: JSON.stringify(payload) });
          }
        }
      }catch(err){ console.warn('Brand kit sync failed', err); }
    });
    wrap.querySelector('#bpReset').addEventListener('click',()=>{
      // Clear all form fields
      wrap.querySelector('#bpName').value = '';
      wrap.querySelector('#bpAudience').value = '';
      wrap.querySelector('#bpAvoid').value = '';
      wrap.querySelector('#bpExamples').value = '';
      
      // Unselect all tone chips
      toneWrap.querySelectorAll('.tone-chip.active').forEach(chip => {
        chip.classList.remove('active');
      });
      
      // Reset toggle to disabled (default)
      updateBrandToggle(false);
      
      // Clear stored data
      writeJSON(BRAND_KEY, defBrand());
      writeJSON('brandEnabled:v1', false);
      
      showToast('Brand kit reset');
    });
  }
  function openBrandOverlay(){
    const ov=document.getElementById('brandOverlay'); if(!ov) return;
    ov.classList.add('show'); ov.setAttribute('aria-hidden','false');
    const onKey=e=>{if(e.key==='Escape'){ ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',onKey); }};
    document.addEventListener('keydown',onKey);
  }
  /* ---------- Advanced Tools overlay (Glossary + Phrasebook Saved) ---------- */
  function ensureAdvancedOverlay(){
    if(document.getElementById('advOverlay')) return;

    const wrap=document.createElement('div');
    wrap.id='advOverlay';
    wrap.className='lang-overlay';
    wrap.setAttribute('role','dialog');
    wrap.setAttribute('aria-modal','true');
    wrap.setAttribute('aria-hidden','true');
    wrap.innerHTML=`
      <div class="lang-sheet" role="document" style="max-width:980px">
        <div class="lang-head">
          <div class="lang-title">Advanced Tools</div>
          <div style="display:flex;gap:8px">
            <button class="lang-close" id="advCloseBtn" aria-label="Close">âœ•</button>
          </div>
        </div>

        <div class="adv-tabs">
          <button class="adv-tab active" data-pane="advGlossary">Glossary</button>
          <button class="adv-tab" data-pane="advPhrasebook">Phrasebook</button>
        </div>

        <div class="lang-grid" id="advGrid" style="padding-right:8px">
          <!-- Glossary (with Saved sidebar) -->
          <div class="adv-pane active" id="advGlossary">
            <div class="pb-wrap" data-cols="1">
              <div>
                <div class="bp-toolbar">
                  <button class="mini" id="glAdd">Add row</button>
                  <button class="mini" id="glImport">Import CSV/TSV/TMX</button>
                  <input type="file" id="glFile" accept=".csv,.tsv,.txt,.tmx" style="display:none">
                  <button class="mini" id="glClear">Clear</button>

                  <!-- ON/OFF toggle -->
                  <div class="gl-toggle" title="Enable/disable glossary rules">
                    <div class="gl-switch" id="glSwitch"></div>
                    <span class="gl-label" id="glSwitchLabel">Glossary Off</span>
                  </div>

                  <div style="font-size:13px; color:#6b7280; font-weight:400;">Lock terms for consistent terminology.</div>
                </div>
                <div class="bp-table" id="glTableHost" style="margin-top:20px;">
                  <table id="glTable">
                    <thead>
                      <tr>
                        <th style="width:26%">Source term</th>
                        <th style="width:26%">Preferred translation</th>
                        <th style="width:18%">Flags</th>
                        <th style="width:26%">Notes</th>
                        <th style="width:4%"></th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px;padding:8px 0;">
                  <div id="glStats" style="font-size:13px; color:#6b7280; font-weight:400;">0 terms</div>
                  <div style="font-size:13px; color:#6b7280; font-weight:400;text-align:right;line-height:1.4;">Tip: leave "Preferred translation" blank + lock â†’ keep product names untranslated.</div>
                </div>
              </div>

              <!-- Minimal saved sidebar (shared with Phrasebook) -->
              <div class="pb-saved is-hidden" data-scope="glossary">
                <div class="pb-head">
                  <div style="display:flex;align-items:center;gap:8px"><strong>Saved</strong></div>
                  <div style="display:flex;gap:8px">
                    <input class="pb-search" type="text" placeholder="Search savedâ€¦" style="border:1px solid var(--border);border-radius:10px">
                    <select class="pb-sort" style="border:1px solid var(--border);border-radius:10px">
                      <option value="new">Newest</option>
                      <option value="old">Oldest</option>
                      <option value="az">A â†’ Z</option>
                      <option value="za">Z â†’ A</option>
                    </select>
                  </div>
                </div>
                <div class="pb-list"></div>
              </div>
            </div>
          </div>

          <!-- Phrasebook (main + same Saved sidebar) -->
          <div class="adv-pane" id="advPhrasebook">
            <div class="pb-wrap" data-cols="1">
              <div class="pb-saved" data-scope="phrasebook" style="grid-column:1/-1">
                <div class="pb-head">
                  <div style="display:flex;align-items:center;gap:8px"><strong>Saved</strong></div>
                  <div style="display:flex;gap:8px">
                    <input class="pb-search" type="text" placeholder="Search savedâ€¦" style="border:1px solid var(--border);border-radius:10px">
                    <select class="pb-sort" style="border:1px solid var(--border);border-radius:10px">
                      <option value="new">Newest</option>
                      <option value="old">Oldest</option>
                      <option value="az">A â†’ Z</option>
                      <option value="za">Z â†’ A</option>
                    </select>
                    <button class="pb-clear" type="button" title="Clear all saved phrases">Clear</button>
                  </div>
                </div>
                <div class="pb-list"></div>
              </div>
              <div id="pbHowTo" style="grid-column:1/-1;padding:8px 0;margin-top:8px;">
                <div style="font-size:13px; color:#6b7280; font-weight:400; line-height:1.4;">
                  Tip: select text in the Result and click <strong style="color:#374151;">Save to Phrasebook</strong>. In Split View, it saves the paired source line automatically.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>`;
    document.body.appendChild(wrap);

    // helper: keep grid columns sane when Saved sidebar is shown/hidden
    function adjustPbWrapGrid(){
      document.querySelectorAll('#advOverlay .adv-pane .pb-wrap').forEach(w=>{
        const hasVisibleSidebar = !!w.querySelector('.pb-saved:not(.is-hidden)');
        w.setAttribute('data-cols', hasVisibleSidebar ? '2' : '1');
      });
    }

    // tabs
    wrap.querySelectorAll('.adv-tab').forEach(btn=>{
      btn.addEventListener('click',()=>{
        // Simple, fast tab switching
        wrap.querySelectorAll('.adv-tab').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        
        wrap.querySelectorAll('.adv-pane').forEach(p=>p.classList.remove('active','active-enter'));
        const targetPane = document.getElementById(btn.getAttribute('data-pane'));
        
        if(targetPane) {
          targetPane.classList.add('active');
        }

        // Handle sidebar visibility based on tab
        const isPhrasebook = btn.getAttribute('data-pane') === 'advPhrasebook';
        
        if(isPhrasebook) {
          // Show phrasebook sidebar
          document.querySelectorAll('#advGlossary .pb-saved').forEach(x=>x.classList.add('is-hidden'));
          document.querySelectorAll('#advPhrasebook .pb-saved').forEach(x=>x.classList.remove('is-hidden'));
        } else {
          // Hide all sidebars for glossary
          document.querySelectorAll('#advPhrasebook .pb-saved').forEach(x=>x.classList.add('is-hidden'));
          document.querySelectorAll('#advGlossary .pb-saved').forEach(x=>x.classList.add('is-hidden'));
        }
        
        // Adjust grid layout
        adjustPbWrapGrid();
      });
    });

    const close=()=>{wrap.classList.remove('show'); wrap.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',onKey)};
    const onKey=e=>{if(e.key==='Escape') close()};
    wrap.querySelector('#advCloseBtn').addEventListener('click',close);
    wrap.addEventListener('click',e=>{ if(e.target.id==='advOverlay') close(); });

    // Glossary ON/OFF switch
    const glSwitch = wrap.querySelector('#glSwitch');
    const glLabel = wrap.querySelector('#glSwitchLabel');
    const hostTable = wrap.querySelector('#glTableHost');

    function setGlUI(on){
      glSwitch.classList.toggle('on', !!on);
      glLabel.textContent = on ? 'Glossary On' : 'Glossary Off';
      hostTable.classList.toggle('is-disabled', !on);
      writeJSON(GLOSSARY_ENABLED_KEY, !!on);
      if (window.updateSubmitHints) window.updateSubmitHints();
    }
    setGlUI(readJSON(GLOSSARY_ENABLED_KEY, false)===true);
    glSwitch.addEventListener('click',()=> setGlUI(!(glSwitch.classList.contains('on'))));

    // Glossary wire-up
    buildGlossaryTable();
    wrap.querySelector('#glImport').addEventListener('click',()=>wrap.querySelector('#glFile').click());
    wrap.querySelector('#glFile').addEventListener('change', async (e)=>{
      const file=e.target.files?.[0]; if(!file) return;
      try{
        const txt=await file.text();
        const list = parseTermsFromCSVorTMX(txt, file.name);
        const prev = readJSON(GLOSSARY_KEY, defGlossary);
        writeJSON(GLOSSARY_KEY, prev.concat(list));
        buildGlossaryTable(); showToast(`Imported ${list.length} terms`);
      }catch(err){ console.error(err); showToast('Failed to import glossary') }
      e.target.value='';
    });
    wrap.querySelector('#glClear').addEventListener('click',()=>{ writeJSON(GLOSSARY_KEY,defGlossary()); buildGlossaryTable(); });
    wrap.querySelector('#glAdd').addEventListener('click',()=>{ const cur=readJSON(GLOSSARY_KEY,defGlossary); cur.push({src:'',tgt:'',flags:{lock:true,case:'auto'},notes:''}); writeJSON(GLOSSARY_KEY,cur); buildGlossaryTable(true); });

    // Saved sidebars (both panes)
    setupPhrasebookSidebars();

    // initial layout
    adjustPbWrapGrid();
    buildGlossaryTable(); // Build glossary table on initial load
  }
  function openAdvancedOverlay(){
    const ov=document.getElementById('advOverlay'); if(!ov) return;
    ov.classList.add('show'); ov.setAttribute('aria-hidden','false');
    const onKey=e=>{if(e.key==='Escape'){ ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',onKey); }};
    document.addEventListener('keydown',onKey);
    renderSavedPhrasebookAll();
    buildGlossaryTable(); // Ensure glossary table is built when overlay opens
    
    // Check which tab is currently active and set up the appropriate state
    const activeTab = ov.querySelector('.adv-tab.active');
    const isPhrasebookActive = activeTab && activeTab.getAttribute('data-pane') === 'advPhrasebook';
    
    if(isPhrasebookActive) {
      // If Phrasebook tab is active, show its sidebar and set 2-column layout
      ov.querySelectorAll('#advGlossary .pb-saved').forEach(x=>x.classList.add('is-hidden'));
      ov.querySelectorAll('#advPhrasebook .pb-saved').forEach(x=>x.classList.remove('is-hidden'));
      ov.querySelectorAll('#advPhrasebook .pb-wrap').forEach(w=>w.setAttribute('data-cols','2'));
    } else {
      // If Glossary tab is active (default), hide all sidebars and set single column
      ov.querySelectorAll('.pb-saved').forEach(x=>x.classList.add('is-hidden'));
      ov.querySelectorAll('.pb-wrap').forEach(w=>w.setAttribute('data-cols','1'));
    }
  }

  /* ---------- Glossary table ---------- */
  function buildGlossaryTable(focusLast=false){
    const tb=document.querySelector('#glTable tbody'); if(!tb) return;
    const rows=readJSON(GLOSSARY_KEY, defGlossary);
    tb.innerHTML = rows.length ? '' : `<tr><td colspan="5" class="pb-empty">No glossary terms yet</td></tr>`;
    rows.forEach((row,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td><input data-k="src" data-i="${i}" type="text" placeholder="Source term" value="${escapeHTML(row.src||'')}"></td>
        <td><input data-k="tgt" data-i="${i}" type="text" placeholder="Preferred translation" value="${escapeHTML(row.tgt||'')}"></td>
        <td>
          <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
            <select data-k="case" data-i="${i}">
              <option value="auto"${(row.flags?.case||'auto')==='auto'?' selected':''}>case:auto</option>
              <option value="exact"${(row.flags?.case||'auto')==='exact'?' selected':''}>case:exact</option>
              <option value="lower"${(row.flags?.case||'auto')==='lower'?' selected':''}>case:lower</option>
              <option value="upper"${(row.flags?.case||'auto')==='upper'?' selected':''}>case:upper</option>
              <option value="title"${(row.flags?.case||'auto')==='title'?' selected':''}>case:title</option>
            </select>
            <label style="display:inline-flex;gap:6px;align-items:center;font-size:12px">
              <input type="checkbox" data-k="lock" data-i="${i}" ${row.flags?.lock!==false?'checked':''}> lock
            </label>
          </div>
        </td>
        <td><input data-k="notes" data-i="${i}" type="text" placeholder="Notes" value="${escapeHTML(row.notes||'')}"></td>
        <td style="text-align:right;white-space:nowrap">
          <button class="gl-row-del" data-i="${i}" title="Remove this term" aria-label="Remove row">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="3 6 5 6 21 6"/>
              <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2l-1-14"/>
              <path d="M10 11v6M14 11v6"/>
              <path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/>
            </svg>
          </button>
        </td>
      `;
      tb.appendChild(tr);
    });
    const save = ()=>{
      const cur = readJSON(GLOSSARY_KEY, defGlossary);
      tb.querySelectorAll('input,select').forEach(el=>{
        const i=Number(el.dataset.i), k=el.dataset.k;
        if(!Number.isFinite(i)||!cur[i]) return;
        if(k==='src'||k==='tgt'||k==='notes') cur[i][k]=el.value;
        if(k==='case'){cur[i].flags=cur[i].flags||{}; cur[i].flags.case=el.value;}
        if(k==='lock'){cur[i].flags=cur[i].flags||{}; cur[i].flags.lock=el.checked;}
      });
      writeJSON(GLOSSARY_KEY,cur);
      const stat=document.getElementById('glStats'); if(stat) stat.textContent = `${cur.length} term${cur.length!==1?'s':''}`;
    };
    tb.querySelectorAll('input,select').forEach(el=>el.addEventListener('input',debounce(save,150)));
    tb.querySelectorAll('.gl-row-del').forEach(btn=>btn.addEventListener('click', e=>{
      const idx = Number(e.currentTarget.getAttribute('data-i'));
      const cur = readJSON(GLOSSARY_KEY, defGlossary);
      if(Number.isFinite(idx) && cur[idx]){
        cur.splice(idx,1);
        writeJSON(GLOSSARY_KEY, cur);
        buildGlossaryTable();
      }
    }));
    const stat=document.getElementById('glStats'); if(stat) stat.textContent = `${rows.length} term${rows.length!==1?'s':''}`;
    if(focusLast){
      const last=tb.querySelector('tr:last-child input[data-k="src"]'); last?.focus();
    }

    // reflect enabled state visually on first build
    const enabled = readJSON(GLOSSARY_ENABLED_KEY, false)===true;
    document.getElementById('glTableHost')?.classList.toggle('is-disabled', !enabled);
  }

  /* ---------- CSV/TMX parsers (used by Glossary import) ---------- */
  function detectDelim(s){ return s.includes('\t') ? '\t' : ','; }
  function splitRow(line, delim){
    let out=[], cur='', q=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(q){
        if(ch==='"' && line[i+1]==='"'){ cur+='"'; i++; }
        else if(ch==='"'){ q=false; }
        else { cur+=ch; }
      }else{
        if(ch==='"'){ q=true; }
        else if(ch===delim){ out.push(cur); cur=''; }
        else { cur+=ch; }
      }
    }
    out.push(cur);
    return out.map(x=>x.trim());
  }
  function parsePairsCSVorTSV(text){
    const lines=String(text||'').split(/\r?\n/).filter(l=>l.trim().length);
    if(!lines.length) return [];
    const delim=detectDelim(lines[0]);
    const out=[];
    for(const line of lines){
      const cols=splitRow(line,delim);
      if(cols.length<2) continue;
      out.push({src:cols[0], tgt:cols[1], notes:cols[2]||''});
    }
    return out;
  }
  function parseTermsFromCSVorTMX(text, name){
    const fn=(name||'').toLowerCase();
    if(fn.endsWith('.tmx')){
      const pairs=[];
      const tuBlocks=String(text||'').split(/<\/tu>/i);
      for(const tu of tuBlocks){
        const segs = Array.from(tu.matchAll(/<tuv[^>]*?>\s*<seg>([\s\S]*?)<\/seg>\s*<\/tuv>/gi)).map(m=>m[1].replace(/<[^>]+>/g,'').trim());
        if(segs.length>=2){ pairs.push({src:segs[0], tgt:segs[1], flags:{lock:true,case:'auto'}, notes:''}); }
      }
      return pairs;
    }
    const rows=parsePairsCSVorTSV(text);
    return rows.map(r=>({src:r.src,tgt:r.tgt,flags:{lock:true,case:'auto'},notes:r.notes||''}));
  }
  /* ---------- Compose injections (Brand + Glossary only) ---------- */
  function composeInjections(){
    const brand = readJSON(BRAND_KEY, defBrand);
    const glossary = readJSON(GLOSSARY_KEY, defGlossary);
    const glossaryEnabled = readJSON(GLOSSARY_ENABLED_KEY, false)===true;
    const brandEnabled = readJSON('brandEnabled:v1', false) === true;

    const parts=[];
    // Brand
    const tone = (brand.tone||[]).filter(Boolean).join(', ');
    const name = (brand.name||'').trim();
    if(brandEnabled && (tone || brand.audience || brand.doList || brand.dontList || brand.examples || name)){
      parts.push(`[BRAND VOICE â€” MANDATORY RULES]
${name?`Brand: ${name}\n`:''}${tone?`Tone (apply consistently): ${tone}\n`:''}${brand.audience?`Audience (write for them): ${brand.audience}\n`:''}${brand.doList?`MUST DO:\n- ${String(brand.doList).replace(/\r?\n/g,'\n- ')}\n`:''}${brand.dontList?`DO NOT:\n- ${String(brand.dontList).replace(/\r?\n/g,'\n- ')}\n`:''}${brand.examples?`STYLE EXAMPLES (imitate voice, not wording):\n${brand.examples}\n`:''}Deviations from BRAND VOICE are errors unless they conflict with locked glossary terms.`.trim());
    }

    // Glossary (capped + only if enabled)
    if(glossaryEnabled){
      const TERMS_CAP = 500;
      const gl = (glossary||[]).filter(r=>r && (r.src||'').trim()).slice(0,TERMS_CAP);
      if(gl.length){
        const lines=gl.map(r=>{
          const src = r.src.trim();
          const tgt = (r.tgt||'').trim();
          const flags = r.flags||{};
          const f = [
            flags.lock!==false ? 'lock' : '',
            flags.case && flags.case!=='auto' ? `case:${flags.case}` : ''
          ].filter(Boolean).join('; ');
          return `${JSON.stringify(src)} => ${JSON.stringify(tgt)}${f?` [${f}]`:''}${r.notes?` // ${r.notes}`:''}`;
        });
        parts.push(`[GLOSSARY RULES]
- Treat mappings as preferred terms. If "lock" is set, use the target exactly.
- If target is empty and "lock" is set, keep the source term untranslated.
- Respect case hints (case:exact|lower|upper|title).
${lines.join('\n')}`);
      }
    }

    return parts.join('\n\n').trim();
  }

  /* ---------- Override runTextDoc/runSrtDoc to send injections ---------- */
  async function runTextDoc(d){
    const input=(d.text||'').trim();
    const srcSegs = segmentText(input);
    if(!srcSegs.length){ d.output=''; d.lastAlignedTgt=[]; return; }

    const injections = composeInjections();
    // Add authentication headers
    const headers = {'Content-Type':'application/json'};
    const token = localStorage.getItem('authToken');
    const guestId = localStorage.getItem('guestId');
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    } else if (guestId) {
      headers['X-Guest-ID'] = guestId;
    }
    
    setStatus('Localizing');
    const user = JSON.parse(localStorage.getItem('user')||'{}');
    const tierNow = String(user?.tier||'free').toLowerCase();
    const allowPro = (tierNow==='business' || tierNow==='pro') && !!$('#maxToggle')?.classList.contains('active');
    
    const res=await fetch('/api/translate',{
      method:'POST',
      headers: { ...headers, 'Cache-Control':'no-store' },
      body:JSON.stringify({
        text: input,
        mode:selectedMode,
        targetLanguage: rephrase ? '' : targetLanguage,
        subStyle:selectedSubStyle,
        rephrase: !!rephrase,
        injections,
        allowPro
      })
    });
    if(!res.ok) throw new Error('HTTP '+res.status);
    const data=await res.json();
    d.output = String(data.result||'');
    setStatus('Localizing done');
    
    // Refresh usage after successful submission (small delay to ensure backend processing is complete)
    setTimeout(() => { if (window.updateCumulativeUsage) window.updateCumulativeUsage(); }, 100);
    if($('#outputRich') && !$('#outputRich').classList.contains('is-hidden')){
      $('#outputRich').textContent = d.output; syncRichToHidden();
    }else{
      $('#outputText').value=d.output; autosizeTextarea($('#outputText'));
    }
    applyContentDirection();
    // Persist recall payload for this run (session-only)
    try{ const entry = makeHistoryEntryFromDoc(d); pushHistory(entry); }catch{}
    if(splitView) renderSegmentBoxes(d);
    updateSplitButton();
  }

  async function runSrtDoc(d){
    const items = (d.cues?.length?d.cues.map(c=>c.text):(d.text||'').split(/\r?\n/)).map(v=>(v||'').trim());
    const hasAny = items.some(v=>v.length);
    if(!hasAny){ d.output=''; d.srtTranslations = new Array(items.length).fill(''); return; }
    
    console.log('[SRT Translation] Starting translation for:', {
      itemCount: items.length,
      firstThreeInputs: items.slice(0, 3),
      docName: d.name
    });

    const injections = composeInjections();
              // Add authentication headers
          const headers = {'Content-Type':'application/json'};
          const token = localStorage.getItem('authToken');
          const guestId = localStorage.getItem('guestId');
          
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
          } else if (guestId) {
            headers['X-Guest-ID'] = guestId;
          }
          const user = JSON.parse(localStorage.getItem('user')||'{}');
          const tierNow = String(user?.tier||'free').toLowerCase();
          const allowPro = (tierNow==='business' || tierNow==='pro') && !!$('#maxToggle')?.classList.contains('active');
          
          // Fresh idempotency key per request (scoped); also attach a stable device id
          const idem = `idem_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          let deviceId = localStorage.getItem('device_id_v1');
          if(!deviceId){ deviceId = `dev_${Date.now()}_${Math.random().toString(36).slice(2)}`; localStorage.setItem('device_id_v1', deviceId); }
          const res = await fetch('/api/translate-batch',{
            method:'POST',
            headers: { ...headers, 'Cache-Control':'no-store', 'Idempotency-Key': `POST:/api/translate-batch:${idem}`, 'X-Device-ID': deviceId },
            body:JSON.stringify({
              items,
              mode:selectedMode,
              targetLanguage: rephrase ? '' : targetLanguage,
              subStyle:selectedSubStyle,
              rephrase: !!rephrase,
              injections,
              allowPro
            })
          });
    if(!res.ok) throw new Error('HTTP '+res.status);
    const data = await res.json();
    console.log('[SRT Translation] Response received:', {
      itemCount: data.items?.length,
      firstThree: data.items?.slice(0, 3),
      engines: res.headers.get('X-Engines-Used'),
      models: res.headers.get('X-Models-Used')
    });
    d.srtTranslations = Array.isArray(data.items)? data.items : items;
    console.log('[SRT Translation] Setting UI with translations:', {
      translationCount: d.srtTranslations.length,
      firstThree: d.srtTranslations.slice(0, 3),
      docName: d.name
    });
    setStatus('Localizing done');
    
    // Refresh usage after successful SRT translation (small delay to ensure backend processing is complete)
    setTimeout(() => { if (window.updateCumulativeUsage) window.updateCumulativeUsage(); }, 100);
    
    d.output = d.srtTranslations.join('\n');
    $('#outputText').value = d.output;
    console.log('[SRT Translation] Updated outputText with:', $('#outputText').value.slice(0, 100));
    autosizeTextarea($('#outputText'));
    applyContentDirection();
    if(splitView) renderSrtBoxes(d);
    try{ const entry = makeHistoryEntryFromDoc(d); pushHistory(entry); }catch{}
    updateSplitButton();
  }

  /* ---------- Phrasebook (server-backed "Saved") ---------- */
  async function pbAPI(path, method='GET', body=null){
    const headers={'Content-Type':'application/json','Cache-Control':'no-cache'};
    const token = localStorage.getItem('authToken');
    const guestId = localStorage.getItem('guestId');
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    } else if (guestId) {
      headers['X-Guest-ID'] = guestId;
    }
    const res = await fetch(path,{method,headers,body:body?JSON.stringify(body):undefined});
    if(!res.ok){
      let detail='';
      try{ detail = await res.text(); }catch{}
      console.error('Phrasebook API failure', method, path, res.status, detail);
      throw new Error('PB '+res.status);
    }
    return await res.json();
  }
  // Cache for phrasebook data to reduce server calls
  let phrasebookCache = null;
  let lastCacheTime = 0;
  const CACHE_DURATION = 1000; // 1 second cache
  
  async function pbLoad(forceRefresh = false){ 
    const now = Date.now();
    
    // Use cache if recent and not forcing refresh
    if (!forceRefresh && phrasebookCache && (now - lastCacheTime) < CACHE_DURATION) {
      console.log('ðŸ“š Using cached phrasebook data');
      return phrasebookCache;
    }
    
    try {
      const data = await pbAPI('/api/phrasebook','GET'); 
      const items = Array.isArray(data.items) ? data.items : [];
      
      // Update cache
      phrasebookCache = items;
      lastCacheTime = now;
      
      console.log('ðŸ“š Fresh phrasebook data loaded:', items.length, 'items');
      return items;
    } catch (error) {
      console.error('Failed to load phrasebook:', error);
      // Return cached data if available
      return phrasebookCache || [];
    }
  }
  async function pbAdd(item){ 
    // Optimistic insert for instant UI
    try {
      const optimisticId = item.id || ('pb_'+Date.now().toString(36)+Math.random().toString(36).slice(2));
      const optimisticItem = { ...item, id: optimisticId, createdAt: item.createdAt || Date.now() };
      if (!Array.isArray(phrasebookCache)) phrasebookCache = [];
      phrasebookCache.unshift(optimisticItem);
      lastCacheTime = Date.now();
      renderSavedPhrasebookAll(); // instant

      // Persist in background
      await pbAPI('/api/phrasebook/add','POST',{ item: optimisticItem }); 
      console.log('ðŸ“š Added to phrasebook:', optimisticItem.srcText, 'â†’', optimisticItem.tgtText);

      // Reconcile with server truth (dedupe by id)
      const serverItems = await pbLoad(true);
      const seen = new Set();
      const merged = [...serverItems, ...phrasebookCache].filter(it=>{
        const key = String(it.id||'') || `${(it.srcText||'').toLowerCase()}|${(it.tgtText||'').toLowerCase()}`;
        if(seen.has(key)) return false; seen.add(key); return true;
      }).sort((a,b)=> (b.createdAt||0)-(a.createdAt||0));
      phrasebookCache = merged; lastCacheTime = Date.now();
      renderSavedPhrasebookAll();
    } catch (error) {
      console.error('Failed to add to phrasebook:', error);
      // Rollback optimistic insert if it failed
      if (phrasebookCache && item?.id) {
        phrasebookCache = phrasebookCache.filter(x=>String(x.id)!==String(item.id));
        renderSavedPhrasebookAll();
      }
      throw error;
    }
  }
  // Lightweight language detector for display purposes only
  function detectLanguageName(text){
    const s = String(text||'').trim(); if(!s) return '';
    // Fast path: Scripts with unique Unicode blocks
    if(/[\u4E00-\u9FFF]/.test(s)) return 'Chinese';           // Han
    if(/[\u3040-\u30FF]/.test(s)) return 'Japanese';           // Hiragana/Katakana
    if(/[\uAC00-\uD7AF]/.test(s)) return 'Korean';             // Hangul
    if(/[\u0400-\u04FF]/.test(s)) return 'Cyrillic';           // Russian/Ukrainian/Bulgarian
    if(/[\u0600-\u06FF]/.test(s)) return 'Arabic';             // Arabic/Persian/Urdu
    if(/[\u0590-\u05FF]/.test(s)) return 'Hebrew';
    if(/[\u0370-\u03FF]/.test(s)) return 'Greek';
    if(/[\u0900-\u097F]/.test(s)) return 'Hindi';              // Devanagari
    if(/[\u0980-\u09FF]/.test(s)) return 'Bengali';
    if(/[\u0A00-\u0A7F]/.test(s)) return 'Punjabi';            // Gurmukhi
    if(/[\u0A80-\u0AFF]/.test(s)) return 'Gujarati';
    if(/[\u0B00-\u0B7F]/.test(s)) return 'Odia';
    if(/[\u0B80-\u0BFF]/.test(s)) return 'Tamil';
    if(/[\u0C00-\u0C7F]/.test(s)) return 'Telugu';
    if(/[\u0C80-\u0CFF]/.test(s)) return 'Kannada';
    if(/[\u0D00-\u0D7F]/.test(s)) return 'Malayalam';
    if(/[\u0D80-\u0DFF]/.test(s)) return 'Sinhala';
    if(/[\u0E00-\u0E7F]/.test(s)) return 'Thai';
    if(/[\u0E80-\u0EFF]/.test(s)) return 'Lao';
    if(/[\u1780-\u17FF]/.test(s)) return 'Khmer';
    if(/[\u10A0-\u10FF]/.test(s)) return 'Georgian';
    if(/[\u0530-\u058F]/.test(s)) return 'Armenian';

    // Latin-based heuristics (order matters; use strong, unique signals first)
    const lower = s.toLowerCase();

    // Turkish (very distinctive)
    if(/[ÄŸÃ¼ÅŸÃ¶Ã§Ä±Ä°]/i.test(s)) return 'Turkish';

    // Polish
    if(/[Ä…Ä‡Ä™Å‚Å„Ã³Å›ÅºÅ¼]/i.test(s)) return 'Polish';

    // Czech / Slovak (diacritics sets)
    if(/[Ä›Å¡ÄÅ™Å¾Å¯ÄÅ¥Åˆ]/i.test(s)) return 'Czech';
    if(/[Ã¡Ã¤ÄÄÃ©Ã­Ä¾ÄºÅˆÃ³Ã´Å•Å¡Å¥ÃºÃ½Å¾]/i.test(s)) return 'Slovak';

    // Romanian
    if(/[ÄƒÃ¢Ã®È™ÅŸÅ£È›]/i.test(s)) return 'Romanian';

    // Portuguese (check before Spanish/French)
    if(/[Ã£Ãµ]/.test(lower) || /(Ã§Ã£o|Ã§Ãµes|Ãµes|Ã§Ã£o)/i.test(lower)) return 'Portuguese';
    if(/\b(nÃ£o|vocÃª|vocÃªs|estÃ¡|estÃ£o|tambÃ©m|porque|pois|pra|para|como|pode|ser|nÃ£o)\b/.test(lower)) return 'Portuguese';

    // Spanish
    if(/[Ã±Â¡Â¿]/.test(lower) || /\b(que|para|como|estÃ¡|estÃ¡s|estÃ¡n|pero|porque|gracias)\b/.test(lower)) return 'Spanish';

    // French (avoid over-triggering on Ã§ which appears in PT)
    if(/[Ã Ã¢Ã¦Ã§Ã©Ã¨ÃªÃ«Ã®Ã¯Ã´Å“Ã¹Ã»Ã¼Ã¿]/i.test(s) || /\b(avec|pour|sans|mais|merci)\b/.test(lower)) return 'French';

    // German
    if(/[Ã¤Ã¶Ã¼ÃŸ]/i.test(s) || /\b(und|der|die|das|nicht|ich|danke|bitte|sein|mit)\b/.test(lower)) return 'German';

    // Italian
    if(/[Ã Ã¨Ã©Ã¬Ã²Ã¹]/i.test(s) || /\b(che|per|non|sono|grazie|ciao|questo|questa|con|una|uno)\b/.test(lower)) return 'Italian';

    // Dutch
    if(/\b(het|een|en|wij|jij|zijn|hebben|geen|met|voor)\b/.test(lower)) return 'Dutch';

    // Hungarian
    if(/[Å‘Å±]/i.test(s)) return 'Hungarian';

    // Scandinavian (rough grouping)
    if(/[Ã¸Ã¦Ã¥]/i.test(s)) return 'Norwegian/Danish';
    if(/[Ã¥Ã¤Ã¶]/i.test(s)) return 'Swedish';

    // Vietnamese
    if(/[ÄƒÃ¢ÃªÃ´Æ¡Æ°Ä‘]/i.test(s)) return 'Vietnamese';

    // Indonesian / Malay
    const indoHits = (lower.match(/\b(yang|dan|tidak|itu|ini|atau|dengan|untuk|saya|kamu|kami|anda)\b/g)||[]).length;
    if(indoHits>=2) return 'Bahasa';

    // English
    const engHits = (lower.match(/\b(the|and|you|are|is|to|of|in|for|with)\b/g)||[]).length;
    if(engHits>=2) return 'English';

    return '';
  }
  async function pbDelete(id){ 
    try {
      console.log('ðŸ“š Starting delete for ID:', id);
      
      // Call server delete API
      await pbAPI('/api/phrasebook/delete','POST',{ id }); 
      console.log('ðŸ“š Server delete successful for:', id);
      
      // Force cache refresh and UI update
      phrasebookCache = null;
      lastCacheTime = 0;
      
      // Immediate UI refresh with fresh server data
      await pbLoad(true);
      await renderSavedPhrasebookAll();
      
      console.log('ðŸ“š Phrasebook delete completed - UI updated');
      window.showNotification('Removed', 'Phrase deleted from library', 'success');
      
    } catch (error) {
      console.error('Failed to delete from phrasebook:', error);
      window.showNotification('Delete Failed', 'Could not remove phrase', 'error');
      throw error;
    }
  }

  // Render helpers for multiple sidebars (Glossary + Phrasebook)
  function setupPhrasebookSidebars(){
    document.querySelectorAll('.pb-saved').forEach(box=>{
      const s=box.querySelector('.pb-search');
      const o=box.querySelector('.pb-sort');
      const c=box.querySelector('.pb-clear');
      s?.addEventListener('input',()=>renderSavedPhrasebook(box));
      o?.addEventListener('change',()=>renderSavedPhrasebook(box));
      c?.addEventListener('click', async ()=>{
        try{
          const items = await pbLoad(true);
          for(const it of (items||[])){
            if(it?.id) await pbDelete(it.id);
          }
          phrasebookCache = [];
          lastCacheTime = Date.now();
          await renderSavedPhrasebookAll();
          window.showNotification && window.showNotification('Cleared', 'All saved phrases removed', 'success');
        }catch(e){ console.error('Clear all failed', e); window.showNotification && window.showNotification('Clear failed','Could not remove all','error'); }
      });
    });
    renderSavedPhrasebookAll();
  }
  async function renderSavedPhrasebookAll(){
    const all = Array.from(document.querySelectorAll('.pb-saved'));
    await Promise.all(all.map(box=>renderSavedPhrasebook(box)));
  }
  async function renderSavedPhrasebook(hostBox){
    const host = hostBox || document.querySelector('.pb-saved'); if(!host) return;
    const listEl = host.querySelector('.pb-list'); if(!listEl) return;
    const q = (host.querySelector('.pb-search')?.value||'').toLowerCase();
    const sort = (host.querySelector('.pb-sort')?.value)||'new';

    let items=[];
    try{ 
      items = await pbLoad(); 
      console.log('ðŸ“š Phrasebook rendered:', items.length, 'items');
    }catch(e){ 
      console.error('Phrasebook load error:', e); 
      items = []; // Fallback to empty array
    }

    items = items.filter(it=>{
      if(!q) return true;
      const s = `${it.srcText} ${it.tgtText} ${it.srcLang} ${it.tgtLang}`.toLowerCase();
      return s.includes(q);
    });
    items.sort((a,b)=>{
      if(sort==='new') return (b.createdAt||0)-(a.createdAt||0);
      if(sort==='old') return (a.createdAt||0)-(b.createdAt||0);
      const A=(a.tgtText||'').toLowerCase(), B=(b.tgtText||'').toLowerCase();
      if(sort==='az') return A.localeCompare(B);
      if(sort==='za') return B.localeCompare(A);
      return 0;
    });

    if(!items.length){ listEl.innerHTML = `<div class="pb-empty">Nothing saved yet. Select text in the Result and click "Save to Phrasebook".</div>`; return; }

    listEl.innerHTML = items.map(it=>{
      const dir = `${escapeHTML('Auto')} â†’ ${escapeHTML(it.tgtLang||'')}`;
      const when = new Date(it.createdAt||Date.now()).toLocaleString();
      return `<div class="pb-item" data-id="${it.id}">
        <div style="min-width:0">
          <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHTML(it.tgtText||'')}</div>
          <div class="pb-meta" title="${escapeHTML(it.srcText||'')}">${escapeHTML(it.srcText||'')}</div>
          <div class="pb-meta">${dir} Â· ${when}</div>
        </div>
        <button class="pb-star" title="Remove" aria-label="Remove">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <polyline points="3 6 5 6 21 6"/>
            <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2l-1-14"/>
            <path d="M10 11v6M14 11v6"/>
            <path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
      </div>`;
    }).join('');

    listEl.querySelectorAll('.pb-item .pb-star').forEach(btn=>{
      btn.addEventListener('click',async (e)=>{
        e.preventDefault();
        e.stopPropagation();
        
        const itemElement = e.currentTarget.closest('.pb-item');
        const id = itemElement?.dataset?.id;
        
        if(!id) {
          console.error('ðŸ“š No ID found for delete button');
          return;
        }
        
        console.log('ðŸ“š Delete button clicked for ID:', id);
        
        // Optimistic UI: remove immediately
        if (phrasebookCache) {
          phrasebookCache = phrasebookCache.filter(x=>String(x.id)!==String(id));
        }
        itemElement?.remove();
        
        // Keep list tidy while server call happens
        if (listEl.childElementCount===0) {
          renderSavedPhrasebook(host);
        }
        
        try{ 
          await pbDelete(id); 
          console.log('ðŸ“š Delete operation completed successfully');
        }catch(error){
          // On failure, force reload
          await pbLoad(true);
          await renderSavedPhrasebookAll();
          console.error('Delete failed:', error);
        }
      });
    });
  }

  /* ---------- Save-selection bubble (instant show, refine in background) ---------- */
  let saveBubble=null, saveBubbleHideT=null;
  function ensureSaveBubble(){
    if(saveBubble) return saveBubble;
    const el=document.createElement('div');
    el.className='save-bubble';
    el.innerHTML=`<span class="ok">Saved âœ“</span><span class="label">Save to Phrasebook</span><button class="act">Add</button>`;
    document.body.appendChild(el);
    el.querySelector('.act').addEventListener('click', onSaveBubbleCommitFast);
    // Avoid native context menu overlapping our bubble
    el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
    // Restructure: wrap label + ok inside a fixed-width container to prevent jump
    try{
      const ok = el.querySelector('.ok');
      const lab = el.querySelector('.label');
      if(ok && lab && !el.querySelector('.left')){
        try{ ok.textContent = 'Saved âœ“'; }catch{}
        // Measure current label width before moving nodes
        let w0 = 0; try{ w0 = Math.ceil(lab.getBoundingClientRect().width); }catch{}
        const left = document.createElement('span');
        left.className = 'left';
        el.insertBefore(left, lab);
        left.appendChild(lab);
        left.appendChild(ok);
        // Fix width so bubble doesn't jump when switching to Saved
        const w = w0 || Math.ceil(lab.getBoundingClientRect().width);
        left.style.minWidth = w + 'px';
        left.style.width = w + 'px';
      }
    }catch{}
    return (saveBubble=el);
  }
  function clamp(n,lo,hi){ return Math.max(lo, Math.min(hi, n)); }
  // Measure text width using the font metrics of a reference element
  function measureTextWidthEl(refEl, text){
    try{
      const tmp = document.createElement('span');
      const cs = window.getComputedStyle(refEl || document.body);
      tmp.textContent = text || '';
      tmp.style.position='absolute'; tmp.style.visibility='hidden'; tmp.style.whiteSpace='nowrap';
      tmp.style.font = cs.font; tmp.style.letterSpacing = cs.letterSpacing; tmp.style.fontWeight = cs.fontWeight;
      document.body.appendChild(tmp);
      const w = Math.ceil(tmp.getBoundingClientRect().width);
      tmp.remove();
      return w || 0;
    }catch{ return 0; }
  }
  function placeBubbleAtRect(r){
    const vpTop = window.scrollY;
    const centerX = window.scrollX + r.left + r.width/2;
    const x = clamp(centerX, 60, document.documentElement.clientWidth - 60);
    const roomAbove = r.top;
    const top = (roomAbove > 64) ? (vpTop + r.top - 10) : (vpTop + r.bottom + 10);
    return { x, y: top };
  }
  function showSaveBubbleAtRect(r, payload){
    ensureSaveBubble();
    saveBubble.dataset.payload = JSON.stringify(payload||{});
    const pos = placeBubbleAtRect(r);
    saveBubble.style.left = pos.x+'px';
    saveBubble.style.top = pos.y+'px';
    saveBubble.classList.remove('saved');
    // Ensure correct glyph and widths on each show
    try{
      const left = saveBubble.querySelector('.left') || saveBubble;
      const lab = saveBubble.querySelector('.label');
      const ok = saveBubble.querySelector('.ok');
      if(ok) ok.textContent = 'Saved \u2713';
      if(lab){
        const wLabel = measureTextWidthEl(lab, lab.textContent||'');
        const wSaved = measureTextWidthEl(lab, (ok?.textContent)||'Saved \u2713');
        if(left && wLabel){ left.style.minWidth = wLabel+'px'; left.style.width = wLabel+'px'; }
        saveBubble.dataset.labelw = String(wLabel);
        saveBubble.dataset.savedw = String(wSaved||Math.max(40, wLabel*0.5));
      }
    }catch{}
    saveBubble.classList.add('show');
    clearTimeout(saveBubbleHideT);
    saveBubbleHideT = setTimeout(()=>{ saveBubble.classList.remove('show'); }, 3000);
  }
  async function onSaveBubbleCommit(){
    if(!saveBubble) return;
    const data = JSON.parse(saveBubble.dataset.payload||'{}');
    try{
      await pbAdd({
        id:'pb_'+Date.now().toString(36)+Math.random().toString(36).slice(2),
        srcLang: 'Auto',
        tgtLang: data.tgtLang || (targetLanguage || ''),
        srcText: data.srcText || '',
        tgtText: data.tgtText || '',
        createdAt: Date.now()
      });
      saveBubble.classList.add('saved');
      // Animate compact width for "Saved" state
      try{
        const left = saveBubble.querySelector('.left') || saveBubble;
        const okW = parseInt(saveBubble.dataset.savedw||'0',10);
        if(left && okW){ left.style.minWidth = okW+'px'; left.style.width = okW+'px'; }
      }catch{}
      // [removed] pbAdd() already performs optimistic insert and re-render
      /* if (phrasebookCache) {
        phrasebookCache.unshift({
          id: 'pb_' + Date.now().toString(36) + Math.random().toString(36).slice(2),
          srcLang: 'Auto',
          tgtLang: data.tgtLang || (targetLanguage || ''),
          srcText: data.srcText || '',
          tgtText: data.tgtText || '',
          createdAt: Date.now()
        });
        console.log('ðŸ“š Added to local cache for instant display');
      } */
      
      // Immediate UI update without waiting for server
      renderSavedPhrasebookAll();
      console.log('ðŸ“š Phrasebook UI updated instantly');
    }catch(e){ console.error(e); showToast('Failed to save phrase'); }
  }
  // Faster, optimistic version used by the bubble button
  function onSaveBubbleCommitFast(){
    if(!saveBubble) return;
    const data = JSON.parse(saveBubble.dataset.payload||'{}');
    // Optimistic UI: switch to saved state immediately and animate width
    try{
      saveBubble.classList.add('saved');
      const left = saveBubble.querySelector('.left') || saveBubble;
      const okW = parseInt(saveBubble.dataset.savedw||'0',10);
      if(left && okW){ left.style.minWidth = okW+'px'; left.style.width = okW+'px'; }
    }catch{}
    // Persist in background (pbAdd already updates the list optimistically)
    pbAdd({
      id:'pb_'+Date.now().toString(36)+Math.random().toString(36).slice(2),
      srcLang: 'Auto',
      tgtLang: data.tgtLang || (targetLanguage || ''),
      srcText: data.srcText || '',
      tgtText: data.tgtText || '',
      createdAt: Date.now()
    }).catch(e=>{
      console.error(e);
      if (typeof showToast==='function') showToast('Failed to save phrase');
      // Revert UI if save fails
      try{
        saveBubble.classList.remove('saved');
        const left = saveBubble.querySelector('.left') || saveBubble;
        const labW = parseInt(saveBubble.dataset.labelw||'0',10);
        if(left && labW){ left.style.minWidth = labW+'px'; left.style.width = labW+'px'; }
      }catch{}
    });
  }

  function currentTargetLangLabel(){
    const lang=localStorage.getItem('uiLang')||DEFAULT_LANG;
    const label = langLabel(targetLanguage||'') || targetLanguage || '';
    return label || (LANG_LABELS[lang]?.English || 'English');
  }

  // ---- Alignment-based source-span finder (exact word/phrase) ----
  async function alignSrcForSelection(srcSeg='', tgtSeg='', selectedTgt=''){
    try{
      if(!srcSeg || !tgtSeg || !selectedTgt) return srcSeg;
      const res = await fetch('/api/align',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ src:srcSeg, tgt:tgtSeg, srcLang:'auto', tgtLang: currentTargetLangLabel() })
      });
      if(!res.ok) return srcSeg;
      const pairs = await res.json(); // [{src,tgt}]
      const needle = String(selectedTgt).toLowerCase();
      let best = null;
      let bestScore = -1;

      for(const p of (pairs||[])){
        const tgt = String(p.tgt||'');
        const tgtLc = tgt.toLowerCase();
        if(!tgt) continue;
        const contains = tgtLc.includes(needle);
        const overlap = contains ? Math.min(needle.length, tgt.length) : 0;
        const lenPenalty = Math.abs(tgt.length - needle.length) * -0.25;
        const score = (contains ? 5 : 0) + overlap + lenPenalty;
        if(score > bestScore){ bestScore=score; best=p; }
      }
      return (best && best.src) ? String(best.src) : srcSeg;
    }catch{ return srcSeg; }
  }
  function getSelectionRect(){
    const sel=window.getSelection();
    if(!sel || sel.rangeCount===0) return null;
    const r=sel.getRangeAt(0).getBoundingClientRect();
    if(!r || (!r.width && !r.height)) return null;
    return r;
  }

  // Locate the segment index + texts for current doc based on a target selection
  function findSegForSelectionInDoc(selectedText){
    const d = currentDoc(); if(!d) return { idx:-1, srcSeg:'', tgtSeg:'' };
    const srcSegs = d.isSrt ? (d.cues?.map(c=>c.text)||[]) : segmentText(d.text||'');
    let tgtSegs;
    if(d.isSrt){
      tgtSegs = Array.isArray(d.srtTranslations)? d.srtTranslations.slice() : (d.output||'').split(/\r?\n/);
    }else{
      tgtSegs = Array.isArray(d.lastAlignedTgt)&&d.lastAlignedTgt.length? d.lastAlignedTgt.slice() : alignToSource(d.output||'', srcSegs.length);
    }
    const idx = tgtSegs.findIndex(seg => (seg||'').toLowerCase().includes(String(selectedText||'').toLowerCase()));
    const srcSeg = idx>=0 ? (srcSegs[idx]||'') : (d.text||'');
    const tgtSeg = idx>=0 ? (tgtSegs[idx]||'') : (d.output||'');
    return { idx, srcSeg, tgtSeg };
  }

  // Show bubble immediately, refine the payload when alignment returns
  function showNowThenRefine(rect, srcSeg, tgtSeg, txt){
    const initial = { tgtText:txt, srcText:srcSeg||'', srcLang: 'Auto', tgtLang: currentTargetLangLabel() };
    showSaveBubbleAtRect(rect, initial);
    alignSrcForSelection(srcSeg, tgtSeg, txt).then(refined=>{
      try{
        if(!saveBubble?.classList.contains('show')) return;
        const cur = JSON.parse(saveBubble.dataset.payload||'{}');
        // only update if the same selection is still active
        if((cur.tgtText||'')===txt){
          cur.srcText = refined || srcSeg || '';
          saveBubble.dataset.payload = JSON.stringify(cur);
        }
      }catch{}
    });
  }
  /* Wire selection listeners for: outputRich, outputText, split SRT & split non-SRT */
  function initSaveSelectionUI(){
    // Normal rich area
    const rich = document.getElementById('outputRich');
    if(rich){
      rich.addEventListener('mouseup', ()=>{
        const txt = (window.getSelection()?.toString()||'').trim();
        if(!txt) return;
        const r=getSelectionRect(); if(!r) return;
        const { srcSeg, tgtSeg } = findSegForSelectionInDoc(txt);
        showNowThenRefine(r, srcSeg, tgtSeg, txt);
      });
      // local prevention (still keep for safety)
      rich.addEventListener('contextmenu', e=> e.preventDefault());
    }

    // Fallback textarea
    const ta = document.getElementById('outputText');
    if(ta){
      ta.addEventListener('mouseup', ()=>{
        const s=ta.selectionStart, e=ta.selectionEnd;
        if(!ta.value || s===e) return;
        const txt = ta.value.slice(s,e).trim(); if(!txt) return;
        const { srcSeg, tgtSeg } = findSegForSelectionInDoc(txt);
        const rect = ta.getBoundingClientRect();
        const fakeRect = { left: rect.left + rect.width/2, width:0, top: rect.top + 10, bottom: rect.top + 22, height:12 };
        showNowThenRefine(fakeRect, srcSeg, tgtSeg, txt);
      });
      ta.addEventListener('contextmenu', e=> e.preventDefault());
    }

    // Split SRT textareas
    const split = document.getElementById('segTgtBox');
    if(split){
      split.addEventListener('mouseup', (e)=>{
        const el = e.target.closest('textarea[data-srt]'); if(!el) return;
        const s=el.selectionStart, oe=el.selectionEnd;
        if(s===oe) return;
        const txt = el.value.slice(s,oe).trim(); if(!txt) return;
        const idx = Number(el.getAttribute('data-srt')||0);
        const d=currentDoc(); if(!d) return;
        const srcTextSeg = (d.cues?.[idx]?.text) || '';
        const tgtSeg = el.value || '';
        const rect = el.getBoundingClientRect();
        const fakeRect = { left: rect.left + rect.width/2, width:0, top: rect.top + 6, bottom: rect.top + 18, height:12 };
        showNowThenRefine(fakeRect, srcTextSeg, tgtSeg, txt);
      });

      split.addEventListener('contextmenu', e=>{
        if(e.target.closest('textarea[data-srt]')) e.preventDefault();
      });
    }

    // Split non-SRT (plain divs)
    const tgtBox = document.getElementById('segTgtBox');
    if(tgtBox){
      tgtBox.addEventListener('mouseup', (e)=>{
        const txt = (window.getSelection()?.toString()||'').trim();
        if(!txt) return;
        let r=getSelectionRect();
        if(!r){
          // Fallback rect for non-text nodes in split view
          const el = e.target.closest('.segrow') || tgtBox;
          const rr = el.getBoundingClientRect();
          r = { left: rr.left + rr.width/2, width:0, top: rr.top + 6, bottom: rr.top + 18, height:12 };
        }
        const { srcSeg, tgtSeg } = findSegForSelectionInDoc(txt);
        showNowThenRefine(r, srcSeg, tgtSeg, txt);
      });

      tgtBox.addEventListener('contextmenu', e=> e.preventDefault());
    }

    // Global capture-level guard to suppress the Chrome context menu
    // Hardened: also checks the current selection's container
    document.addEventListener('contextmenu', (e)=>{
      try{
        const targetInZones = (
          e.target.closest('#outputRich') ||
          e.target.closest('#outputText') ||
          e.target.closest('#segTgtBox') ||
          e.target.matches('textarea[data-srt]')
        );
        let selectionInZones = false;
        const sel = window.getSelection && window.getSelection();
        if(sel && sel.rangeCount){
          const common = sel.getRangeAt(0).commonAncestorContainer;
          const el = (common && common.nodeType===1) ? common : common.parentElement;
          if(el){ selectionInZones = !!el.closest('#outputRich, #outputText, #segTgtBox, textarea[data-srt]'); }
        }
        if(targetInZones || selectionInZones){ e.preventDefault(); }
      }catch{}
    }, { capture:true });

    // Hide bubble on scroll or escape
    window.addEventListener('scroll', ()=>saveBubble?.classList.remove('show'), { passive:true });
    document.addEventListener('keydown', e=>{ if(e.key==='Escape') saveBubble?.classList.remove('show'); });
    document.addEventListener('click', e=>{
      if(saveBubble && !saveBubble.contains(e.target) && !e.target.closest('.save-bubble')) saveBubble.classList.remove('show');
    });
  }
  /* ---------- Tabs: enable drag-reorder ---------- */
  function initTabDnD(){
    const bar = document.getElementById('tabBar'); if(!bar) return;

    const setDraggable=()=>bar.querySelectorAll('.tab').forEach(el=>el.setAttribute('draggable','true'));
    setDraggable();
    new MutationObserver(setDraggable).observe(bar, { childList:true });

    let dragId=null;
    bar.addEventListener('dragstart',e=>{
      const t=e.target.closest('.tab'); if(!t) return;
      dragId=t.dataset.id; t.classList.add('dragging');
      e.dataTransfer.setData('text/plain', dragId);
      e.dataTransfer.effectAllowed='move';
    });
    bar.addEventListener('dragend',e=>{
      const t=e.target.closest('.tab'); if(t) t.classList.remove('dragging');
      bar.querySelectorAll('.drop-marker').forEach(x=>x.classList.remove('drop-marker'));
    });
    bar.addEventListener('dragover',e=>{
      if(!dragId) return;
      e.preventDefault();
      const over=e.target.closest('.tab'); if(!over || over.dataset.id===dragId) return;
      bar.querySelectorAll('.drop-marker').forEach(x=>x.classList.remove('drop-marker'));
      over.classList.add('drop-marker');
    });
    bar.addEventListener('drop',e=>{
      e.preventDefault();
      const over=e.target.closest('.tab'); if(!over) return;
      const targetId = over.dataset.id;
      bar.querySelectorAll('.drop-marker').forEach(x=>x.classList.remove('drop-marker'));
      if(!dragId || dragId===targetId) return;

      const from = docs.findIndex(d=>d.id===dragId);
      const to = docs.findIndex(d=>d.id===targetId);
      if(from<0 || to<0) return;
      const [moved]=docs.splice(from,1);
      docs.splice(to,0,moved);
      renderTabs(); // re-render reflect order
    });
  }
  /* ---------- Boot ---------- */
  document.addEventListener('DOMContentLoaded',()=>{
    // Usage mini dropdown handlers
    const usageMini = document.getElementById('usageMini');
    const usageMiniDropdown = document.getElementById('usageMiniDropdown');
    if (usageMini && usageMiniDropdown){
      const toggle = (expand)=>{
        const next = expand ?? usageMini.getAttribute('aria-expanded') !== 'true';
        usageMini.setAttribute('aria-expanded', String(next));
        usageMiniDropdown.setAttribute('aria-hidden', String(!next));
      };
      usageMini.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(); });
      usageMini.addEventListener('keydown', (e)=>{
        if (e.key==='Enter' || e.key===' ') { e.preventDefault(); toggle(); }
        if (e.key==='Escape') toggle(false);
      });
      document.addEventListener('click', (e)=>{ if (!usageMini.contains(e.target)) toggle(false); });
    }

    // Initial pull
    if (window.updateCumulativeUsage) window.updateCumulativeUsage();
    ensureGlobalUIStyles();
    injectBrandButton();
    injectAdvancedButton();
    initSaveSelectionUI();
    initTabDnD();
    
    // Initialize the original dropzone functionality (this was missing!)
    initDropzone();
    
    // Setup quick login button (development only) and prevent auto-login in production
    const isLocalHost = ['localhost','127.0.0.1','::1'].includes(location.hostname);
    const quickLoginBtn = document.getElementById('quickLoginBtn');
    const signInBtn = document.getElementById('signInBtn');
    const signOutBtnTop = document.getElementById('signOutBtnTop');
    const authModal = document.getElementById('authModal');
    const authClose = document.getElementById('authClose');
    const authForm = document.getElementById('authForm');
    const authName = document.getElementById('authName');
    const authEmail = document.getElementById('authEmail');
    const authPassword = document.getElementById('authPassword');
    const authMsg = document.getElementById('authMsg');
    const authTabLogin = document.getElementById('authTabLogin');
    const authTabRegister = document.getElementById('authTabRegister');

    // Quick login button only on localhost
    if (quickLoginBtn) {
      if (isLocalHost) {
        quickLoginBtn.style.display='';
        quickLoginBtn.addEventListener('click', async () => {
          try { await window.quickLogin(); }
          catch (error) { console.error('Login failed:', error); }
        });
      } else {
        quickLoginBtn.remove();
      }
    }

    function openAuth(mode){
      const isRegister = mode==='register';
      const authNameField = document.getElementById('authNameField');
      const authForm = document.getElementById('authForm');
      const checkEmailState = document.getElementById('checkEmailState');
      
      // Reset to form state
      authForm.style.display = '';
      checkEmailState.style.display = 'none';
      
      // Smooth transition for name field using CSS classes
      if (isRegister) {
        authNameField.classList.remove('hidden');
        authNameField.classList.add('visible');
      } else {
        authNameField.classList.remove('visible');
        authNameField.classList.add('hidden');
      }
      
      // Update tab states
      authTabLogin.classList.toggle('active', !isRegister);
      authTabRegister.classList.toggle('active', isRegister);
      
      // Update button and title
      authSubmit.textContent = isRegister ? 'Create account' : 'Sign in';
      document.querySelector('.modal-head h3').textContent = isRegister ? 'Create account' : 'Sign in';
      
      // Clear messages
      authMsg.textContent='';
      
      // Show modal
      authModal.style.display='flex';
      
      // Focus appropriate field with proper timing
      setTimeout(() => {
        if (isRegister) {
          authName.focus();
        } else {
          authEmail.focus();
        }
      }, isRegister ? 250 : 100); // Longer delay for register to allow field to appear
    }
    function closeAuth(){ authModal.style.display='none'; }
    if (signInBtn) signInBtn.addEventListener('click', async ()=>{
      try{
        openAuth('login');
      }catch(e){ console.error(e); }
    });

    // Google button inside modal
    const authGoogle = document.getElementById('authGoogle');
    if (authGoogle) authGoogle.addEventListener('click', async ()=>{
      try{
        // Close the auth modal before OAuth redirect
        closeAuth();
        
        const { data, error } = await supabase.auth.signInWithOAuth({ 
          provider: 'google', 
          options: { 
            redirectTo: window.location.origin,
            queryParams: {
              access_type: 'offline',
              prompt: 'consent'
            }
          }
        });
        if (error) throw error;
        
        console.log('OAuth initiated successfully');
      }catch(e){ 
        console.error('Google sign-in failed', e); 
        showToast('Google sign-in failed: ' + (e.message || e)); 
      }
    });
    if (authClose) authClose.addEventListener('click', closeAuth);
    if (authTabLogin) authTabLogin.addEventListener('click', ()=>openAuth('login'));
    if (authTabRegister) authTabRegister.addEventListener('click', ()=>openAuth('register'));
    
    // Back to login button from check email state
    const backToLogin = document.getElementById('backToLogin');
    if (backToLogin) backToLogin.addEventListener('click', ()=>openAuth('login'));

    function showCheckEmailState(email) {
      const authForm = document.getElementById('authForm');
      const checkEmailState = document.getElementById('checkEmailState');
      
      // Hide form and show check email state
      authForm.style.display = 'none';
      checkEmailState.style.display = '';
      
      // Update title
      document.querySelector('.modal-head h3').textContent = 'Check your email';
    }

    if (authForm) authForm.addEventListener('submit', async (e)=>{
      e.preventDefault();
      authMsg.textContent='';
      const email = authEmail.value.trim();
      const password = authPassword.value;
      const authNameField = document.getElementById('authNameField');
      const isRegister = authNameField.classList.contains('visible');
      const name = isRegister ? authName.value.trim() : undefined;
      
      try{
        if (isRegister) {
          // Sign up flow
          const { data, error } = await supabase.auth.signUp({ 
            email, 
            password, 
            options: { 
              data: { name, tier: 'free' } 
            } 
          });
          if (error) throw error;
          
          // Show check email state
          showCheckEmailState(email);
          
          // Auto-transition back to login after 3 seconds
          setTimeout(() => {
            openAuth('login');
          }, 3000);
        } else {
          // Sign in flow
          const { data, error } = await supabase.auth.signInWithPassword({ email, password });
          if (error) throw error;
          const confirmed = !!(data?.user?.email_confirmed_at || data?.user?.confirmed_at);
          if (!confirmed) {
            try { await supabase.auth.signOut(); } catch {}
            authMsg.textContent = 'Please confirm your email before signing in.';
            showCheckEmailState(email);
            return;
          }
          closeAuth();
          location.reload();
        }
      }catch(err){ 
        authMsg.textContent = err.message || String(err); 
      }
    });

    // ----- Settings: tokens, navigation, and actions -----
    async function fetchSettingsTokens(){
      try{
        const res = await fetch('/api/settings/tokens');
        const t = await res.json();
        if (t?.palette){
          const r = document.documentElement.style;
          if (t.palette.bg) r.setProperty('--bg', t.palette.bg);
          if (t.palette.card) r.setProperty('--card', t.palette.card);
          if (t.palette.text) r.setProperty('--text', t.palette.text);
          if (t.palette.muted) r.setProperty('--muted', t.palette.muted);
          if (t.palette.border) r.setProperty('--border', t.palette.border);
          if (t.palette.accent) r.setProperty('--accent', t.palette.accent);
          if (t.palette.accentWeak) r.setProperty('--accent-weak', t.palette.accentWeak);
        }
        if (t?.typography?.body?.size){
          document.documentElement.style.setProperty('--fs', `${t.typography.body.size}px`);
        }
      }catch(e){ console.warn('settings tokens', e); }
    }

    function showSettings(){
      const page = document.getElementById('settingsPage');
      if (!page) return;
      
      const appCard = document.getElementById('cardRoot');
      const tabsWrap = document.querySelector('.tabs-wrap');
      const titlebar = document.querySelector('.titlebar');
      const elementsToHide = [titlebar, tabsWrap, appCard].filter(el => el);
      
      // Set up settings page for animation (but keep it hidden)
      page.style.display = 'block';
      page.classList.add('active');
      gsap.set(page, { opacity: 0, x: 20 });
      gsap.set('.settings-inner > *', { opacity: 0, x: 20 });
      
      // Create a smooth crossfade timeline
      const tl = gsap.timeline({
        onComplete: () => {
          // Lock body position to prevent background scrolling
          document.body.classList.add('settings-open');
        }
      });
      
      // Phase 1: Hide main app elements (faster, no stagger to avoid jiggle)
      tl.to(elementsToHide, {
        opacity: 0,
        x: -15,
        scale: 0.99,
        duration: 0.25,
        ease: "power2.in",
        onComplete: () => {
          // Hide elements cleanly
          if (appCard) appCard.style.display = 'none';
          if (tabsWrap) tabsWrap.style.visibility = 'hidden';
          if (titlebar) titlebar.style.visibility = 'hidden';
        }
      })
      
      // Phase 2: Show settings page (overlapping for smoother transition)
      .to(page, {
        opacity: 1,
        x: 0,
        duration: 0.35,
        ease: "power2.out"
      }, "-=0.1") // Start slightly before previous animation ends
      
      // Phase 3: Animate settings content (tighter timing)
      .to('.settings-inner > *', {
        opacity: 1,
        x: 0,
        duration: 0.4,
        stagger: 0.05, // Reduced stagger for smoother feel
        ease: "power2.out"
      }, "-=0.2"); // Start before settings page animation ends
      
      try{ history.replaceState(null, '', '/settings'); }catch{}
      activateSettingsTab('#secProfile');
      fetchSettingsTokens();
      refreshSettingsData();
    }
    function hideSettings(){
      // Check if billing dialog is open
      const billingDialog = document.getElementById('billingDialog');
      if (billingDialog && billingDialog.classList.contains('active')) {
        // Don't close settings if billing dialog is open
        return;
      }
      
      const page = document.getElementById('settingsPage');
      if (!page) return;
      
      const appCard = document.getElementById('cardRoot');
      const tabsWrap = document.querySelector('.tabs-wrap');
      const titlebar = document.querySelector('.titlebar');
      const elementsToShow = [titlebar, tabsWrap, appCard].filter(el => el);
      
      // Remove body lock immediately to restore scrollbar
      document.body.classList.remove('settings-open');
      
      // Prepare main app elements for animation (but keep them hidden initially)
      if (appCard) appCard.style.display = '';
      if (tabsWrap) tabsWrap.style.visibility = '';
      if (titlebar) titlebar.style.visibility = '';
      gsap.set(elementsToShow, { opacity: 0, x: -15, scale: 0.99 });
      
      // Create smooth reverse timeline
      const tl = gsap.timeline({
        onComplete: () => {
          // Clean up settings page
          page.classList.remove('active');
          page.style.display = 'none';
          gsap.set(page, { clearProps: "all" });
          gsap.set('.settings-inner > *', { clearProps: "all" });
        }
      });
      
      // Phase 1: Hide settings page
      tl.to(page, {
        opacity: 0,
        x: 20,
        duration: 0.25,
        ease: "power2.in"
      })
      
      // Phase 2: Show main app elements (overlapping for smooth transition)
      .to(elementsToShow, {
        opacity: 1,
        x: 0,
        scale: 1,
        duration: 0.35,
        stagger: 0.03, // Very tight stagger to avoid jiggle
        ease: "power2.out"
      }, "-=0.1"); // Start before settings fade completes
      
      try{ history.replaceState(null, '', '/'); }catch{}
    }
    function activateSettingsTab(sel){
      const links = Array.from(document.querySelectorAll('.settings-link'));
      const btn = links.find(b=>b.dataset.target===sel);
      const sections = ['#secProfile','#secBilling','#secSecurity','#secA11y'];
      const currentSection = document.querySelector(sel);
      const otherSections = sections.filter(id => id !== sel).map(id => document.querySelector(id)).filter(el => el);
      
      // Update link states
      links.forEach(b=>b.classList.remove('active'));
      if (btn) {
        btn.classList.add('active');
        // Button click/hover animations removed across settings pages
      }
      
      // Update billing data when switching to billing section
      if (sel === '#secBilling') {
        // Delay slightly to ensure section is visible
        setTimeout(() => {
          if (window.updateBillingPageData) {
            window.updateBillingPageData();
          }
        }, 50);
      }
      
      // Hide other sections immediately (no animation to prevent flicker)
      otherSections.forEach(el => {
        el.style.display = 'none';
        el.classList.remove('active');
      });
      
      // Show and animate current section
      if (currentSection) {
        currentSection.style.display = 'block';
        currentSection.classList.add('active');
        
        // Only animate if not the initial load
        if (document.querySelector('.settings-page.active')) {
          gsap.fromTo(currentSection, 
            { opacity: 0, y: 15 },
            { opacity: 1, y: 0, duration: 0.3, ease: "power2.out" }
          );
        }
        
        try{ currentSection.focus(); }catch{}
      }
    }
    async function refreshSettingsData(){
      // Function to update billing page with current usage data
      window.updateBillingPageData = function updateBillingPageData() {
        const usageData = window.currentUsageData;
        if (!usageData) return;
        
        const plan = usageData.isGuest ? 'Guest' : (usageData.tier || 'Free').replace(/^./,c=>c.toUpperCase());
        const pct = Math.round(usageData.percentage || 0);
        
        const planEl = document.getElementById('planName'); 
        if (planEl) planEl.textContent = plan;
        
        const pctEl = document.getElementById('planUsagePct'); 
        if (pctEl) pctEl.textContent = pct + '% Characters used';
        
        const bar = document.getElementById('planUsageBar'); 
        if (bar) {
          bar.style.width = pct + '%';
          // Set color based on usage percentage using main app rules
          if (pct >= 70) {
            bar.style.background = '#dc2626'; // Critical (red) for 70%+
          } else if (pct >= 50) {
            bar.style.background = '#d97706'; // Warning (amber) for 50-69%
          } else {
            bar.style.background = 'var(--accent)'; // Normal (blue) for under 50%
          }
        }
        
        const priceEl = document.getElementById('planPrice'); 
        if (priceEl) priceEl.textContent = plan==='Business' ? '$45' : (plan==='Pro' ? '$13' : '$0');
        
        // Update upgrade button based on tier
        const upgradeBtn = document.getElementById('planUpgradeBtn');
        if (upgradeBtn) {
          // Remove existing event listener
          if (!upgradeBtn._clickWired) {
            upgradeBtn._clickWired = true;
            upgradeBtn.addEventListener('click', () => {
              showToast('Plan change coming soon!');
            });
          }
          
          if (plan === 'Business') {
            upgradeBtn.textContent = 'Downgrade';
            upgradeBtn.style.background = '#dc2626'; // Red for downgrade
          } else if (plan === 'Pro') {
            upgradeBtn.textContent = 'Upgrade';
            upgradeBtn.style.background = '#006cff'; // Blue for upgrade
          } else {
            upgradeBtn.textContent = 'Upgrade';
            upgradeBtn.style.background = '#006cff'; // Blue for upgrade
          }
        }
      }
      
      // Update billing data immediately if available
      window.updateBillingPageData();
      
      // Also update when usage data changes (listen for updates)
      const originalUpdateUsageMini = window.updateUsageMini;
      if (typeof originalUpdateUsageMini === 'function') {
        window.updateUsageMini = function(...args) {
          const result = originalUpdateUsageMini.apply(this, args);
          // Update billing page after main usage update
          setTimeout(window.updateBillingPageData, 100);
          return result;
        };
      }

      try{
        const [res, acc, bill] = await Promise.all([
          fetch('/api/profile', { headers: await authHeaders() }),
          fetch('/api/account', { headers: await authHeaders() }),
          fetch('/api/billing/profile', { headers: await authHeaders() })
        ]);
        if (res.ok){ const p = await res.json(); const dn = document.getElementById('profileDisplayName'); if (dn && p?.name) dn.value = p.name; }
        if (acc.ok){
          const a = await acc.json();
          const em = document.getElementById('profileEmail'); if (em && a?.email){ em.value = a.email; }
          // Verified state UI (STATE-GUIDE)
          if (em){
            if (a.email_confirmed){ em.style.borderColor = '#d2d2d7'; em.title = 'Verified'; }
          }
        }
        if (bill.ok){
          const b = await bill.json();
          const s = b?.billing_profile || {};
          const bs = document.getElementById('billingSummary');
          if (bs){
            const lines = [];
            if (s.billing_email) lines.push(`Email address\n${s.billing_email}`);
            if (s.address_1 || s.city || s.postal_code) lines.push(`Address\n${[s.address_1,s.city,s.postal_code].filter(Boolean).join(', ')}`);
            if (s.company) lines.push(`Company\n${s.company}`);
            bs.textContent = lines.length ? '' : 'No details yet';
            if (lines.length){
              bs.innerHTML = lines.map(x=>`<div style="margin:6px 0">${x.replace(/\n/g,'<br/>')}</div>`).join('');
            }
          }
          // Prefill dialog fields
          const set = (id,val)=>{ const el=document.getElementById(id); if(el&&val!=null) el.value=val; };
          set('billEmail', s.billing_email);
          set('billCompany', s.company);
          set('billAddr1', s.address_1);
          set('billAddr2', s.address_2);
          set('billCity', s.city);
          set('billCountry', s.country);
          set('billPostal', s.postal_code);
          set('billTax', s.tax_id);
          // Invoices sample (until Stripe wired)
          const body = document.getElementById('invoicesBody');
          const empty = document.getElementById('invoicesEmpty');
          if (body){
            body.innerHTML = '';
            const rows = Array.isArray(s.invoices) ? s.invoices : [];
            if (rows.length){ empty.style.display='none'; }
            else { empty.style.display='block'; }
            rows.forEach(row=>{
              const tr=document.createElement('tr');
              tr.innerHTML = `<td>${row.ref||''}</td><td>${row.status||''}</td><td>${row.amount||''}</td><td>${row.date||''}</td><td><span class="inv-view">View</span></td>`;
              body.appendChild(tr);
            });
          }
        }
      }catch(e){ console.warn('settings profile', e); }
    }

    async function authHeaders(){
      const headers = { 'Content-Type': 'application/json' };
      const token = localStorage.getItem('authToken');
      if (token) headers['Authorization'] = `Bearer ${token}`;
      else {
        try{ const s = await supabase.auth.getSession(); const t = s?.data?.session?.access_token; if (t) headers['Authorization'] = `Bearer ${t}`; } catch{}
      }
      return headers;
    }
    function wireSettings(){
      const btn = document.getElementById('settingsBtn');
      if (btn && !btn._wired){ btn._wired = true; btn.addEventListener('click', showSettings); }
      const backTop = document.getElementById('settingsBackTop');
      if (backTop && !backTop._wired){ backTop._wired = true; backTop.addEventListener('click', hideSettings); }
      // Sidebar tabs
      document.querySelectorAll('.settings-link').forEach(b=>{
        b.addEventListener('click', ()=> {
          // Check if billing dialog is open
          const billingDialog = document.getElementById('billingDialog');
          if (billingDialog && billingDialog.classList.contains('active')) {
            // Don't allow tab switching if billing dialog is open
            return;
          }
          activateSettingsTab(b.dataset.target);
        });
      });
      // Save profile with click state animation
      const saveBtn = document.getElementById('saveProfileBtn');
      if (saveBtn && !saveBtn._wired){
        saveBtn._wired = true;
        saveBtn.addEventListener('click', async ()=>{
          const payload = { display_name: document.getElementById('profileDisplayName')?.value?.trim() || undefined };
          const r = await fetch('/api/profile', { method:'PATCH', headers: await authHeaders(), body: JSON.stringify(payload) });
          // Also persist display name to Supabase user metadata for consistency
          try{ if (payload.display_name){ await supabase.auth.updateUser({ data: { name: payload.display_name } }); } }catch{}
          
          if (r.ok) {
            // Show success feedback
            const status = document.getElementById('saveProfileStatus');
            if (status){ status.style.display = 'inline'; setTimeout(()=>{ status.style.display = 'none'; }, 2000); }
            showToast('Profile updated');
          } else {
            showToast('Failed to update profile');
          }
        });
      }
      // Email verification button with states
      const emailVerifyBtn = document.getElementById('emailVerifyBtn');
      if (emailVerifyBtn && !emailVerifyBtn._wired) {
        emailVerifyBtn._wired = true;
        
        // Check if user is logged in with Google (auto-verify)
        const checkGoogleAuth = async () => {
          try {
            const { data: { user } } = await supabase.auth.getUser();
            if (user && user.app_metadata?.provider === 'google') {
              // Auto-verify for Google users
              emailVerifyBtn.textContent = 'Verified âœ“';
              emailVerifyBtn.style.background = 'transparent';
              emailVerifyBtn.style.border = 'none';
              emailVerifyBtn.style.color = '#006cff';
              emailVerifyBtn.style.cursor = 'default';
              emailVerifyBtn.disabled = true;
              // Remove hover effects
              emailVerifyBtn.style.pointerEvents = 'none';
            }
          } catch (e) {
            console.log('Auth check failed');
          }
        };
        
        // Check on load
        checkGoogleAuth();
        
        emailVerifyBtn.addEventListener('click', async () => {
          // Show "Verification link sent" state
          const originalText = emailVerifyBtn.textContent;
          emailVerifyBtn.textContent = 'Verification link sent';
          emailVerifyBtn.style.color = '#006cff';
          emailVerifyBtn.disabled = true;
          
          // Simulate verification process
          setTimeout(() => {
            emailVerifyBtn.textContent = 'Verified âœ“';
            emailVerifyBtn.style.background = 'transparent';
            emailVerifyBtn.style.border = 'none';
            emailVerifyBtn.style.color = '#006cff';
            emailVerifyBtn.style.cursor = 'default';
            emailVerifyBtn.disabled = true;
            // Remove hover effects
            emailVerifyBtn.style.pointerEvents = 'none';
          }, 3000);
          
          showToast('Verification email sent');
        });
      }
      
      const delBtn = document.getElementById('deleteAccountBtn');
      if (delBtn && !delBtn._wired){ 
        delBtn._wired = true; 
        delBtn.addEventListener('click', async ()=>{ 
          if(!confirm('Delete account? This cannot be undone.')) return; 
          const r = await fetch('/api/profile', { method:'DELETE', headers: await authHeaders() }); 
          showToast(r.ok ? 'Account deleted' : 'Failed to delete'); 
          if(r.ok){ try{ await supabase.auth.signOut(); }catch{} location.href = '/'; } 
        }); 
      }
      // Security: change password via Supabase
      const pwBtn = document.getElementById('changePwBtn');
      if (pwBtn && !pwBtn._wired){
        pwBtn._wired = true;
        pwBtn.addEventListener('click', async ()=>{
          const npw = document.getElementById('pwNew')?.value || '';
          const cpw = document.getElementById('pwConfirm')?.value || '';
          if (npw.length < 8 || npw !== cpw) { showToast('Password invalid or mismatch'); return; }
          try{
            const { error } = await supabase.auth.updateUser({ password: npw });
            showToast(error ? ('Error: ' + error.message) : 'Password updated');
          }catch(e){ showToast('Password change failed'); }
        });
      }
      // Show/hide password toggles with animations
      const toggle = (inputId, btnId)=>{
        const input=document.getElementById(inputId); const btn=document.getElementById(btnId);
        if (input && btn && !btn._wired){ 
          btn._wired=true; 
          btn.addEventListener('click',()=>{ 
            const isPwd=input.type==='password'; 
            input.type=isPwd?'text':'password'; 
            btn.textContent=isPwd?'Hide':'Show';
          }); 
        }
      };
      toggle('pwCurrent','pwCurrentToggle');
      toggle('pwNew','pwNewToggle');
      toggle('pwConfirm','pwConfirmToggle');
      
      // New Security Page Functions
      // Two-Factor Authentication with state management
      const add2FABtn = document.getElementById('add2FABtn');
      if (add2FABtn && !add2FABtn._wired) {
        add2FABtn._wired = true;
        add2FABtn.addEventListener('click', async () => {
          // Toggle 2FA state
          const statusSpan = add2FABtn.parentElement.querySelector('span');
          const isDisabled = statusSpan.textContent === 'Disabled';
          
          if (isDisabled) {
            // Enable 2FA
            statusSpan.textContent = 'Enabled';
            statusSpan.style.color = '#006cff';
            add2FABtn.textContent = 'Disable Two-Factor authentication';
            showToast('Two-Factor Authentication enabled');
            try{ await fetch('/api/profile/prefs', { method:'PATCH', headers: await authHeaders(), body: JSON.stringify({ two_factor_enabled: true }) }); }catch{}
            try{ await supabase.auth.updateUser({ data: { two_factor_enabled: true } }); }catch{}
          } else {
            // Disable 2FA
            statusSpan.textContent = 'Disabled';
            statusSpan.style.color = 'var(--text)';
            add2FABtn.textContent = 'Add Two-Factor authentication';
            showToast('Two-Factor Authentication disabled');
            try{ await fetch('/api/profile/prefs', { method:'PATCH', headers: await authHeaders(), body: JSON.stringify({ two_factor_enabled: false }) }); }catch{}
            try{ await supabase.auth.updateUser({ data: { two_factor_enabled: false } }); }catch{}
          }
        });
      }
      // Password visibility toggles for new security page
      const togglePassword = (inputId, btnId) => {
        const input = document.getElementById(inputId);
        const btn = document.getElementById(btnId);
        if (input && btn && !btn._wired) {
          btn._wired = true;
          btn.addEventListener('click', () => {
            const isPassword = input.type === 'password';
            input.type = isPassword ? 'text' : 'password';
            btn.textContent = isPassword ? 'Hide' : 'Show';
          });
        }
      };
      
      togglePassword('currentPassword', 'showCurrentPw');
      togglePassword('newPassword', 'showNewPw');
      togglePassword('confirmPassword', 'showConfirmPw');
      
      // Change Password functionality with click states
      const changePasswordBtn = document.getElementById('changePasswordBtn');
      if (changePasswordBtn && !changePasswordBtn._wired) {
        changePasswordBtn._wired = true;
        changePasswordBtn.addEventListener('click', async () => {
          const currentPw = document.getElementById('currentPassword')?.value || '';
          const newPw = document.getElementById('newPassword')?.value || '';
          const confirmPw = document.getElementById('confirmPassword')?.value || '';
          
          if (!newPw || newPw.length < 8) {
            showToast('New password must be at least 8 characters');
            return;
          }
          
          if (newPw !== confirmPw) {
            showToast('New passwords do not match');
            return;
          }
          
          try {
            const { error } = await supabase.auth.updateUser({ password: newPw });
            if (error) {
              showToast('Error: ' + error.message);
            } else {
              // Show success feedback
              const originalText = changePasswordBtn.textContent;
              changePasswordBtn.textContent = 'Password changed!';
              changePasswordBtn.style.color = '#006cff';
              
              setTimeout(() => {
                changePasswordBtn.textContent = originalText;
                changePasswordBtn.style.color = '';
              }, 2000);
              
              showToast('Password updated successfully');
              // Clear form
              document.getElementById('currentPassword').value = '';
              document.getElementById('newPassword').value = '';
              document.getElementById('confirmPassword').value = '';
            }
          } catch (e) {
            showToast('Password change failed');
          }
        });
      }
      
      // Log out from all devices
      const logoutAllBtn = document.getElementById('logoutAllBtn');
      if (logoutAllBtn && !logoutAllBtn._wired) {
        logoutAllBtn._wired = true;
        logoutAllBtn.addEventListener('click', async () => {
          if (!confirm('Are you sure you want to log out from all devices? You will need to sign in again on all your devices.')) {
            return;
          }
          
          try {
            // Revoke all sessions via API and sign out locally
            await fetch('/api/auth/sessions/revoke_all', { method:'POST', headers: await authHeaders() });
            const { error } = await supabase.auth.signOut();
            if (error) { showToast('Error logging out: ' + error.message); return; }
            showToast('Logged out from all devices');
            setTimeout(() => { window.location.href = '/'; }, 1500);
          } catch (e) { showToast('Logout failed'); }
        });
      }
      // Accessibility: Theme switching functionality
      const themeButtons = document.querySelectorAll('.theme-btn');
      themeButtons.forEach(btn => {
        if (!btn._wired) {
          btn._wired = true;
          btn.addEventListener('click', () => {
            // Remove active class from all buttons and reset to default border colors
            themeButtons.forEach(b => {
              b.classList.remove('active');
              if (b.id === 'themeAuto') {
                b.style.background = '#F6F6F2';
                b.style.color = 'var(--text)';
                b.style.border = '2px solid #eaeaea';
              } else if (b.id === 'themeLight') {
                b.style.background = '#FFFFFF';
                b.style.color = 'var(--text)';
                b.style.border = '2px solid #eaeaea';
              } else if (b.id === 'themeDark') {
                b.style.background = '#000000';
                b.style.color = 'white';
                b.style.border = '2px solid #eaeaea';
              }
            });
            
            // Add active class to clicked button - only change border to blue
            btn.classList.add('active');
            btn.style.border = '2px solid #006cff';
            
            // Apply theme
            const theme = btn.id.replace('theme', '').toLowerCase();
            applyTheme(theme);
          });
        }
      });
      
      const applyTheme = (theme) => {
        const html = document.documentElement;
        if (theme === 'auto') {
          // Follow system preference
          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
          html.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
        } else {
          html.setAttribute('data-theme', theme);
        }
        
        // Save preference silently (no toast)
        localStorage.setItem('theme-preference', theme);
      };
      
      // Load saved theme preference
      const savedTheme = localStorage.getItem('theme-preference') || 'auto';
      const savedThemeBtn = document.getElementById('theme' + savedTheme.charAt(0).toUpperCase() + savedTheme.slice(1));
      if (savedThemeBtn) {
        savedThemeBtn.click();
      }
      
      // Listen for system theme changes when in auto mode
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
        const currentTheme = localStorage.getItem('theme-preference');
        if (currentTheme === 'auto') {
          applyTheme('auto');
        }
      });
      
      // Accessibility: persist and apply with toggle animation
      const applyA11y = async () => {
        const toggleInput = document.getElementById('a11yReduceMotion');
        const reduced_motion = !!toggleInput?.checked;
        
        // Add toggle animation
        // Toggle animation removed
        
        document.documentElement.classList.toggle('rm', reduced_motion);
        
        // Disable/enable animations based on reduced motion setting
        if (reduced_motion) {
          document.documentElement.style.setProperty('--animation-duration', '0s');
          document.documentElement.style.setProperty('--transition-duration', '0s');
        } else {
          document.documentElement.style.removeProperty('--animation-duration');
          document.documentElement.style.removeProperty('--transition-duration');
        }
        
        try{ await fetch('/api/profile/prefs', { method:'PATCH', headers: await authHeaders(), body: JSON.stringify({ reduced_motion }) }); }catch{}
      };
      const reduceEl = document.getElementById('a11yReduceMotion'); if (reduceEl && !reduceEl._wired){ reduceEl._wired = true; reduceEl.addEventListener('change', applyA11y); }
      const themeAuto = document.getElementById('themeAuto');
      const themeLight = document.getElementById('themeLight');
      const themeDark = document.getElementById('themeDark');
      const setTheme = async (theme)=>{
        document.documentElement.dataset.theme = theme;
        [themeAuto, themeLight, themeDark].forEach(b=>{ if(!b) return; b.classList.remove('active'); });
        if (theme==='system'||theme==='auto'){ if(themeAuto) themeAuto.classList.add('active'); } else if (theme==='light'){ if(themeLight) themeLight.classList.add('active'); } else if (theme==='dark'){ if(themeDark) themeDark.classList.add('active'); }
        try{ await fetch('/api/profile/prefs', { method:'PATCH', headers: await authHeaders(), body: JSON.stringify({ theme }) }); }catch{}
      };
      if (themeAuto && !themeAuto._wired){ themeAuto._wired = true; themeAuto.addEventListener('click', ()=> setTheme('auto')); }
      if (themeLight && !themeLight._wired){ themeLight._wired = true; themeLight.addEventListener('click', ()=> setTheme('light')); }
      if (themeDark && !themeDark._wired){ themeDark._wired = true; themeDark.addEventListener('click', ()=> setTheme('dark')); }

      const logoutAll = document.getElementById('logoutAllBtn');
      if (logoutAll && !logoutAll._wired){ logoutAll._wired = true; logoutAll.addEventListener('click', async ()=>{ const r = await fetch('/api/auth/sessions/revoke_all', { method:'POST', headers: await authHeaders() }); showToast(r.ok ? 'Logged out everywhere' : 'Failed to logout all'); }); }
      
      // Interactive animations disabled across settings pages by design
      document.querySelectorAll('.settings-btn').forEach(() => {});

      // Email verify UI
      const verifyBtn = document.getElementById('emailVerifyBtn');
      const verifyState = document.getElementById('emailVerifyState');
      if (verifyBtn && !verifyBtn._wired){
        verifyBtn._wired = true;
        verifyBtn.addEventListener('click', async ()=>{
          try{
            const { data, error } = await supabase.auth.resend({ type: 'signup', email: document.getElementById('profileEmail')?.value || '' });
            if (!error){ verifyState.textContent = 'Verification link sent'; }
          }catch{}
        });
      }
      // Invoice view functionality
      document.querySelectorAll('.invoice-view-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          const invoiceId = this.dataset.invoice;
          // Show a simple alert for now - in production this would open a proper invoice viewer
          alert(`Viewing invoice ${invoiceId}\n\nThis would normally open the invoice details or download the PDF.`);
          console.log('Viewing invoice:', invoiceId);
        });
      });
      // Smart Card Input Functionality - Separate Fields with Auto-jump
      function initSmartCardInput() {
        const cardNumberInput = document.getElementById('cardNumberInput');
        const expiryInput = document.getElementById('expiryInput');
        const cvvInput = document.getElementById('cvvInput');
        
        if (!cardNumberInput || !expiryInput || !cvvInput) return;
        
        // Format card number with spaces
        function formatCardNumber(value) {
          const digits = value.replace(/\D/g, '');
          return digits.replace(/(\d{4})(?=\d)/g, '$1 ');
        }
        
        // Format expiry as MM/YY
        function formatExpiry(value) {
          const digits = value.replace(/\D/g, '');
          if (digits.length >= 2) {
            return digits.substring(0, 2) + '/' + digits.substring(2, 4);
          }
          return digits;
        }
        
        // Card Number Input
        cardNumberInput.addEventListener('input', function(e) {
          const rawValue = e.target.value.replace(/\D/g, '');
          const formattedValue = formatCardNumber(rawValue);
          
          // Update the input value
          e.target.value = formattedValue;
          
          // Auto-jump to expiry when 16 digits entered
          if (rawValue.length === 16) {
            expiryInput.focus();
          }
        });
        
        // Expiry Input with month validation
        expiryInput.addEventListener('input', function(e) {
          const rawValue = e.target.value.replace(/\D/g, '');
          let formattedValue = formatExpiry(rawValue);
          
          // Validate month (01-12)
          if (rawValue.length >= 2) {
            const month = parseInt(rawValue.substring(0, 2));
            if (month < 1 || month > 12) {
              // Invalid month, reset to valid range
              const correctedMonth = Math.min(Math.max(month, 1), 12).toString().padStart(2, '0');
              const year = rawValue.substring(2, 4);
              formattedValue = correctedMonth + (year ? '/' + year : '');
            }
          }
          
          // Update the input value
          e.target.value = formattedValue;
          
          // Auto-jump to CVV when 4 digits entered (MMYY)
          if (rawValue.length === 4) {
            cvvInput.focus();
          }
        });
        
        // CVV Input - only allow digits
        cvvInput.addEventListener('input', function(e) {
          const rawValue = e.target.value.replace(/\D/g, '');
          e.target.value = rawValue;
        });
        
        // Backspace navigation
        expiryInput.addEventListener('keydown', function(e) {
          if (e.key === 'Backspace' && e.target.value === '') {
            cardNumberInput.focus();
          }
        });
        
        cvvInput.addEventListener('keydown', function(e) {
          if (e.key === 'Backspace' && e.target.value === '') {
            expiryInput.focus();
          }
        });
        
        // Reset function
        function resetCardInput() {
          cardNumberInput.value = '';
          expiryInput.value = '';
          cvvInput.value = '';
          cardNumberInput.focus();
        }
        
        // Make reset available globally
        window.resetSmartCardInput = resetCardInput;
        
        // Focus first field initially
        setTimeout(() => cardNumberInput.focus(), 100);
      }
      // Billing dialog
      const openDlg = document.getElementById('openBillingDialog');
      const dlg = document.getElementById('billingDialog');
      const btnClose = document.getElementById('billingCancel');
      const btnCloseX = document.getElementById('billingClose');
      const btnSave = document.getElementById('billingSave');
      
      if (openDlg && !openDlg._wired){ 
        openDlg._wired = true; 
        openDlg.addEventListener('click', ()=>{ 
          dlg?.classList.add('active'); 
          dlg?.setAttribute('aria-hidden','false');
          
          // Reset and initialize smart card input
          if (window.resetSmartCardInput) window.resetSmartCardInput();
          setTimeout(initSmartCardInput, 50);
          
          // Animate dialog appearance with subtle fade and scale (no bounce)
          gsap.fromTo('.billing-dialog-card', 
            { scale: 0.98, opacity: 0, y: 10 },
            { scale: 1, opacity: 1, y: 0, duration: 0.16, ease: "power2.out" }
          );
        }); 
      }
      
      const closeBillingDialog = () => {
        gsap.to('.billing-dialog-card', {
          scale: 0.98,
          opacity: 0,
          y: 10,
          duration: 0.10,
          ease: "power2.in",
          onComplete: () => {
            dlg?.classList.remove('active'); 
            dlg?.setAttribute('aria-hidden','true');
          }
        });
      };
      
      if (btnClose && !btnClose._wired){ 
        btnClose._wired = true; 
        btnClose.addEventListener('click', closeBillingDialog); 
      }
      if (btnCloseX && !btnCloseX._wired){ 
        btnCloseX._wired = true; 
        btnCloseX.addEventListener('click', closeBillingDialog); 
      }
      if (btnSave && !btnSave._wired){
        btnSave._wired = true;
        btnSave.addEventListener('click', async ()=>{
          // Get form data from new billing dialog
          const cardNumber = document.getElementById('cardNumberInput')?.value || '';
          const expiry = document.getElementById('expiryInput')?.value || '';
          const cvv = document.getElementById('cvvInput')?.value || '';
          const nameOnCard = document.querySelector('.billing-input[placeholder=""]')?.value || '';
          const country = document.querySelector('.billing-country-select')?.value || '';
          const addressLine1 = document.querySelector('input[placeholder="Address line 1"]')?.value || '';
          const addressLine2 = document.querySelector('input[placeholder="Address line 2"]')?.value || '';
          const city = document.querySelector('input[placeholder="City"]')?.value || '';
          const postalCode = document.querySelector('input[placeholder="Postal Code"]')?.value || '';
          const state = document.querySelector('input[placeholder="State, county, province, or region"]')?.value || '';
          
          // Validate required fields
          if (!cardNumber || cardNumber.replace(/\s/g, '').length !== 16) {
            alert('Please enter a valid 16-digit card number');
            return;
          }
          if (!expiry || expiry.length !== 5) {
            alert('Please enter a valid expiry date (MM/YY)');
            return;
          }
          if (!cvv || cvv.length < 3) {
            alert('Please enter a valid CVV');
            return;
          }
          if (!country) {
            alert('Please select a country');
            return;
          }
          if (!addressLine1 || !city || !postalCode) {
            alert('Please fill in all required address fields');
            return;
          }
          
          // Create masked card number (show last 4 digits)
          const cleanCardNumber = cardNumber.replace(/\s/g, '');
          const maskedCardNumber = '**** **** **** ' + cleanCardNumber.slice(-4);
          
          // Get country name from select option
          const countrySelect = document.querySelector('.billing-country-select');
          const countryName = countrySelect.options[countrySelect.selectedIndex].text;
          
          // Update billing details in the main page
          const emailEl = document.getElementById('billingSummaryEmail');
          const addressEl = document.getElementById('billingSummaryAddress');
          const paymentEl = document.getElementById('billingSummaryPayment');
          
          if (emailEl) emailEl.textContent = JSON.parse(localStorage.getItem('user') || '{}').email || '';
          if (addressEl) addressEl.textContent = `${addressLine1}, ${city}, ${postalCode}`;
          if (paymentEl) paymentEl.textContent = `Mastercard, ${maskedCardNumber}`;
          
          console.log('Payment method saved:', {
            maskedCard: maskedCardNumber,
            expiry,
            address: `${addressLine1}, ${city}, ${postalCode}`,
            country: countryName
          });
          
          // Close dialog
          closeBillingDialog();
          return;
          
          // Old billing logic (fallback)
          const payload = {
            billing_email: document.getElementById('billEmail')?.value || undefined,
            company: document.getElementById('billCompany')?.value || undefined,
            address_1: document.getElementById('billAddr1')?.value || undefined,
            address_2: document.getElementById('billAddr2')?.value || undefined,
            city: document.getElementById('billCity')?.value || undefined,
            country: document.getElementById('billCountry')?.value || undefined,
            postal_code: document.getElementById('billPostal')?.value || undefined,
            tax_id: document.getElementById('billTax')?.value || undefined
          };
          const r = await fetch('/api/billing/profile', { method:'PATCH', headers: await authHeaders(), body: JSON.stringify(payload) });
          showToast(r.ok ? 'Billing details saved' : 'Failed to save billing details');
          if (r.ok){ dlg?.classList.remove('active'); dlg?.setAttribute('aria-hidden','true'); }
        });
      }
    }

    document.addEventListener('DOMContentLoaded', wireSettings);
    if (location.pathname.startsWith('/settings')){
      window.addEventListener('load', ()=>{ wireSettings(); showSettings(); });
    }
    // Render header auth state
    window.renderAuthHeader = function renderAuthHeader(){
      try{
        const hasToken = !!localStorage.getItem('authToken');
        const u = JSON.parse(localStorage.getItem('user')||'{}');
        const badge = document.getElementById('tierBadge');
        const isGuest = u.isGuest === true;
        
        console.log('ðŸ” renderAuthHeader:', { hasToken, user: u, isGuest });
        
        if (hasToken && !isGuest){
          // Authenticated user
          console.log('ðŸ” Rendering authenticated user UI, tier:', u.tier);
          if (signInBtn) signInBtn.style.display='none';
          if (signOutBtnTop) signOutBtnTop.style.display='inline-block';
          if (signOutBtnTop && u.tier) signOutBtnTop.title = `Tier: ${u.tier}`;
          if (badge){
            if (u.tier){ 
              badge.style.display='inline-block'; 
              badge.textContent = String(u.tier).toUpperCase();
              // Reset guest styling
              badge.style.background=''; 
              badge.style.color='';
              badge.style.borderColor='';
              badge.title = `Current tier: ${u.tier}`;
            }
            else { badge.style.display='none'; }
          }
        } else if (isGuest) {
          // Guest user
          if (signOutBtnTop) signOutBtnTop.style.display='none';
          if (signInBtn) {
            signInBtn.style.display='inline-block';
            signInBtn.textContent = 'Sign in';
            signInBtn.title = 'Sign in to unlock more features and save your work';
          }
          if (badge){
            badge.style.display='inline-block'; 
            badge.textContent = 'GUEST';
            badge.style.background='#f3f4f6'; 
            badge.style.color='#6b7280';
            badge.style.borderColor='#d1d5db';
            badge.title = 'Guest mode - Sign in to unlock more features';
          }
        } else {
          // No user at all (shouldn't happen with guest mode)
          if (signOutBtnTop) signOutBtnTop.style.display='none';
          if (signInBtn) signInBtn.style.display='inline-block';
          if (badge) badge.style.display='none';
        }
      }catch{}
    }
    renderAuthHeader();
    // Character limit system
    const TIER_LIMITS = {
      free: { maxInputSize: 1000, name: 'Free' },
      pro: { maxInputSize: 10000, name: 'Pro' },
      business: { maxInputSize: 50000, name: 'Business' },
      guest: { maxInputSize: 1000, name: 'Guest' }
    };

    function getTierLimit(tier) {
      return TIER_LIMITS[tier] || TIER_LIMITS.free;
    }

    async function updateCharacterLimit() {
      // Rate limiting to prevent cascade calls
      const now = Date.now();
      if (window._lastCharLimitUpdate && (now - window._lastCharLimitUpdate) < 2000) {
        console.log('ðŸš« Character limit update rate limited');
        return;
      }
      window._lastCharLimitUpdate = now;
      
      // Compact meter relies on cumulative usage
      await updateCumulativeUsage();
    }
    async function updateCumulativeUsage() {
      // Rate limiting to prevent spam requests
      const now = Date.now();
      if (window._lastUsageUpdate && (now - window._lastUsageUpdate) < 2000) {
        console.log('ðŸš« Usage update rate limited');
        return;
      }
      
      // Prevent concurrent calls
      if (window._usageUpdateRunning) {
        console.log('ðŸš« Usage update already running');
        return;
      }
      window._usageUpdateRunning = true;
      window._lastUsageUpdate = now;
      
      const usageMini = document.getElementById('usageMini');
      const label = document.getElementById('usageMiniLabel');
      const bar = document.getElementById('usageMiniBar');
      const planEl = document.getElementById('usageMiniPlan');
      const pctEl = document.getElementById('usageMiniPct');
      const resetEl = document.getElementById('usageMiniReset');
      if (!usageMini || !label || !bar) return;
      
      console.log('ðŸ“Š Updating cumulative usage...');
      
      try {
        // Fetch current usage from backend
        const headers = {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        };
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        
        if (user.isGuest) {
          headers['X-Guest-ID'] = localStorage.getItem('guestId');
        } else {
          // Try to get Supabase session token
          const authToken = localStorage.getItem('authToken');
          if (authToken) {
            headers['Authorization'] = `Bearer ${authToken}`;
          } else {
            // Try to get Supabase session
            try {
              const supabaseSession = await supabase.auth.getSession();
              if (supabaseSession?.data?.session?.access_token) {
                headers['Authorization'] = `Bearer ${supabaseSession.data.session.access_token}`;
                console.log('ðŸ”‘ Using Supabase session token for usage API');
              }
            } catch (e) {
              console.warn('Failed to get Supabase session:', e);
            }
          }
        }
        
        const fetchUrl = `/api/usage/current?t=${Date.now()}`;
        console.log('ðŸ“¡ Fetching usage from:', fetchUrl);
        const response = await fetch(fetchUrl, { 
          headers,
          cache: 'no-cache'
        });
        if (!response.ok) {
          const errText = await response.text().catch(()=>'');
          throw new Error(`HTTP ${response.status} ${errText}`);
        }
        const usageData = await response.json();
        
        if (usageData && typeof usageData.used === 'number') {
          const fmt = (n)=>{
            if (n < 10000) return n.toLocaleString('id-ID');
            if (n < 1000000) return (n/1000).toFixed(1).replace(/\.0$/,'') + 'k';
            return (n/1000000).toFixed(1).replace(/\.0$/,'') + 'm';
          };
          label.textContent = `${fmt(usageData.used)} / ${fmt(usageData.limit)}`;
          bar.style.width = usageData.percentage + '%';
          usageMini.removeAttribute('data-variant');
          if (usageData.percentage >= 70) usageMini.setAttribute('data-variant','critical');
          else if (usageData.percentage >= 50) usageMini.setAttribute('data-variant','warning');
          if (planEl) planEl.textContent = usageData.isGuest ? 'Guest' : (usageData.tier || 'Free').replace(/^./,c=>c.toUpperCase());
          if (pctEl) pctEl.textContent = Math.round(usageData.percentage);
          if (resetEl){ const d=new Date(); d.setMonth(d.getMonth()+1,1); resetEl.textContent = d.toLocaleDateString('en-GB',{day:'numeric',month:'short',year:'numeric'}); }
          window.currentUsageData = usageData;
        } else {
          label.textContent = '0 / 0';
          bar.style.width = '0%';
        }
      } catch (error) {
        console.error('Failed to fetch usage data:', error);
        
        // Minimal fallback
        label.textContent = '0 / 0';
        bar.style.width = '0%';
      } finally {
        // Clear running flag
        window._usageUpdateRunning = false;
      }
    }

    function updateCurrentTabCharacterCount() {
      const inputText = document.getElementById('inputText');
      if (!inputText) return;
      
      const user = JSON.parse(localStorage.getItem('user') || '{}');
      const tier = user.isGuest ? 'guest' : (user.tier || 'free');
      const tierConfig = window.getTierLimit ? window.getTierLimit(tier) : TIER_LIMITS[tier] || TIER_LIMITS.free;
      const currentLength = inputText.value.length;
      const maxLength = tierConfig.maxInputSize;
      const percentage = Math.min((currentLength / maxLength) * 100, 100);
      
      // Per-tab visual removed; cumulative meter covers usage
      
      // Return whether limit is exceeded
      return currentLength > maxLength;
    }

    // Alias for backward compatibility
    function updateCharacterCount() {
      return updateCumulativeUsage();
    }

    async function checkCharacterLimit(text) {
      try {
        // Fetch current usage to check against cumulative limit
        const headers = {};
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        
        if (user.isGuest) {
          headers['X-Guest-ID'] = localStorage.getItem('guestId');
        } else {
          // Try to get Supabase session token
          const authToken = localStorage.getItem('authToken');
          if (authToken) {
            headers['Authorization'] = `Bearer ${authToken}`;
          } else {
            // Try to get Supabase session
            try {
              const supabaseSession = await supabase.auth.getSession();
              if (supabaseSession?.data?.session?.access_token) {
                headers['Authorization'] = `Bearer ${supabaseSession.data.session.access_token}`;
              }
            } catch (e) {
              console.warn('Failed to get Supabase session:', e);
            }
          }
        }
        
        const response = await fetch('/api/usage/current', { headers });
        const usageData = await response.json();
        
        if (response.ok) {
          // Check if adding this text would exceed the limit
          const potentialUsage = usageData.used + text.length;
          return potentialUsage <= usageData.limit;
        }
      } catch (error) {
        console.error('Failed to check character limit:', error);
      }
      
      // Fallback to simple text length check
      const user = JSON.parse(localStorage.getItem('user') || '{}');
      const tier = user.isGuest ? 'guest' : (user.tier || 'free');
      const tierConfig = window.getTierLimit ? window.getTierLimit(tier) : TIER_LIMITS[tier] || TIER_LIMITS.free;
      return text.length <= tierConfig.maxInputSize;
    }
    // Initialize character limit system
    async function initCharacterLimits() {
      if (window.updateCharacterLimit) {
        await window.updateCharacterLimit();
      }
      
      // Add event listener to input text
      const inputText = document.getElementById('inputText');
      if (inputText) {
        inputText.addEventListener('input', () => {
          if (window.updateCharacterCount) window.updateCharacterCount();
        });
        inputText.addEventListener('paste', () => {
          setTimeout(() => {
            if (window.updateCharacterCount) window.updateCharacterCount();
          }, 10); // Delay to allow paste to complete
        });
      }
      
      // Update on user change
      const originalRenderAuthHeader = window.renderAuthHeader;
      window.renderAuthHeader = function() {
        originalRenderAuthHeader.apply(this, arguments);
        setTimeout(async () => {
          if (window.updateCharacterLimit) {
            await window.updateCharacterLimit();
          }
          if (window.updateCharacterCount) {
            await window.updateCharacterCount();
          }
        }, 100);
      };
    }
    // Attach a stable device ID header to fetch, for routes not using localization-client.
    (function installDeviceHeader(){
      try{
        const k='device_id_v1';
        let did=localStorage.getItem(k);
        if(!did){ did=`dev_${Date.now()}_${Math.random().toString(36).slice(2)}`; localStorage.setItem(k,did); }
        const _fetch = window.fetch;
        window.fetch = function(input, init){
          try{
            const url = (typeof input === 'string') ? input : (input && input.url) || '';
            // Only attach header for same-origin API calls to avoid CORS on external resources
            const sameOrigin = url.startsWith('/') || url.startsWith(location.origin);
            const path = url.startsWith(location.origin) ? url.slice(location.origin.length) : url;
            const isApi = sameOrigin && (path.startsWith('/api/'));
            if (isApi){
              const o = init ? { ...init } : {};
              const headers = o.headers || {};
              if (typeof headers.set === 'function') {
                headers.set('X-Device-ID', did);
              } else if (Array.isArray(headers)) {
                // Headers as array of tuples
                o.headers = [...headers, ['X-Device-ID', did]];
              } else {
                o.headers = { ...headers, 'X-Device-ID': did };
              }
              return _fetch(input, o);
            }
          }catch{}
          return _fetch(input, init);
        }
      }catch{}
    })();

    // Make functions globally accessible
    window.updateCharacterLimit = updateCharacterLimit;
    window.updateCharacterCount = updateCharacterCount;
    window.updateCumulativeUsage = updateCumulativeUsage;
    window.updateCurrentTabCharacterCount = updateCurrentTabCharacterCount;
    window.checkCharacterLimit = checkCharacterLimit;
    window.getTierLimit = getTierLimit;
    // Initialize character limits when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initCharacterLimits);
    } else {
      initCharacterLimits();
    }

    // Complete auth state cleanup
    window.clearAuthState = function clearAuthState() {
      console.log('ðŸ§¹ Clearing all auth state');
      localStorage.removeItem('authToken');
      localStorage.removeItem('user');
      localStorage.removeItem('guestId');
      sessionStorage.clear();
      // Initialize fresh guest mode
      window.initGuestMode();
      window.renderAuthHeader();
    }
    // Settings wiring
    try{ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wireSettings); else wireSettings(); }catch{}
    try{ if (location.pathname.startsWith('/settings')) window.addEventListener('load', ()=>{ showSettings(); }); }catch{}

    // Sign out (top button)
    if (signOutBtnTop) signOutBtnTop.addEventListener('click',async ()=>{
      try{ await supabase.auth.signOut(); }catch{}
      window.clearAuthState();
      location.reload();
    });

    // If a dev admin token leaked to production, clear it once
    if (!isLocalHost) {
      try {
        const u = JSON.parse(localStorage.getItem('user') || 'null');
        if (u && (u.email === 'admin@localhost' || /@localhost$/.test(u.email))) {
          localStorage.removeItem('authToken');
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          if (typeof openAuth==='function') openAuth('login');
        }
      } catch (e) {}
    }

    // Auto-login should only happen on localhost during development
    if (isLocalHost) {
      setTimeout(() => { if (window.autoLogin) { window.autoLogin(); } }, 1000);
    }
    // Don't auto-show login for guests - they can use the app freely
    // Only show login modal if explicitly requested
  });
</script>
<!-- Socket.IO for real-time job progress -->
<script src="/socket.io/socket.io.js"></script>

<!-- Enhanced UI features integrated directly -->

<!-- Initialize advanced features -->
<script>
  // Initialize WebSocket job tracking  
  if (typeof io !== 'undefined') {
    console.log('ðŸŒ Initializing WebSocket job tracking...');
    
    window.jobSocket = io('/jobs', {
      transports: ['websocket', 'polling'],
      timeout: 20000
    });
    
    window.jobSocket.on('connect', () => {
      console.log('ðŸŒ Real-time job progress connected');
    });
    
    window.jobSocket.on('job_progress', (data) => {
      console.log('ðŸ“Š Job progress:', data.jobId, data.progress + '%');
      
      // Update UI if job progress element exists
      const progressElement = document.querySelector(`[data-job-id="${data.jobId}"]`);
      if (progressElement) {
        const progressBar = progressElement.querySelector('.job-progress-bar .job-progress-fill');
        if (progressBar) {
          progressBar.style.width = data.progress + '%';
        }
        
        const progressText = progressElement.querySelector('.progress-text');
        if (progressText) {
          progressText.textContent = `${data.progress}% - ${data.status || 'Processing...'}`;
        }
      }
    });
    
    window.jobSocket.on('job_complete', (data) => {
      console.log('âœ… Job completed:', data.jobId);
      
      // Show completion notification
      if (window.showNotification) {
        window.showNotification('Translation Complete', 'Your translation job has finished successfully!', 'success');
      }
      
      // Update result in UI if available
      if (data.result && data.result.result) {
        const resultTextarea = document.getElementById('resultText');
        if (resultTextarea && resultTextarea.value.trim() === '') {
          resultTextarea.value = data.result.result;
          
          // Trigger existing result handling if available
          if (window.processTranslationResult) {
            window.processTranslationResult(data.result.result);
          }
        }
      }
      
      // Remove progress indicator after delay
      setTimeout(() => {
        const progressElement = document.querySelector(`[data-job-id="${data.jobId}"]`);
        if (progressElement) {
          progressElement.remove();
        }
      }, 3000);
    });
    
    window.jobSocket.on('job_failed', (data) => {
      console.log('âŒ Job failed:', data.jobId, data.error);
      
      if (window.showNotification) {
        window.showNotification('Translation Failed', data.error || 'Translation job failed', 'error');
      }
      
      // Remove progress indicator after delay
      setTimeout(() => {
        const progressElement = document.querySelector(`[data-job-id="${data.jobId}"]`);
        if (progressElement) {
          progressElement.classList.add('failed');
          setTimeout(() => progressElement.remove(), 5000);
        }
      }, 1000);
    });
    
    window.jobSocket.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason);
    });
    
    window.jobSocket.on('connect_error', (error) => {
      console.warn('WebSocket connection error:', error.message);
    });
  } else {
    console.warn('Socket.IO not available - real-time features disabled');
  }
  
  // Enhanced UI features - integrate with existing functionality
  document.addEventListener('DOMContentLoaded', () => {
    console.log('ðŸŽ¨ Enhanced UI features ready');
    
    // Add enhanced visual feedback CSS if not already present
    if (!document.getElementById('enhanced-ui-styles')) {
      const style = document.createElement('style');
      style.id = 'enhanced-ui-styles';
      style.textContent = `
        .dropzone.drag {
          transform: scale(1.02);
          box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3) !important;
          border-color: #3b82f6 !important;
          background-color: rgba(59, 130, 246, 0.05) !important;
          transition: all 0.2s ease;
        }
        
        .dropzone {
          transition: all 0.2s ease;
        }
        
        .job-progress-container {
          position: fixed;
          bottom: 20px;
          right: 20px;
          background: white;
          border-radius: 8px;
          box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
          padding: 16px;
          min-width: 300px;
          z-index: 1000;
        }
        
        .job-progress-item {
          display: flex;
          align-items: center;
          margin-bottom: 8px;
          padding: 8px;
          border-radius: 6px;
          background: #f9fafb;
        }
        
        .job-progress-item.completed {
          background: #d1fae5;
          color: #065f46;
        }
        
        .job-progress-item.failed {
          background: #fee2e2;
          color: #991b1b;
        }
        
        .job-progress-bar {
          width: 100%;
          height: 4px;
          background: #e5e7eb;
          border-radius: 2px;
          overflow: hidden;
          margin-top: 4px;
        }
        
        .job-progress-fill {
          height: 100%;
          background: #3b82f6;
          width: 0%;
          transition: width 0.3s ease;
        }
        
        .notification {
          position: fixed;
          top: 20px;
          right: 20px;
          background: white;
          border-radius: 8px;
          box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
          border-left: 4px solid #3b82f6;
          padding: 16px;
          max-width: 400px;
          z-index: 10001;
          animation: slideInNotification 0.3s ease-out;
          margin-bottom: 8px;
        }
        
        /* Dynamic positioning handled by JavaScript */
        
        .notification-success { border-left-color: #10b981; }
        .notification-error { border-left-color: #ef4444; }
        .notification-warning { border-left-color: #f59e0b; }
        
        @keyframes slideInNotification {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        
        .notification-title {
          font-weight: 600;
          margin-bottom: 4px;
        }
        
        .notification-message {
          font-size: 14px;
          color: #6b7280;
        }
        
        .notification-close {
          background: none;
          border: none;
          font-size: 18px;
          cursor: pointer;
          color: #6b7280;
          float: right;
          margin-top: -4px;
        }
      `;
      document.head.appendChild(style);
    }
    
    console.log('âœ… Enhanced UI styles loaded');
  });

  // Quick authentication system
  window.quickLogin = async function() {
    try {
      const response = await fetch('/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          email: 'admin@localhost',
          password: 'admin123'
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        
        // Store token for future requests
        localStorage.setItem('authToken', data.token);
        localStorage.setItem('user', JSON.stringify(data.user));
        
        // Update UI
        const loginBtn = document.getElementById('quickLoginBtn');
        if (loginBtn) {
          loginBtn.textContent = 'ðŸ‘‘ ' + data.user.name;
          loginBtn.style.background = '#10b981';
          loginBtn.title = `Logged in as ${data.user.email} (${data.user.tier})`;
        }
        
        window.showNotification('Login Successful', `Welcome back, ${data.user.name}!`, 'success');
        return data;
      } else {
        const error = await response.json();
        throw new Error(error.error || 'Login failed');
      }
    } catch (error) {
      console.error('Quick login failed:', error);
      window.showNotification('Login Failed', error.message, 'error');
      throw error;
    }
  };
  // Auto-login on page load if no token
  window.autoLogin = async function() {
    const token = localStorage.getItem('authToken');
    if (!token) {
      try {
        console.log('ðŸ”‘ No auth token found, attempting quick login...');
        await window.quickLogin();
      } catch (error) {
        console.log('Auto-login failed, manual login required');
      }
    } else {
      // Verify existing token
      try {
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        const loginBtn = document.getElementById('quickLoginBtn');
        if (loginBtn && user.name) {
          loginBtn.textContent = 'ðŸ‘‘ ' + user.name;
          loginBtn.style.background = '#10b981';
          loginBtn.title = `Logged in as ${user.email} (${user.tier})`;
        }
        console.log('âœ… Already authenticated as:', user.email);
      } catch (error) {
        console.log('Invalid stored token, clearing...');
        localStorage.removeItem('authToken');
        localStorage.removeItem('user');
      }
    }
  };
  
  // Job progress tracking helper
  window.trackJobProgress = function(jobId, jobName) {
    if (window.jobSocket) {
      window.jobSocket.emit('subscribe_job', jobId);
      
      // Create progress indicator
      let progressContainer = document.getElementById('job-progress-container');
      if (!progressContainer) {
        progressContainer = document.createElement('div');
        progressContainer.id = 'job-progress-container';
        progressContainer.className = 'job-progress-container';
        document.body.appendChild(progressContainer);
      }
      
      const progressElement = document.createElement('div');
      progressElement.id = `job-progress-${jobId}`;
      progressElement.className = 'job-progress-item';
      progressElement.setAttribute('data-job-id', jobId);
      progressElement.innerHTML = `
        <div class="job-info">
          <div class="job-name">${jobName}</div>
          <div class="progress-text">Starting...</div>
        </div>
        <div class="job-progress-bar">
          <div class="job-progress-fill" style="width: 0%"></div>
        </div>
      `;
      
      progressContainer.appendChild(progressElement);
      return progressElement;
    }
    return null;
  };
</script>

</body>
</html>

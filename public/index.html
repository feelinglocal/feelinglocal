<!DOCTYPE html>
<html lang="en">
<head>
  <script src="localization-client.js"></script>
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';
    const SUPABASE_URL = 'https://tqdmrzcnnciatviwogpa.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRxZG1yemNubmNpYXR2aXdvZ3BhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYwMTM1MDcsImV4cCI6MjA3MTU4OTUwN30.I1D_7G9rshIHeA82VQ0Q-GD7oC3ovypkas7LG3FTDbo';
    window.supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true
      }
    });

    // Guest mode system
    window.initGuestMode = function initGuestMode() {
      let guestId = localStorage.getItem('guestId');
      if (!guestId) {
        // Generate anonymous guest ID
        guestId = 'guest_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('guestId', guestId);
        console.log('Created guest session:', guestId);
      }
      
      // Set up guest user object
      const guestUser = {
        id: guestId,
        email: null,
        name: 'Guest User',
        tier: 'free',
        isGuest: true
      };
      
      if (!localStorage.getItem('authToken')) {
        localStorage.setItem('user', JSON.stringify(guestUser));
        console.log('Guest mode active:', guestUser);
        // Ensure UI reflects guest state immediately
        setTimeout(() => renderAuthHeader(), 100);
      }
      
      return guestUser;
    }

    // Keep auth token/user in localStorage so existing fetches work
    supabase.auth.onAuthStateChange(async (_event, session) => {
      const token = session?.access_token || '';
      const user = session?.user ? {
        id: session.user.id,
        email: session.user.email,
        name: (session.user.user_metadata && session.user.user_metadata.name) ? session.user.user_metadata.name : (session.user.email||'').split('@')[0],
        isGuest: false
      } : null;
      
      if (token) {
        localStorage.setItem('authToken', token);
        // Clear guest mode when user signs in
        localStorage.removeItem('guestId');
      } else {
        localStorage.removeItem('authToken');
        // Initialize guest mode if no user session
        if (!user) {
          window.initGuestMode();
        }
      }
      
      if (user) {
        // For authenticated users, always fetch the authoritative tier from backend
        localStorage.setItem('user', JSON.stringify(user));
        console.log('🔍 Authenticated user detected, will fetch tier from backend');
        // Don't render header yet - wait for profile fetch to get correct tier
      } else {
        // Keep guest user if no authenticated user
        const currentUser = JSON.parse(localStorage.getItem('user') || '{}');
        if (!currentUser.isGuest) {
          localStorage.removeItem('user');
          window.initGuestMode();
        }
        window.renderAuthHeader();
      }
      
      // Fetch server-side profile to get authoritative tier
      try{
        if (token) {
          console.log('🔍 Fetching profile for authenticated user with token');
          const profileHeaders = token ? { 'Authorization': `Bearer ${token}` } : {};
          const res = await fetch('/api/profile', { headers: profileHeaders });
          console.log('🔍 Profile fetch response:', res.status, res.ok);
          if (res.ok) {
            const p = await res.json();
            console.log('🔍 Profile data received:', p);
            const u = JSON.parse(localStorage.getItem('user')||'{}');
            u.tier = p.tier || 'team'; // Use backend tier or default to team
            u.isGuest = false; // Ensure authenticated users are not marked as guests
            localStorage.setItem('user', JSON.stringify(u));
            console.log('🔍 Updated user object with backend tier:', u);
            // refresh UI and phrasebook
            window.renderAuthHeader();
            try{ if (typeof renderSavedPhrasebookAll==='function') await renderSavedPhrasebookAll(); }catch{}
          } else {
            console.log('🔍 Profile fetch failed, but user has token - marking as authenticated');
            // If profile fetch fails but we have a token, still mark as not guest with team tier
            const u = JSON.parse(localStorage.getItem('user')||'{}');
            u.isGuest = false;
            u.tier = u.tier || 'team'; // Default to team tier for authenticated users
            localStorage.setItem('user', JSON.stringify(u));
            console.log('🔍 Fallback user object with team tier:', u);
            window.renderAuthHeader();
          }
        } else {
          // No token, ensure guest mode is active
          const currentUser = JSON.parse(localStorage.getItem('user') || '{}');
          if (!currentUser.isGuest) {
            window.initGuestMode();
          }
          window.renderAuthHeader();
        }
      }catch(e){ 
        console.warn('profile fetch failed', e);
        // On error, if we have a token, still mark as authenticated
        if (token) {
          const u = JSON.parse(localStorage.getItem('user')||'{}');
          u.isGuest = false;
          localStorage.setItem('user', JSON.stringify(u));
        }
        window.renderAuthHeader();
      }
    });

    // On initial load, recover session immediately (covers OAuth redirect)
    (async () => {
      try{
        console.log('Checking for existing session...');
        const { data: { session } } = await supabase.auth.getSession();
        const token = session?.access_token;
        console.log('Session found:', !!session, 'Token:', !!token);
        
        // If we arrived via OAuth, clean the hash from the URL once handled
        const hasOAuthTokens = /access_token=|refresh_token=|code=/i.test(location.hash);
        if (hasOAuthTokens) {
          console.log('OAuth tokens detected in URL hash, processing...');
          try { history.replaceState(null, '', location.pathname + location.search); } catch {}
        }
        
        if (token) {
          const user = session.user ? {
            id: session.user.id,
            email: session.user.email,
            name: (session.user.user_metadata && session.user.user_metadata.name) ? session.user.user_metadata.name : (session.user.email||'').split('@')[0],
            isGuest: false
          } : null;
          localStorage.setItem('authToken', token);
          localStorage.removeItem('guestId'); // Clear guest mode
          if (user) {
            user.isGuest = false; // Explicitly mark as not guest
            user.tier = 'team'; // Default to team tier for authenticated users
            localStorage.setItem('user', JSON.stringify(user));
            console.log('🔍 Initial session recovery - set user with team tier:', user);
          }
          try{
            const profileHeaders = token ? { 'Authorization': `Bearer ${token}` } : {};
            const res = await fetch('/api/profile', { headers: profileHeaders });
            if (res.ok) {
              const p = await res.json();
              const u = JSON.parse(localStorage.getItem('user')||'{}');
              u.tier = p.tier || 'team'; // Use backend tier or default to team
              u.isGuest = false; // Ensure not marked as guest
              localStorage.setItem('user', JSON.stringify(u));
              console.log('🔍 Session recovery - updated user with backend tier:', u);
            }
          }catch{}
        } else {
          // No authenticated session, initialize guest mode
          window.initGuestMode();
        }
        // Update header to reflect current state
        window.renderAuthHeader();
      }catch{
        // On error, ensure guest mode is active
        initGuestMode();
        window.renderAuthHeader();
      }
    })();

    window.getAuthToken = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      return session?.access_token || '';
    };
  </script>
  <meta charset="UTF-8" />
  <title>AI Localization Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#f5f5f7;--card:#fff;--text:#0b0b0c;--muted:#6e6e73;--border:#d2d2d7;
      --accent:#007aff;--accent-weak:#e6f0ff;--radius:14px;--radius-pill:999px;
      --shadow:0 10px 30px rgba(0,0,0,.08);--shadow-soft:0 2px 10px rgba(0,0,0,.06);
      --ease:cubic-bezier(.22,.61,.36,1);
      --fs:14px;
    }
    *,*::before,*::after{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text","Helvetica Neue",Arial,system-ui,sans-serif;color:var(--text);background:radial-gradient(80% 100% at 50% -20%,#fff 0,#f6f7fb 60%,var(--bg) 100%)}
    .shell{max-width:1100px;margin:28px auto 48px;padding:0 20px}
    .titlebar{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .title{font-weight:700;letter-spacing:.2px;font-size:28px;margin:6px 0 18px}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid var(--border);background:#fafafa;padding:9px 14px;border-radius:12px;font-size:14px;letter-spacing:.2px;transition:transform .12s var(--ease),box-shadow .12s var(--ease),background .12s,border-color .12s,opacity .12s;box-shadow:var(--shadow-soft);user-select:none;cursor:pointer;display:inline-flex;align-items:center;gap:8px;min-height:36px; transition:
    transform .12s var(--ease),
    box-shadow .18s var(--ease),
    background .18s,
    border-color .18s,
    color .18s,
    opacity .12s,
    filter .22s var(--ease),
    backdrop-filter .22s var(--ease);}
    .btn:hover{transform:translateY(-1px)}
    .btn:active{transform:translateY(0)}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .toggle-btn.active,.style-btn.active{border-color:var(--accent);background:var(--accent-weak);box-shadow:0 0 0 2px var(--accent-weak)}
    .primary{background:var(--accent);color:#fff;border-color:var(--accent);padding:10px 16px;border-radius:12px;box-shadow:0 6px 16px rgba(0,122,255,.25)}
    .card{position:relative;background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:22px;overflow:hidden}
    .section{margin-top:18px}
    .label{display:block;font-size:13px;color:var(--muted);margin:0 0 8px;letter-spacing:.2px}
    .hr{height:1px;background:var(--border);margin:14px 0}

    /* Toasts (validation + errors) */
    .toasts{position:fixed;top:16px;right:16px;display:flex;flex-direction:column;gap:10px;z-index:10000;pointer-events:none}
    .toast{display:flex;align-items:center;gap:10px;background:#fff;border:1px solid var(--border);border-left:4px solid #f59e0b;color:#111;padding:10px 12px;border-radius:12px;box-shadow:var(--shadow-soft);opacity:0;transform:translateY(-6px);transition:opacity .18s var(--ease),transform .18s var(--ease);pointer-events:auto}
    .toast.show{opacity:1;transform:translateY(0)}
    .toast .ticon{width:16px;height:16px;color:#f59e0b}

    /* Modern Tabs: pill + subtle shadow + grab-scroll */
    .tabs-wrap{margin:8px 0 12px}
    .tabs{display:flex;align-items:center;gap:8px;overflow:auto;padding:4px;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow-soft);cursor:grab;-webkit-overflow-scrolling:touch}
    .tabs.grabbing{cursor:grabbing}
    .tabs::-webkit-scrollbar{display:none}
    .tab{position:relative;display:inline-flex;align-items:center;gap:10px;max-width:260px;padding:8px 12px;border:1px solid var(--border);border-radius:999px;background:#fafafa;color:#2c2c2e;cursor:pointer;transition:background .18s,border-color .18s,transform .12s var(--ease),box-shadow .18s}
    .tab.active{background:#fff;border-color:var(--accent);box-shadow:0 0 0 2px var(--accent-weak), var(--shadow-soft)}
    .tab:hover{background:#fff}
    .tab-title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px}
    .tab-ext{opacity:.6;font-size:12px}
    .tab-close{border:1px solid var(--border);border-radius:9px;padding:2px 6px;background:#fff;cursor:pointer;font-size:12px}

    textarea{
      width:100%;min-height:140px;max-height:42vh;resize:vertical;border:1px solid var(--border);
      border-radius:12px;padding:12px 14px;background:#fff;box-shadow:var(--shadow-soft);
      line-height:1.55;outline:none;transition:box-shadow .18s var(--ease),border-color .18s var(--ease);
      font-family:inherit;font-size:var(--fs);overflow:hidden /* was auto – causes arrows on short text */
    }
    textarea:focus{border-color:var(--accent);box-shadow:0 0 0 4px var(--accent-weak)}
    .rich{min-height:200px;max-height:42vh;overflow:auto;border:1px solid var(--border);border-radius:12px;padding:12px 14px;background:#fff;box-shadow:var(--shadow-soft);line-height:1.55;outline:none;white-space:pre-wrap;font-size:var(--fs);resize:vertical}
    .is-hidden{display:none!important}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;min-height:38px}
    .substyle{border:1px solid var(--border);border-radius:12px;background:#fff;box-shadow:var(--shadow-soft);padding:12px}
    .substyle-trigger{display:flex;justify-content:space-between;align-items:center;width:100%;background:#fff;border:0;padding:8px 4px;font-size:14px;cursor:pointer}
    .chev{transition:transform .22s var(--ease)}
    .chev.up{transform:rotate(180deg)}
    .substyle-panel{overflow:hidden;opacity:0;max-height:0;transition:max-height .28s var(--ease),opacity .2s var(--ease)}
    .substyle-panel.open{opacity:1;max-height:220px}
    .substyle-scroll{max-height:180px;overflow:auto;padding:8px 0 2px}
    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{border:1px solid var(--border);background:#fafafa;border-radius:999px;padding:6px 12px;font-size:13px;transition:background .12s,border-color .12s,transform .12s var(--ease);cursor:pointer}
    .chip:hover{transform:translateY(-1px)}
    .chip.active{background:var(--accent-weak);border-color:var(--accent)}

    /* Split view + rows */
    .mode-wrap{position:relative;transition:height .34s var(--ease);min-height:360px;height:auto}
    .mode-wrap:not(.layered) .view{display:none;position:static;opacity:1;transform:none;filter:none;pointer-events:auto}
    .mode-wrap:not(.layered) .view.active{display:block}
    .mode-wrap.layered .view{display:block;position:absolute;left:0;right:0;top:0;opacity:0;transform:translateY(8px) scale(.995);filter:blur(6px);transition:opacity .34s var(--ease),transform .34s var(--ease),filter .30s var(--ease);pointer-events:none;will-change:opacity,transform,filter}
    .mode-wrap.layered .view.active{opacity:1;transform:translateY(0) scale(1);filter:none;pointer-events:auto}
    @media (prefers-reduced-motion:reduce){.mode-wrap{transition:none}.mode-wrap.layered .view{transition:none;filter:none;transform:none}}

    .split-grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;align-items:start}
    @media (max-width:900px){.split-grid{grid-template-columns:1fr}}
    .paneCard{border:1px solid var(--border);border-radius:12px;background:#fff;box-shadow:var(--shadow-soft);padding:12px;position:relative;display:flex;flex-direction:column;min-width:0}
    .paneHead{font-size:13px;color:#3a3a3c;font-weight:600;margin:0 0 6px}
    .segbox{border:1px solid var(--border);border-radius:12px;background:#fff;padding:12px;max-height:70vh;overflow:auto;position:relative;flex:1;min-width:0;word-wrap:break-word;height:auto}
    .view.split .segbox{max-height:none;height:auto;overflow:auto}
    /* Prevent scroll anchoring jumps inside segment boxes */
    #segSrcBox, #segTgtBox{overflow-anchor:none;scrollbar-gutter:stable both-edges}
    #segSrcBox,#segTgtBox{padding-right:72px;padding-bottom:56px}
    .segrow{display:flex;gap:10px;align-items:stretch;padding:12px 6px;border-bottom:1px dashed #ececec;min-width:0;min-height:auto}
    .segrow:last-child{border-bottom:none}
    .lineno{min-width:26px;height:22px;line-height:22px;text-align:center;border:1px solid var(--border);border-radius:999px;font-size:12px;color:#666;background:#f6f8ff;margin-top:2px;user-select:none}
    .segcontent{flex:1;min-width:0;overflow-wrap:break-word;width:100%;height:auto;display:flex;flex-direction:column}
    .segtext{white-space:pre-wrap;word-wrap:break-word;line-height:1.55;font-family:inherit;font-size:var(--fs);min-width:0;overflow-wrap:anywhere;width:100%;height:auto;display:block;flex:1;overflow:visible;max-height:none}
    /* Target segment textareas: clean styling */
    .segtext-textarea{
      width:100%;min-height:40px;border:1px solid transparent;
      border-radius:8px;padding:8px;background:transparent;
      font-family:inherit;font-size:var(--fs);line-height:1.55;
      resize:none;overflow:hidden;
      transition:border-color .18s var(--ease);
    }
    .segtext-textarea:focus{
      outline:none;border-color:var(--accent);
      box-shadow:0 0 0 2px var(--accent-weak);
    }
    .segmeta{margin-top:6px;font-size:12px;color:#666}
    .segrow.placeholder .segtext{color:#aaa}

    .segbox textarea[data-srt]{
      width:100%;min-height:44px;border:1px solid var(--border);
      border-radius:10px;padding:8px 10px;resize:none;line-height:1.55;
      font-family:inherit;font-size:var(--fs);background:#fff;box-shadow:var(--shadow-soft);
      overflow:auto;max-height:none;height:auto
    }

    .split-footer{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-top:10px;padding-top:10px;border-top:1px solid var(--border)}
    .split-footer .label{margin:0;color:#888;font-size:12px;flex:1 1 auto;min-width:0}
    
    /* (removed Edit Mode styles) */

    /* Status tab (replaces progress bar; collapsible with smooth motion) */
    .upload-progress-bar{
      margin:0; /* collapsed state */
      padding:0 20px; /* vertical padding animated */
      background:rgba(255,255,255,0.95);
      border:2px solid var(--accent);
      border-radius:12px;
      box-shadow:0 8px 32px rgba(0,0,0,0.12);
      opacity:0;
      transform:translateY(-12px); /* appears from behind input */
      transition:opacity .38s var(--ease), transform .38s var(--ease),
                 margin .38s var(--ease), padding .38s var(--ease),
                 max-height .42s var(--ease);
      backdrop-filter:blur(12px);
      -webkit-backdrop-filter:blur(12px);
      z-index:1000;
      position:relative;
      overflow:hidden;
      max-height:0; /* collapse space when hidden */
      pointer-events:none;
    }
    .upload-progress-bar.show{
      opacity:1;
      transform:translateY(0);
      margin:12px 0;
      padding:12px 20px;
      max-height:72px; /* smooth push/pull of content */
      pointer-events:auto;
    }
    /* Subtle pulse while busy */
    .upload-progress-bar.is-busy{--pulse:rgba(0,122,255,.22);animation:pulseShadow 1.6s var(--ease) infinite}
    @keyframes pulseShadow{0%{box-shadow:0 8px 32px rgba(0,0,0,.12),0 0 0 0 var(--pulse)}70%{box-shadow:0 8px 32px rgba(0,0,0,.12),0 0 0 8px rgba(0,122,255,0)}100%{box-shadow:0 8px 32px rgba(0,0,0,.12),0 0 0 0 rgba(0,122,255,0)}}
    /* Typing ellipsis on the status text */
    .upload-progress-bar.is-busy .upload-progress-text[data-ellipsis]::after{content:attr(data-ellipsis);display:inline-block;width:1.4em;text-align:left;animation:typingDots 1.2s steps(4,end) infinite}
    @keyframes typingDots{0%{content:""}25%{content:"."}50%{content:".."}75%{content:"..."}100%{content:""}}
    .upload-progress-text{
      font-size:15px;
      font-weight:600;
      color:var(--accent);
      margin-bottom:8px;
      text-align:center;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    /* Hide bar visuals; we only keep status text per requirement */
    .upload-progress-track{ display:none }
    .upload-progress-fill{ display:none }

    /* Result actions container (outside text box) */
    .result-actions{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      margin-top:12px;
      padding:0;
    }
    
    /* Legacy action strip (for split view) */
    .action-strip{position:absolute;right:12px;bottom:12px;display:inline-flex;align-items:center;gap:8px;z-index:2}
    .ctl-btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;height:34px;padding:0 12px;border-radius:12px;border:1px solid var(--border);background:#fff;box-shadow:var(--shadow-soft);cursor:pointer;transition:transform .18s var(--ease),background .18s,border-color .18s,color .18s,filter .22s var(--ease),backdrop-filter .22s var(--ease)}
    .ctl-btn svg{width:16px;height:16px}
    .ctl-btn.copy-btn{min-width:110px}
    .split-footer .ctl-btn{white-space:nowrap}
    .ctl-btn:hover{
      background:rgba(255,255,255,.95);
      border-color:var(--accent);
      color:var(--accent);
      transform:translateY(-1px);
      box-shadow:0 4px 18px rgba(0,0,0,.12), 0 0 0 2px var(--accent-weak);
    }
    .copy-btn.copied{background:var(--accent-weak);border-color:var(--accent);color:var(--accent);transform:translateY(-1px);backdrop-filter:blur(3px) saturate(1.12);-webkit-backdrop-filter:blur(3px) saturate(1.12)}

    .no-js .mode-wrap{height:auto!important;min-height:unset!important}
    .no-js .view{position:static;opacity:1;filter:none;transform:none;pointer-events:auto}
    #clearHl{display:none}

    .glass{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(120% 120% at 50% 30%,rgba(255,255,255,.25) 0,rgba(245,245,247,.35) 40%,rgba(245,245,247,.55) 100%);backdrop-filter:blur(8px) saturate(1.1);-webkit-backdrop-filter:blur(8px) saturate(1.1);opacity:0;pointer-events:none;transform:scale(1.02);transition:opacity .28s var(--ease),transform .28s var(--ease);z-index:5}
    .glass.show{opacity:1;pointer-events:auto;transform:scale(1)}
    .glass-content{display:flex;flex-direction:column;align-items:center;gap:10px;transform:translateY(6px)}
    .ring{width:28px;height:28px;border-radius:50%;border:3px solid rgba(0,0,0,.12);border-top-color:var(--accent);animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .glass-text{font-size:13px;color:var(--muted);letter-spacing:.2px}


  .lang-overlay{position:fixed; inset:0; z-index:10000; display:flex; align-items:center; justify-content:center;
    /* uses the same tuning as the Phrasebook bubble */
    background:radial-gradient(120% 120% at 50% 30%,
      rgb(255 255 255 / var(--save-bubble-alpha, .10)) 0,
      rgb(245 245 247 / var(--save-bubble-alpha, .10)) 40%,
      rgb(245 245 247 / var(--save-bubble-alpha, .10)) 100%);
    backdrop-filter:blur(var(--save-bubble-blur, 2px)) saturate(1.28);
    -webkit-backdrop-filter:blur(var(--save-bubble-blur, 2px)) saturate(1.28);
    opacity:0; pointer-events:none; transform:scale(1.02); transition:opacity .28s var(--ease), transform .28s var(--ease)}

    .lang-overlay.show{opacity:1; pointer-events:auto; transform:scale(1)}
    .lang-sheet{width:min(720px,92vw); background:#fff; border:1px solid var(--border); border-radius:16px; box-shadow:var(--shadow); overflow:hidden; overflow-x:hidden; transform:translateY(8px) scale(.995); filter:blur(var(--save-bubble-blur, 4px)); transition:transform .34s var(--ease), filter .30s var(--ease), opacity .34s var(--ease); opacity:0}
    .lang-overlay.show .lang-sheet{transform:translateY(0) scale(1); filter:none; opacity:1}
    .lang-head{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid var(--border)}
    .lang-title{font-weight:700}
    .lang-close{border:1px solid var(--border); background:#fafafa; border-radius:10px; padding:6px 10px; cursor:pointer}
    .lang-grid{display:grid; grid-template-columns:1fr 1fr; gap:0; max-height:60vh; overflow:auto; overflow-x:hidden}
    .lang-item{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-top:1px solid #f0f0f3; cursor:pointer; transition:all .18s var(--ease); border-radius:0}
    .lang-item:hover{
      background:var(--accent-weak);
      border-color:var(--accent);
      color:var(--accent);
      transform:translateX(2px);
      box-shadow:0 2px 8px rgba(0,122,255,.12)
    }
    .lang-code{font-size:12px; color:#666}
    .lang-check{opacity:0; transition:opacity .18s var(--ease)}
    .lang-item.active .lang-check{opacity:1; color:var(--accent)}
    .lang-item.active{
      background:rgba(0,122,255,.05);
      border-left:3px solid var(--accent);
      font-weight:600;
    }
    .lang-item.active:hover{
      background:var(--accent-weak);
      transform:translateX(1px);
    }
    .face-btn{display:inline-flex; align-items:center; justify-content:center; gap:6px; min-width:56px}
    .face-btn svg{width:16px;height:16px;stroke:currentColor}

    .or-wrap{display:flex;align-items:center;gap:10px;margin:14px 0}
    .or-wrap::before,.or-wrap::after{content:"";flex:1;height:1px;background:var(--border)}
    .or{font-size:12px;color:var(--muted);letter-spacing:.3px;text-transform:uppercase}

    .dropzone{
      position:relative;border:1.5px dashed var(--border);border-radius:14px;
      background:#fff;padding:18px;display:flex;align-items:center;justify-content:center;
      gap:10px;cursor:pointer;transition:background .18s,border-color .18s,transform .12s var(--ease)
    }
    .dropzone:hover{transform:translateY(-1px)}
    .dropzone input{position:absolute;inset:0;opacity:0;width:100%;height:100%;cursor:pointer}
    .dropzone.drag{border-color:var(--accent);background:var(--accent-weak)}
    .dz-hint{font-size:13px;color:#383a3e}
    .dz-sub{font-size:12px;color:var(--muted)}

    .file-badge{display:inline-flex;align-items:center;gap:10px;border:1px solid var(--border);
      border-radius:12px;padding:8px 10px;background:#fff;box-shadow:var(--shadow-soft)}
    .file-badge b{font-weight:600}
    .file-badge .kill{margin-left:6px;border:1px solid var(--border);border-radius:10px;padding:4px 8px;cursor:pointer}

    .substyle-note{margin-top:10px;font-size:13px;color:#3a3a3c;opacity:0;transform:translateY(4px);
      transition:opacity .22s var(--ease), transform .22s var(--ease)}
    .substyle-note.show{opacity:1;transform:translateY(0)}
    .substyle-note b{font-weight:600}

        /* Glassy toolbar buttons (Language + History) */
    #uiLangBtn,
    #historyBtn{
      background: rgba(255,255,255,.45);                 /* transparent look */
      -webkit-backdrop-filter: blur(6px) saturate(1.15); /* Safari */
      backdrop-filter: blur(6px) saturate(1.15);
      border-color: rgba(0,0,0,.08);
      box-shadow: 0 2px 10px rgba(0,0,0,.08);
    }

    /* Red accent on Sign out hover (match style with blue variant) */
    #signOutBtnTop:hover{
      background: rgba(255,255,255,.32);
      color: #ef4444;
      border-color: #ef4444;
      box-shadow: 0 4px 18px rgba(0,0,0,.12), 0 0 0 2px rgba(239,68,68,.18);
    }

    /* Blue accent on Split View and New Tab hover (match Brand Kit/History style) */
    #toggleSplit:hover,
    #addTextTabBtn:hover{
      background: rgba(255,255,255,.32);
      color: var(--accent);
      border-color: var(--accent);
      box-shadow: 0 4px 18px rgba(0,0,0,.12), 0 0 0 2px var(--accent-weak);
    }

    /* Transparent hover + blue accent ring */
    #uiLangBtn:hover,
    #historyBtn:hover{
      background: rgba(255,255,255,.32);                 /* stay transparent */
      color: var(--accent);                              /* blue text/icon */
      border-color: var(--accent);                       /* blue border */
      box-shadow: 0 4px 18px rgba(0,0,0,.12),
                  0 0 0 2px var(--accent-weak);          /* subtle blue halo */
    }

    /* Active press state stays transparent */
    #uiLangBtn:active,
    #historyBtn:active{
      transform: translateY(0);
      filter: saturate(1.06);
      box-shadow: 0 2px 10px rgba(0,0,0,.10),
                  0 0 0 2px var(--accent-weak);
    }

    /* Keyboard focus — blue focus ring */
    #uiLangBtn:focus-visible,
    #historyBtn:focus-visible{
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-weak);
    }

  </style>
  <style>
    /* Minimal modal base styles */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:9999;display:none;align-items:center;justify-content:center}
    .modal-card{background:#fff;border:1px solid var(--border);border-radius:14px;box-shadow:var(--shadow-hard);width:min(440px,92vw);padding:20px}
    .modal-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:14px}
    /* Animated dropdown */
    @keyframes popIn{from{opacity:0;transform:translateY(-6px) scale(.98)}to{opacity:1;transform:translateY(0) scale(1)}}
    .menu-show{display:block !important;animation:popIn .16s ease-out}

    /* Auth modal — polished visuals */
    #authModal .modal-card{animation:popIn .18s ease-out}
    #authModal .modal-head h3{margin:0;font-weight:600;font-size:18px;color:#0f172a}
    #authModal .auth-body{display:grid;gap:12px}
    #authModal .btn-google{display:flex;align-items:center;justify-content:center;gap:8px;background:#fff;border:1px solid var(--border);border-radius:10px;padding:10px 12px;color:#111}
    #authModal .btn-google:hover{border-color:var(--accent);box-shadow:0 6px 22px rgba(0,0,0,.10),0 0 0 2px var(--accent-weak)}
    #authModal .btn-google svg{width:18px;height:18px}
    #authModal .auth-divider{display:flex;align-items:center;gap:10px;color:#6b7280;font-size:12px}
    #authModal .auth-divider:before,#authModal .auth-divider:after{content:"";flex:1;height:1px;background:#e5e7eb}
    #authModal .auth-tabs{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    #authModal .auth-tabs .btn{border-radius:10px;padding:9px 10px;justify-content:center;transition:all .18s var(--ease)}
    #authModal .auth-tabs .btn.active{background:var(--accent);color:#fff;border-color:var(--accent);box-shadow:0 0 0 2px var(--accent-weak)}
    #authModal .auth-form{display:grid;gap:10px}
    #authModal .auth-field{display:grid;gap:6px;transition:all .18s var(--ease)}
    #authModal .auth-field label{font-size:12px;color:#374151}
    #authModal .auth-input{padding:10px;border:1px solid var(--border);border-radius:10px;font-size:14px;transition:all .18s var(--ease)}
    #authModal .auth-input:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 3px var(--accent-weak)}
    #authModal .auth-primary{background:var(--accent);color:#fff;border-color:var(--accent);border-width:1px;border-style:solid;border-radius:10px;padding:10px;justify-content:center;display:inline-flex;transition:all .18s var(--ease)}
    #authModal .auth-primary:hover{filter:saturate(1.08);box-shadow:0 6px 16px rgba(0,122,255,.25)}
    #authModal .auth-msg{font-size:12px;color:#e11d48;min-height:16px}
    #authModal .auth-close{background:transparent}
    
    /* Auth state transitions */
    #authModal .auth-field{transition:all .25s var(--ease)}
    #authModal .auth-field.hidden{opacity:0;transform:translateY(-8px);max-height:0;margin:0;overflow:hidden}
    #authModal .auth-field.visible{opacity:1;transform:translateY(0);max-height:100px}
    
    /* Check email state */
    #authModal .check-email{text-align:center;padding:20px 0}
    #authModal .check-email-icon{font-size:48px;margin-bottom:16px;color:var(--accent)}
    #authModal .check-email-title{font-size:18px;font-weight:600;margin-bottom:8px;color:#0f172a}
    #authModal .check-email-text{color:#6b7280;font-size:14px;line-height:1.5;margin-bottom:20px}
    #authModal .check-email-back{background:transparent;color:var(--accent);border:1px solid var(--accent)}
  </style>
  <!-- Login/Register Modal -->
  <div id="authModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true">
      <div class="modal-head">
        <div>
          <h3>Sign in</h3>
        </div>
        <button id="authClose" class="btn auth-close" aria-label="Close">✕</button>
      </div>
      <div class="auth-body">
        <button id="authGoogle" class="btn btn-google" type="button" aria-label="Continue with Google">
          <img src="/Google_Favicon_2025.svg" alt="Google" width="18" height="18" style="display:inline-block"/>
          Continue with Google
        </button>
        <div class="auth-divider"><span>or</span></div>
        <div class="auth-tabs">
          <button id="authTabLogin" class="btn active" type="button">Login</button>
          <button id="authTabRegister" class="btn" type="button">Register</button>
        </div>
        <div id="authFormContainer">
          <form id="authForm" class="auth-form">
            <div class="auth-field hidden" id="authNameField">
              <label for="authName">Full name</label>
              <input id="authName" class="auth-input" placeholder="Full name" />
            </div>
            <div class="auth-field">
              <label for="authEmail">Email</label>
              <input id="authEmail" class="auth-input" placeholder="Email" type="email" required />
            </div>
            <div class="auth-field">
              <label for="authPassword">Password</label>
              <input id="authPassword" class="auth-input" placeholder="Password" type="password" required />
            </div>
            <button id="authSubmit" class="btn auth-primary" type="submit">Sign in</button>
            <div id="authMsg" class="auth-msg"></div>
          </form>
          
          <!-- Check email state -->
          <div id="checkEmailState" class="check-email" style="display:none">
            <div class="check-email-icon">📧</div>
            <div class="check-email-title">Check your email</div>
            <div class="check-email-text">We've sent you a confirmation link. Please check your email and click the link to verify your account.</div>
            <button id="backToLogin" class="btn check-email-back">Back to Sign in</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</head>
<body class="no-js">
  <div class="shell">
    <div class="titlebar">
      <div class="title" data-i18n="title">AI Localization Prototype</div>
      <div class="toolbar">
        <button id="toggleSplit" class="btn" type="button" disabled data-i18n="split_view">Split View</button>
        <button id="clearHl" class="btn" type="button" disabled data-i18n="clear_highlights">Clear Highlights</button>
        <button id="uiLangBtn" class="btn face-btn" aria-haspopup="dialog" aria-expanded="false" title="Change language">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.75" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M3 12h18M12 3a12 12 0 0 1 0 18M12 3a12 12 0 0 0 0 18"></path></svg>
          <span>En</span>
        </button>
        <!-- New Tab button moved here (next to language) -->
        <button id="addTextTabBtn" class="btn" title="New tab" data-i18n="new_tab">New Tab</button>
        <!-- Tier badge -->
        <span id="tierBadge" class="btn" style="display:none; background:#eef3ff; color:#1e40af; border-color:#c7d2fe"></span>
        
        <!-- Character limit indicator -->
        <div id="charLimitIndicator" class="char-limit-indicator" style="display:none;">
          <div class="char-limit-content">
            <div class="char-limit-text">
              <span id="charUsed">0</span>/<span id="charLimit">1000</span>
            </div>
            <div class="char-limit-bar">
              <div id="charProgress" class="char-limit-progress"></div>
            </div>
          </div>
        </div>
        <!-- Auth: Sign in (Supabase) / Sign out -->
        <button id="signInBtn" class="btn" type="button">Sign in</button>
        <button id="signOutBtnTop" class="btn" type="button" style="display:none">Sign out</button>
      </div>
    </div>

    <!-- Tabs bar -->
    <div class="tabs-wrap">
      <div id="tabBar" class="tabs" role="tablist" aria-label="Documents"></div>
    </div>

    <div class="card" id="cardRoot" aria-live="polite" aria-busy="false">
      <div id="modeWrap" class="mode-wrap">
        <!-- STACK (normal) -->
        <div id="stackArea" class="view active">
          <div class="section">
            <label class="label" for="inputText" data-i18n="input_label">Input Text</label>
            <textarea id="inputText" data-maxh="420" placeholder="Paste or write your text here…"></textarea>
          </div>

          <div class="or-wrap"><span class="or" data-i18n="or">Or</span></div>
          <div class="section">
            <div id="dropzone" class="dropzone" role="button" tabindex="0" aria-label="Upload files">
              <input id="fileInput" type="file" accept=".txt,.srt,.docx,.pdf" multiple>
              <div>
                <div class="dz-hint" data-i18n="upload_hint">Drag & drop a .txt, .docx, .pdf, or .srt here</div>
                <div class="dz-sub" data-i18n="upload_sub">…or click to browse</div>
              </div>
            </div>

            <!-- Badge hidden for tabs UI, kept for backward-compat -->
            <div id="fileBadgeWrap" class="section is-hidden">
              <span class="file-badge" id="fileBadge">
                <span id="fileMeta"></span>
                <button id="clearFile" class="kill" type="button">✕</button>
              </span>
            </div>
          </div>

          <div class="hr"></div>

          <div class="section">
            <div class="label" data-i18n="target_lang">Target Language</div>
            <div class="row" id="langButtonsRow"></div>
          </div>

          <div class="section">
            <div class="label" data-i18n="loc_style">Localization Style</div>
            <div class="row" id="styleButtonsRow"></div>
          </div>

          <div class="section is-hidden" id="subStyleContainer">
            <div class="substyle">
              <button type="button" class="substyle-trigger" id="substyleTrigger">
                <span id="substyleTitle" data-i18n="substyle">Sub-style</span>
                <span id="substyleChevron" class="chev">▾</span>
              </button>
              <div id="subStylePanel" class="substyle-panel">
                <div class="substyle-scroll">
                  <div id="chipsWrap" class="chips"></div>
                </div>
                <!-- Microcopy line lives here; created in JS -->
              </div>
            </div>
          </div>

          <div class="section">
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <button id="submitBtn" class="btn primary" type="button" data-i18n="submit">Submit</button>
              <button id="submitAllBtn" class="btn is-hidden" type="button" title="Submit all open files">Submit All</button>
            </div>
          </div>

          <div class="section">
            <label class="label" for="outputText" data-i18n="result_label">Result</label>
            <div class="output-wrapper" style="position:relative">
              <textarea id="outputText" data-maxh="420" readonly style="min-height:160px;"></textarea>
              <div id="outputRich" class="rich is-hidden" contenteditable="true" aria-label="Result editor"></div>
            </div>
            <div class="result-actions">
              <button id="copyBtn" class="ctl-btn copy-btn" title="Copy result">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="9" y="9" width="13" height="13" rx="3"></rect>
                  <rect x="2" y="2" width="13" height="13" rx="3"></rect>
                </svg>
                <span data-i18n="copy">Copy</span>
              </button>
              <button id="downloadInlineBtn" class="ctl-btn" type="button" title="Download localized" data-i18n="download_localized">Download</button>
              <button id="downloadAllInlineBtn" class="ctl-btn" type="button" title="Download all (.zip)" data-i18n="download_all_zip">Download all (.zip)</button>
            </div>
          </div>
        </div>

        <!-- SPLIT -->
        <div id="splitArea" class="view">
          <div class="section">
            <div class="split-grid">
              <div class="paneCard">
                <div class="paneHead" data-i18n="pane_input">Input</div>
                <div id="segSrcBox" class="segbox" aria-label="Source segments"></div>
              </div>

              <!-- FIX: removed stray extra '<' that broke the grid -->
              <div class="paneCard" id="resultPaneCard">
                <div class="paneHead" data-i18n="pane_result">Result</div>
                <div id="segTgtBox" class="segbox" aria-label="Target segments"></div>
              </div>
            </div>

            <div class="split-footer">
              <div class="label">Tip: Split View shows sentence lines with timecodes (SRT) and word &amp; character counts for QA.</div>
              <div style="display:flex;gap:8px;flex-wrap:nowrap;align-items:center">
                <button id="copySplitBtn" class="ctl-btn copy-btn" title="Copy result" aria-label="Copy result">
                  <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="3"></rect>
                    <rect x="2" y="2" width="13" height="13" rx="3"></rect>
                  </svg>
                  <span data-i18n="copy">Copy</span>
                </button>
                <button id="downloadSplitBtn" class="ctl-btn" type="button" title="Download localized" data-i18n="download_localized">Download</button>
                <button id="downloadAllSplitBtn" class="ctl-btn" type="button" title="Download all (.zip)" data-i18n="download_all_zip">Download all (.zip)</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="glassLoader" class="glass" aria-hidden="true">
        <div class="glass-content">
          <div class="ring"></div>
          <div class="glass-text">Localizing…</div>
        </div>
      </div>
    </div>
  </div>

  <div id="toasts" class="toasts" aria-live="polite"></div>

  <!-- Language overlay -->
  <div id="langOverlay" class="lang-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="lang-sheet" role="document">
      <div class="lang-head">
        <div class="lang-title" data-i18n="choose_lang">Select your language</div>
        <button class="lang-close" id="langCloseBtn" aria-label="Close">✕</button>
      </div>
      <div class="lang-grid" id="langGrid"></div>
    </div>
  </div>

  <script>
    /* =======================
       0) Style labels + MICROCOPY
       ======================= */

    // STYLE_I18N: localized style & sub-style labels used by buttons/chips
    // (EN, ID, ZH, FR, ES)
    window.STYLE_I18N = {
      en: {
        style: {
          formal:"Formal", casual:"Casual", marketing:"Marketing", dubbing:"Dubbing",
          creative:"Creative", technical:"Technical", legal:"Legal", medical:"Medical",
          journalistic:"Journalistic", corporate:"Corporate", entertainment:"Entertainment", educational:"Educational"
        },
        sub: {
          general:"General", academic:"Academic", scientific:"Scientific",
          chat:"Chat", gaming:"Gaming", "street-talk":"Street Talk", comedy:"Comedy", "social-media":"Social Media",
          promotional:"Promotional", persuasive:"Persuasive", "product-descriptions":"Product Description",
          "brand-storytelling":"Brand Storytelling", "seo-friendly":"SEO‑Friendly", "email-campaigns":"Email Campaigns",
          "event-promotion":"Event Promotion", "influencer-ugc-style":"Influencer/UGC Style",
          dialogue:"Dialogue", narration:"Narration",
          "literary-adaptation":"Literary Adaptation", "slogan-tagline-writing":"Slogan/Tagline Writing",
          "poetic-tone":"Poetic Tone", "narrative-prose":"Narrative Prose",
          "software-documentation":"Software Documentation", "engineering-manuals":"Engineering Manuals",
          "product-specs":"Product Specs", "api-guides":"API Guides",
          contracts:"Contracts", "terms-conditions":"Terms & Conditions", "compliance-docs":"Compliance Docs",
          "privacy-policies":"Privacy Policies", constitutional:"Constitutional",
          "patient-friendly-explanation":"Patient‑friendly Explanation", "research-abstracts":"Research Abstracts",
          "clinical-documentation":"Clinical Documentation", "health-campaigns":"Health Campaigns",
          "news-reports":"News Reports", "editorial-opinion":"Editorial Opinion", "feature-articles":"Feature Articles",
          "press-releases":"Press Releases", "internal-communications":"Internal Communications",
          "investor-relations":"Investor Relations", "annual-reports":"Annual Reports",
          "professional-presentations":"Professional Presentations",
          subtitling:"Subtitling", screenwriting:"Screenwriting", "script-adaptation":"Script Adaptation", "character-dialogue":"Character Dialogue",
          "e-learning":"E‑learning", "step-by-step-guides":"Step‑by‑step Guides", "academic-tutorials":"Academic Tutorials", "test-preparation":"Test Preparation"
        }
      },
      id: {
        style: {
          formal:"Formal", casual:"Kasual", marketing:"Pemasaran", dubbing:"Dubbing",
          creative:"Kreatif", technical:"Teknis", legal:"Hukum", medical:"Medis",
          journalistic:"Jurnalistik", corporate:"Korporat", entertainment:"Hiburan", educational:"Edukasi"
        },
        sub: {
          general:"Umum", academic:"Akademik", scientific:"Ilmiah",
          chat:"Obrolan", gaming:"Gim", "street-talk":"Bahasa Jalanan", comedy:"Komedi", "social-media":"Media Sosial",
          promotional:"Promosi", persuasive:"Persuasif", "product-descriptions":"Deskripsi Produk",
          "brand-storytelling":"Kisah Merek", "seo-friendly":"Ramah SEO", "email-campaigns":"Kampanye Email",
          "event-promotion":"Promosi Acara", "influencer-ugc-style":"Gaya Influencer/UGC",
          dialogue:"Dialog", narration:"Narasi",
          "literary-adaptation":"Adaptasi Sastra", "slogan-tagline-writing":"Slogan/Tagline",
          "poetic-tone":"Nada Puitis", "narrative-prose":"Prosa Naratif",
          "software-documentation":"Dokumentasi Perangkat Lunak", "engineering-manuals":"Manual Teknik",
          "product-specs":"Spesifikasi Produk", "api-guides":"Panduan API",
          contracts:"Kontrak", "terms-conditions":"Syarat & Ketentuan", "compliance-docs":"Dokumen Kepatuhan",
          "privacy-policies":"Kebijakan Privasi", constitutional:"Konstitusional",
          "patient-friendly-explanation":"Penjelasan Ramah Pasien", "research-abstracts":"Abstrak Riset",
          "clinical-documentation":"Dokumentasi Klinis", "health-campaigns":"Kampanye Kesehatan",
          "news-reports":"Laporan Berita", "editorial-opinion":"Opini Editorial", "feature-articles":"Artikel Fitur",
          "press-releases":"Siaran Pers", "internal-communications":"Komunikasi Internal",
          "investor-relations":"Hubungan Investor", "annual-reports":"Laporan Tahunan",
          "professional-presentations":"Presentasi Profesional",
          subtitling:"Subtitel", screenwriting:"Penulisan Skenario", "script-adaptation":"Adaptasi Naskah", "character-dialogue":"Dialog Karakter",
          "e-learning":"E‑learning", "step-by-step-guides":"Panduan Langkah Demi Langkah", "academic-tutorials":"Tutorial Akademik", "test-preparation":"Persiapan Ujian"
        }
      },
      zh: {
        style: {
          formal:"正式", casual:"日常", marketing:"市场营销", dubbing:"配音",
          creative:"创意", technical:"技术", legal:"法律", medical:"医学",
          journalistic:"新闻", corporate:"企业", entertainment:"娱乐", educational:"教育"
        },
        sub: {
          general:"通用", academic:"学术", scientific:"科学",
          chat:"聊天", gaming:"游戏", "street-talk":"街头口语", comedy:"喜剧", "social-media":"社交媒体",
          promotional:"促销", persuasive:"说服型", "product-descriptions":"产品描述",
          "brand-storytelling":"品牌故事", "seo-friendly":"SEO 友好", "email-campaigns":"电子邮件营销",
          "event-promotion":"活动推广", "influencer-ugc-style":"KOL/UGC 风格",
          dialogue:"对话", narration:"旁白",
          "literary-adaptation":"文学改写", "slogan-tagline-writing":"口号/标语",
          "poetic-tone":"诗意语调", "narrative-prose":"叙事散文",
          "software-documentation":"软件文档", "engineering-manuals":"工程手册",
          "product-specs":"产品规格", "api-guides":"API 指南",
          contracts:"合同", "terms-conditions":"条款与条件", "compliance-docs":"合规文件",
          "privacy-policies":"隐私政策", constitutional:"宪法类",
          "patient-friendly-explanation":"患者易懂说明", "research-abstracts":"研究摘要",
          "clinical-documentation":"临床文档", "health-campaigns":"健康宣传",
          "news-reports":"新闻报道", "editorial-opinion":"社论/评论", "feature-articles":"特写报道",
          "press-releases":"新闻稿", "internal-communications":"内部沟通",
          "investor-relations":"投资者关系", "annual-reports":"年度报告",
          "professional-presentations":"专业演示",
          subtitling:"字幕", screenwriting:"编剧", "script-adaptation":"剧本改编", "character-dialogue":"人物对白",
          "e-learning":"在线学习", "step-by-step-guides":"步骤指南", "academic-tutorials":"学术教程", "test-preparation":"考试准备"
        }
      },
      fr: {
        style: {
          formal:"Formel", casual:"Décontracté", marketing:"Marketing", dubbing:"Doublage",
          creative:"Créatif", technical:"Technique", legal:"Juridique", medical:"Médical",
          journalistic:"Journalistique", corporate:"Entreprise", entertainment:"Divertissement", educational:"Éducatif"
        },
        sub: {
          general:"Général", academic:"Académique", scientific:"Scientifique",
          chat:"Discussion", gaming:"Jeu vidéo", "street-talk":"Argot de rue", comedy:"Comédie", "social-media":"Réseaux sociaux",
          promotional:"Promotionnel", persuasive:"Persuasif", "product-descriptions":"Descriptions produit",
          "brand-storytelling":"Récit de marque", "seo-friendly":"Optimisé SEO", "email-campaigns":"Campagnes e‑mail",
          "event-promotion":"Promotion d’événement", "influencer-ugc-style":"Style influenceur/UGC",
          dialogue:"Dialogue", narration:"Narration",
          "literary-adaptation":"Adaptation littéraire", "slogan-tagline-writing":"Slogan/Baseline",
          "poetic-tone":"Ton poétique", "narrative-prose":"Prose narrative",
          "software-documentation":"Documentation logicielle", "engineering-manuals":"Manuels d’ingénierie",
          "product-specs":"Spécifications produit", "api-guides":"Guides API",
          contracts:"Contrats", "terms-conditions":"Conditions générales", "compliance-docs":"Documents de conformité",
          "privacy-policies":"Politiques de confidentialité", constitutional:"Constitutionnel",
          "patient-friendly-explanation":"Explication accessible au patient", "research-abstracts":"Résumés de recherche",
          "clinical-documentation":"Documentation clinique", "health-campaigns":"Campagnes de santé",
          "news-reports":"Comptes‑rendus", "editorial-opinion":"Tribune/Opinion", "feature-articles":"Articles de fond",
          "press-releases":"Communiqués de presse", "internal-communications":"Communications internes",
          "investor-relations":"Relations investisseurs", "annual-reports":"Rapports annuels",
          "professional-presentations":"Présentations professionnelles",
          subtitling:"Sous‑titres", screenwriting:"Écriture de scénario", "script-adaptation":"Adaptation de script", "character-dialogue":"Dialogue de personnage",
          "e-learning":"E‑learning", "step-by-step-guides":"Guides pas à pas", "academic-tutorials":"Tutoriels académiques", "test-preparation":"Préparation aux examens"
        }
      },
      es: {
        style: {
          formal:"Formal", casual:"Casual", marketing:"Marketing", dubbing:"Doblaje",
          creative:"Creativo", technical:"Técnico", legal:"Legal", medical:"Médico",
          journalistic:"Periodístico", corporate:"Corporativo", entertainment:"Entretenimiento", educational:"Educativo"
        },
        sub: {
          general:"General", academic:"Académico", scientific:"Científico",
          chat:"Chat", gaming:"Videojuegos", "street-talk":"Jerga callejera", comedy:"Comedia", "social-media":"Redes sociales",
          promotional:"Promocional", persuasive:"Persuasivo", "product-descriptions":"Descripciones de producto",
          "brand-storytelling":"Relato de marca", "seo-friendly":"Optimizado para SEO", "email-campaigns":"Campañas de correo",
          "event-promotion":"Promoción de eventos", "influencer-ugc-style":"Estilo influencer/UGC",
          dialogue:"Diálogo", narration:"Narración",
          "literary-adaptation":"Adaptación literaria", "slogan-tagline-writing":"Slogan/Tagline",
          "poetic-tone":"Tono poético", "narrative-prose":"Prosa narrativa",
          "software-documentation":"Documentación de software", "engineering-manuals":"Manuales de ingeniería",
          "product-specs":"Especificaciones de producto", "api-guides":"Guías de API",
          contracts:"Contratos", "terms-conditions":"Términos y condiciones", "compliance-docs":"Documentos de cumplimiento",
          "privacy-policies":"Políticas de privacidad", constitutional:"Constitucional",
          "patient-friendly-explanation":"Explicación para pacientes", "research-abstracts":"Resúmenes de investigación",
          "clinical-documentation":"Documentación clínica", "health-campaigns":"Campañas de salud",
          "news-reports":"Noticias", "editorial-opinion":"Opinión editorial", "feature-articles":"Artículos de fondo",
          "press-releases":"Notas de prensa", "internal-communications":"Comunicaciones internas",
          "investor-relations":"Relaciones con inversionistas", "annual-reports":"Informes anuales",
          "professional-presentations":"Presentaciones profesionales",
          subtitling:"Subtitulado", screenwriting:"Guion cinematográfico", "script-adaptation":"Adaptación de guion", "character-dialogue":"Diálogo de personaje",
          "e-learning":"E‑learning", "step-by-step-guides":"Guías paso a paso", "academic-tutorials":"Tutoriales académicos", "test-preparation":"Preparación para exámenes"
        }
      }
    };

    // Full microcopy dictionary (EN/ID/ZH/FR/ES)
window.STYLE_MICROCOPY = {
  en: {
    formal: {
      general: "For professional documents and public communication.",
      academic: "For research papers, articles, theses, and books.",
      scientific: "For research papers, abstracts, lab reports, and methods."
    },
    casual: {
      general: "For everyday messages that read simple and friendly.",
      "social-media": "For captions and posts with short lines and hashtags.",
      chat: "For quick, conversational replies. Emojis allowed.",
      gaming: "For gamer slang, short callouts, and team banter.",
      "street-talk": "For casual slang and local flavor. Keep it respectful.",
      comedy: "For jokes and playful wording with a clear punchline."
    },
    marketing: {
      general: "For on-brand marketing text across channels.",
      promotional: "For offers and sales. Clear headlines and urgency.",
      persuasive: "For benefit-focused copy with a strong call to action.",
      "product-descriptions": "For product titles, features, specs, and benefits on product detail pages.",
      "brand-storytelling": "For about pages and campaign narratives with emotion.",
      "seo-friendly": "For keyword-smart copy, meta fields, and web/app copywriting.",
      "social-media": "For posts and ads. Hooks, hashtags, and short lines.",
      "email-campaigns": "For subject lines and body that drive clicks.",
      "event-promotion": "For invites and landing pages with dates, venue, and CTA.",
      "influencer-ugc-style": "For first-person, authentic voice that feels like real users."
    },
    dubbing: {
      general: "For dubbing with natural flow, concise lines, and clean timing.",
      dialogue: "For character lines that fit lip movements and match the scene pace.",
      narration: "For voiceover scripts with smooth pacing and clear emphasis."
    },
    creative: {
      general: "For imaginative writing with a natural, readable voice.",
      "literary-adaptation": "For stories rewritten across languages while preserving tone and imagery.",
      "slogan-tagline-writing": "For short, memorable lines that carry brand voice.",
      "poetic-tone": "For lyrical wording with rhythm and vivid images.",
      "narrative-prose": "For novel-style narration, short stories, and other scene-driven prose with smooth flow."
    },
    technical: {
      general: "For precise technical writing with plain language and correct terms.",
      "software-documentation": "For software user guides and release notes with steps and examples.",
      "engineering-manuals": "For procedures and safety notes with parts, tolerances, and diagrams.",
      "product-specs": "For spec sheets with measurements, materials, and limits.",
      "api-guides": "For endpoints and parameters with example requests and response schemas."
    },
    legal: {
      general: "For formal legal writing that is precise, consistent, and citation ready.",
      contracts: "For clauses, definitions, obligations, and remedies with exact terms.",
      "terms-conditions": "For service terms, acceptable use, warranties, and limitations of liability.",
      "compliance-docs": "For policies and reports that meet regulatory requirements.",
      "privacy-policies": "For data collection, use, retention, and user rights stated clearly.",
      constitutional: "For constitutional text and laws with exact wording and article references."
    },
    medical: {
      general: "For medical content with accurate terms and clear structure.",
      "patient-friendly-explanation": "For plain language instructions and health info patients can act on.",
      "research-abstracts": "For concise summaries of background, methods, results, and conclusions.",
      "clinical-documentation": "For Electronic Health Record notes, discharge summaries, and prescriptions.",
      "health-campaigns": "For public health messages and social posts."
    },
    journalistic: {
      general: "For factual writing with neutral tone and verified sources.",
      "news-reports": "For timely updates that lead with who, what, when, where, and why.",
      "editorial-opinion": "For argued viewpoints with evidence, context, and a clear stance.",
      "feature-articles": "For in-depth stories with background, human detail, and narrative flow.",
      "press-releases": "For organization announcements with key facts, quotes, and contact info."
    },
    corporate: {
      general: "For business writing that is clear, concise, and on brand.",
      "internal-communications": "For memos, announcements, and policy updates.",
      "investor-relations": "For earnings updates, KPIs, and risk disclosures.",
      "annual-reports": "For performance summaries, strategy, and ESG sections.",
      "professional-presentations": "For slide titles, speaker notes, and takeaways."
    },
    entertainment: {
      general: "For film, series, and content with engaging tone and steady pacing.",
      subtitling: "For captions with correct timing, line breaks, and reading speed.",
      screenwriting: "For scene headings, action lines, and dialogue in standard format.",
      "script-adaptation": "For localized scripts that keep plot, humor, and intent.",
      "character-dialogue": "For voices that fit each character and match scene timing."
    },
    educational: {
      general: "For teaching materials with clear structure and plain language.",
      "e-learning": "For online modules, slides, and voiceover scripts in an active tone.",
      "step-by-step-guides": "For how-to instructions with numbered steps and simple wording.",
      "academic-tutorials": "For lecture notes and walkthroughs that explain concepts with examples.",
      "test-preparation": "For practice questions, answer keys, and tips that build exam confidence."
    }
  },

  id: {
    formal: {
      general: "Untuk dokumen profesional dan komunikasi publik.",
      academic: "Untuk makalah riset, artikel, tesis, dan buku.",
      scientific: "Untuk makalah riset, abstrak, laporan laboratorium, dan metode."
    },
    casual: {
      general: "Untuk pesan sehari-hari yang mudah dibaca dan terasa ramah.",
      "social-media": "Untuk caption dan posting dengan kalimat pendek serta tagar.",
      chat: "Untuk balasan singkat dan mengalir seperti obrolan. Emoji diperbolehkan.",
      gaming: "Untuk istilah gamer, seruan singkat, dan canda tim.",
      "street-talk": "Untuk bahasa gaul santai dengan rasa lokal. Tetap sopan.",
      comedy: "Untuk humor dan kata-kata jenaka dengan punchline yang jelas."
    },
    marketing: {
      general: "Untuk teks pemasaran yang konsisten dengan brand di berbagai kanal.",
      promotional: "Untuk promo dan diskon. Judul jelas dengan rasa urgensi.",
      persuasive: "Untuk copy berfokus manfaat dengan ajakan bertindak yang kuat.",
      "product-descriptions": "Untuk judul produk, fitur, spesifikasi, dan manfaat di halaman produk.",
      "brand-storytelling": "Untuk halaman profil dan narasi kampanye yang menyentuh emosi.",
      "seo-friendly": "Untuk copy ramah kata kunci, meta field, dan copywriting web/aplikasi.",
      "social-media": "Untuk posting dan iklan. Hook, tagar, dan kalimat pendek.",
      "email-campaigns": "Untuk subjek dan isi email yang mendorong klik.",
      "event-promotion": "Untuk undangan dan landing page dengan tanggal, lokasi, dan CTA.",
      "influencer-ugc-style": "Untuk suara orang pertama yang autentik seperti pengguna sungguhan."
    },
    dubbing: {
      general: "Untuk dubbing yang mengalir natural, ringkas, dan tepat waktu.",
      dialogue: "Untuk dialog karakter yang pas dengan gerak bibir dan tempo adegan.",
      narration: "Untuk naskah sulih suara dengan ritme mulus dan penekanan jelas."
    },
    creative: {
      general: "Untuk tulisan imajinatif dengan suara yang natural dan mudah dibaca.",
      "literary-adaptation": "Untuk cerita lintas bahasa yang menjaga nada dan imagery.",
      "slogan-tagline-writing": "Untuk kalimat sangat singkat yang mudah diingat dan mewakili brand.",
      "poetic-tone": "Untuk diksi puitis dengan ritme dan gambaran yang hidup.",
      "narrative-prose": "Untuk narasi gaya novel, cerita pendek, dan prosa bercerita lain dengan alur yang halus."
    },
    technical: {
      general: "Untuk tulisan teknis presisi dengan bahasa lugas dan istilah tepat.",
      "software-documentation": "Untuk panduan pengguna perangkat lunak dan rilis fitur dengan langkah dan contoh.",
      "engineering-manuals": "Untuk prosedur dan catatan keselamatan dengan bagian, toleransi, dan diagram.",
      "product-specs": "Untuk lembar spesifikasi: ukuran, material, dan batasan.",
      "api-guides": "Untuk endpoint dan parameter dengan contoh permintaan dan skema respons."
    },
    legal: {
      general: "Untuk tulisan hukum formal yang presisi, konsisten, dan siap sitasi.",
      contracts: "Untuk klausul, definisi, kewajiban, dan pemulihan dengan istilah tepat.",
      "terms-conditions": "Untuk syarat layanan, penggunaan yang diterima, garansi, dan pembatasan tanggung jawab.",
      "compliance-docs": "Untuk kebijakan dan laporan yang memenuhi regulasi.",
      "privacy-policies": "Untuk pernyataan pengumpulan, penggunaan, retensi data, dan hak pengguna.",
      constitutional: "Untuk teks konstitusi dan perundangan dengan redaksi tepat dan rujukan pasal."
    },
    medical: {
      general: "Untuk konten medis dengan istilah akurat dan struktur jelas.",
      "patient-friendly-explanation": "Untuk instruksi sederhana dan informasi kesehatan yang bisa ditindaklanjuti.",
      "research-abstracts": "Untuk ringkasan padat mencakup latar, metode, hasil, dan kesimpulan.",
      "clinical-documentation": "Untuk catatan rekam medis, ringkasan pulang, dan resep.",
      "health-campaigns": "Untuk pesan kesehatan publik dan posting sosial."
    },
    journalistic: {
      general: "Untuk tulisan faktual dengan nada netral dan sumber terverifikasi.",
      "news-reports": "Untuk kabar terkini yang diawali siapa, apa, kapan, di mana, dan mengapa.",
      "editorial-opinion": "Untuk opini yang berargumen dengan bukti, konteks, dan sikap jelas.",
      "feature-articles": "Untuk liputan mendalam dengan latar, sisi manusia, dan alur naratif.",
      "press-releases": "Untuk pengumuman organisasi dengan fakta kunci, kutipan, dan kontak."
    },
    corporate: {
      general: "Untuk tulisan bisnis yang jelas, ringkas, dan sesuai brand.",
      "internal-communications": "Untuk memo, pengumuman, dan pembaruan kebijakan.",
      "investor-relations": "Untuk ringkasan kinerja, KPI, dan pengungkapan risiko.",
      "annual-reports": "Untuk ringkasan kinerja, strategi, dan bagian ESG.",
      "professional-presentations": "Untuk judul slide, catatan pembicara, dan poin utama."
    },
    entertainment: {
      general: "Untuk film, serial, dan konten dengan nada menarik dan tempo stabil.",
      subtitling: "Untuk teks layar dengan timing, pemenggalan baris, dan kecepatan baca yang tepat.",
      screenwriting: "Untuk heading adegan, aksi, dan dialog dalam format standar.",
      "script-adaptation": "Untuk naskah terlokalisasi yang menjaga alur, humor, dan maksud.",
      "character-dialogue": "Untuk suara karakter yang pas dan sesuai tempo adegan."
    },
    educational: {
      general: "Untuk materi ajar dengan struktur jelas dan bahasa sederhana.",
      "e-learning": "Untuk modul online, slide, dan naskah voice-over berton aktif.",
      "step-by-step-guides": "Untuk petunjuk langkah demi langkah dengan penomoran dan diksi sederhana.",
      "academic-tutorials": "Untuk catatan kuliah dan walkthrough yang menjelaskan konsep dengan contoh.",
      "test-preparation": "Untuk soal latihan, kunci jawaban, dan tips yang membangun kepercayaan diri ujian."
    }
  },

  zh: {
    formal: {
      general: "用于专业文件与公共沟通场景。",
      academic: "用于研究论文、学术文章、论文与书籍。",
      scientific: "用于研究论文、摘要、实验报告与方法部分。"
    },
    casual: {
      general: "用于日常信息，读起来自然友好。",
      "social-media": "用于配文与帖子，行文短促并可搭配话题标签。",
      chat: "用于简短的对话式回复，可适当使用表情符号。",
      gaming: "用于玩家俚语、简短呼叫与队内玩梗。",
      "street-talk": "用于轻松口语与本地化表达，请保持礼貌。",
      comedy: "用于笑料与俏皮措辞，结尾包袱清晰。"
    },
    marketing: {
      general: "用于各渠道一致的品牌营销文案。",
      promotional: "用于优惠与促销。标题清晰并营造紧迫感。",
      persuasive: "用于以收益为核心并带有强力行动号召的文案。",
      "product-descriptions": "用于产品标题、特性、规格与卖点，适配商品详情页。",
      "brand-storytelling": "用于“关于我们”与活动叙事，注重情感共鸣。",
      "seo-friendly": "用于关键词优化文案、元信息字段和网站/应用文案。",
      "social-media": "用于帖子与广告，讲求开头抓人、话题标签与短句。",
      "email-campaigns": "用于提升点击率的主题与正文。",
      "event-promotion": "用于邀请与落地页，清晰呈现日期、地点与 CTA。",
      "influencer-ugc-style": "用于第一人称、真实感强的“像用户写的”内容。"
    },
    dubbing: {
      general: "用于配音台词，自然顺畅、句子精炼、时序干净。",
      dialogue: "用于人物对白，贴合口型并匹配场景节奏。",
      narration: "用于旁白稿，节奏平稳、重音清晰。"
    },
    creative: {
      general: "用于富有想象力且可读性强的创作性文字。",
      "literary-adaptation": "用于跨语改写故事，保留语气与意象。",
      "slogan-tagline-writing": "用于极短且易记的品牌语句。",
      "poetic-tone": "用于具节奏与鲜活意象的抒情表达。",
      "narrative-prose": "用于小说式叙述、短篇故事和其他以场景推进的叙事性文字与顺滑文气。"
    },
    technical: {
      general: "用于技术写作，术语准确、语言简明。",
      "software-documentation": "用于软件用户指南与更新说明，包含步骤与示例。",
      "engineering-manuals": "用于流程与安全提示，包含部件、允差与示意图。",
      "product-specs": "用于规格表，包含尺寸、材质与界限值。",
      "api-guides": "用于端点与参数说明，配请求示例与响应模式。"
    },
    legal: {
      general: "用于正式法律写作，表述精准、一致并可供引用。",
      contracts: "用于条款、定义、义务与救济，术语严谨。",
      "terms-conditions": "用于服务条款、可接受使用、保证与责任限制。",
      "compliance-docs": "用于满足监管要求的政策与报告。",
      "privacy-policies": "用于清晰说明数据收集、使用、保留与用户权利。",
      constitutional: "用于宪法与法律文本，措辞精确并含条款引用。"
    },
    medical: {
      general: "用于医学内容，术语准确、结构清晰。",
      "patient-friendly-explanation": "用于通俗指引与可行动的健康信息。",
      "research-abstracts": "用于简洁概述：背景、方法、结果与结论。",
      "clinical-documentation": "用于病历记录、出院小结与处方。",
      "health-campaigns": "用于公共健康信息与社交媒体传播。"
    },
    journalistic: {
      general: "用于基于事实、语气中立并经核实的信息写作。",
      "news-reports": "用于及时报道，以“五何”开篇（何人何事何时何地为何）。",
      "editorial-opinion": "用于观点明确、证据充分、脉络清晰的社论。",
      "feature-articles": "用于深度报道，兼顾背景、人情细节与叙事流畅。",
      "press-releases": "用于机构公告，包含要点、引语与联系方式。"
    },
    corporate: {
      general: "用于商务写作，表达清楚、简洁并符合品牌。",
      "internal-communications": "用于备忘、公告与政策更新。",
      "investor-relations": "用于业绩更新、关键指标与风险披露。",
      "annual-reports": "用于绩效回顾、战略与 ESG 板块。",
      "professional-presentations": "用于幻灯片标题、讲者笔记与要点。"
    },
    entertainment: {
      general: "用于影视与内容，语调吸引、节奏稳定。",
      subtitling: "用于字幕，时间轴准确、断行恰当、阅读速度合宜。",
      screenwriting: "用于场景标头、动作与对白的标准剧本格式。",
      "script-adaptation": "用于本地化剧本，保留情节、笑点与意图。",
      "character-dialogue": "用于角色贴脸的台词与场景节奏匹配。"
    },
    educational: {
      general: "用于教学材料，结构清晰、用语朴实。",
      "e-learning": "用于在线模块、幻灯片与配音稿，语气主动。",
      "step-by-step-guides": "用于分步指引，编号清楚、措辞简洁。",
      "academic-tutorials": "用于讲义与演练，结合示例解释概念。",
      "test-preparation": "用于练习题、答案与备考技巧，增强应试信心。"
    }
  },

  fr: {
    formal: {
      general: "Pour les documents professionnels et la communication publique.",
      academic: "Pour les articles de recherche, mémoires, thèses et ouvrages.",
      scientific: "Pour les articles scientifiques, résumés, rapports et méthodes."
    },
    casual: {
      general: "Pour des messages du quotidien, simples et chaleureux.",
      "social-media": "Pour des légendes et posts, lignes courtes et hashtags.",
      chat: "Pour des réponses rapides au ton conversationnel. Émojis autorisés.",
      gaming: "Pour l’argot gamer, les appels courts et l’esprit d’équipe.",
      "street-talk": "Pour un parler courant et local. Restez respectueux.",
      comedy: "Pour des formulations drôles avec une chute claire."
    },
    marketing: {
      general: "Pour un texte marketing cohérent avec la marque sur tous les canaux.",
      promotional: "Pour les offres et promotions. Titres clairs et sentiment d’urgence.",
      persuasive: "Pour un discours centré bénéfices avec un appel à l’action fort.",
      "product-descriptions": "Pour titres, fonctionnalités, spécifications et bénéfices sur les pages produit.",
      "brand-storytelling": "Pour les pages « À propos » et des récits de campagne émotionnels.",
      "seo-friendly": "Pour un contenu optimisé mots-clés, champs méta et rédaction web/app.",
      "social-media": "Pour posts et annonces. Accroches, hashtags, lignes courtes.",
      "email-campaigns": "Pour objets et corps d’e-mail qui incitent au clic.",
      "event-promotion": "Pour invitations et landing pages avec date, lieu et CTA.",
      "influencer-ugc-style": "Pour une voix à la première personne authentique, façon utilisateur réel."
    },
    dubbing: {
      general: "Pour un doublage fluide, des lignes concises et un timing propre.",
      dialogue: "Pour des répliques adaptées au mouvement des lèvres et au rythme des scènes.",
      narration: "Pour des voix off au débit régulier et à l’accentuation claire."
    },
    creative: {
      general: "Pour une écriture imaginative à la voix naturelle et lisible.",
      "literary-adaptation": "Pour réécrire des histoires en préservant le ton et les images.",
      "slogan-tagline-writing": "Pour des lignes très courtes, mémorables et fidèles à la marque.",
      "poetic-tone": "Pour une langue lyrique, rythmée et évocatrice.",
      "narrative-prose": "Pour narration style roman, nouvelles et autres proses narratives axées sur les scènes et le flux."
    },
    technical: {
      general: "Pour une rédaction technique précise avec langage clair et termes justes.",
      "software-documentation": "Pour guides utilisateur logiciel et notes de version avec étapes et exemples.",
      "engineering-manuals": "Pour procédures et consignes de sécurité avec pièces, tolérances et schémas.",
      "product-specs": "Pour fiches techniques avec mesures, matériaux et limites.",
      "api-guides": "Pour endpoints et paramètres avec requêtes d’exemple et schémas de réponse."
    },
    legal: {
      general: "Pour une écriture juridique formelle, précise, cohérente et citable.",
      contracts: "Pour clauses, définitions, obligations et recours aux termes exacts.",
      "terms-conditions": "Pour conditions d’utilisation, garanties et limitations de responsabilité.",
      "compliance-docs": "Pour politiques et rapports conformes aux exigences.",
      "privacy-policies": "Pour collecte, usage, conservation des données et droits des utilisateurs.",
      constitutional: "Pour textes constitutionnels et lois avec formulation exacte et renvois aux articles."
    },
    medical: {
      general: "Pour du contenu médical avec terminologie exacte et structure claire.",
      "patient-friendly-explanation": "Pour des consignes simples et des informations actionnables.",
      "research-abstracts": "Pour des résumés concis : contexte, méthodes, résultats, conclusions.",
      "clinical-documentation": "Pour dossiers médicaux, comptes rendus de sortie et prescriptions.",
      "health-campaigns": "Pour messages de santé publique et posts sociaux."
    },
    journalistic: {
      general: "Pour une écriture factuelle au ton neutre avec sources vérifiées.",
      "news-reports": "Pour des actualités qui ouvrent sur qui, quoi, quand, où, pourquoi.",
      "editorial-opinion": "Pour des points de vue argumentés, contextualisés et assumés.",
      "feature-articles": "Pour des sujets de fond avec contexte, témoignages et narration.",
      "press-releases": "Pour des annonces institutionnelles avec faits clés, citations et contact."
    },
    corporate: {
      general: "Pour une écriture d’entreprise claire, concise et conforme à la marque.",
      "internal-communications": "Pour notes, annonces et mises à jour de politique interne.",
      "investor-relations": "Pour résultats, indicateurs et informations sur les risques.",
      "annual-reports": "Pour bilans de performance, stratégie et chapitres ESG.",
      "professional-presentations": "Pour titres de diapositives, notes orateur et messages clés."
    },
    entertainment: {
      general: "Pour film, séries et contenus au ton engageant et au rythme régulier.",
      subtitling: "Pour sous-titres avec timing, césures et vitesse de lecture corrects.",
      screenwriting: "Pour en-têtes de scène, actions et dialogues au format standard.",
      "script-adaptation": "Pour des scripts localisés qui gardent intrigue, humour et intention.",
      "character-dialogue": "Pour des voix cohérentes avec chaque personnage et le rythme des scènes."
    },
    educational: {
      general: "Pour supports pédagogiques à la structure claire et au langage simple.",
      "e-learning": "Pour modules en ligne, diapositives et voix off au ton actif.",
      "step-by-step-guides": "Pour guides pas à pas, numérotés et formulés simplement.",
      "academic-tutorials": "Pour notes de cours et pas-à-pas expliquant les concepts par l’exemple.",
      "test-preparation": "Pour exercices, corrigés et conseils renforçant la confiance à l’examen."
    }
  },

  es: {
    formal: {
      general: "Para documentos profesionales y comunicación pública.",
      academic: "Para artículos de investigación, tesis y libros.",
      scientific: "Para artículos, resúmenes, informes de laboratorio y métodos."
    },
    casual: {
      general: "Para mensajes cotidianos que suenen simples y cercanos.",
      "social-media": "Para leyendas y posts con frases cortas y hashtags.",
      chat: "Para respuestas rápidas y conversacionales. Se permiten emojis.",
      gaming: "Para jerga gamer, llamados breves y camaradería de equipo.",
      "street-talk": "Para lenguaje coloquial con sabor local. Mantén el respeto.",
      comedy: "Para chistes y redacciones juguetonas con remate claro."
    },
    marketing: {
      general: "Para textos de marketing alineados con la marca en todos los canales.",
      promotional: "Para ofertas y rebajas. Titulares claros y sentido de urgencia.",
      persuasive: "Para copys centrados en beneficios con un CTA contundente.",
      "product-descriptions": "Para títulos, funciones, especificaciones y beneficios en páginas de producto.",
      "brand-storytelling": "Para páginas “Sobre nosotros” y narrativas de campaña con emoción.",
      "seo-friendly": "Para textos con palabras clave, campos meta y copywriting web/app.",
      "social-media": "Para posts y anuncios. Ganchos, hashtags y líneas cortas.",
      "email-campaigns": "Para asuntos y cuerpos que impulsen los clics.",
      "event-promotion": "Para invitaciones y landing pages con fecha, lugar y CTA.",
      "influencer-ugc-style": "Para voz en primera persona, auténtica y cercana, como de usuario real."
    },
    dubbing: {
      general: "Para doblaje con flujo natural, líneas concisas y timing limpio.",
      dialogue: "Para diálogos que se ajusten al movimiento labial y al ritmo de la escena.",
      narration: "Para locuciones con ritmo fluido y énfasis claro."
    },
    creative: {
      general: "Para escritura imaginativa con voz natural y legible.",
      "literary-adaptation": "Para reescritura de historias preservando tono e imágenes.",
      "slogan-tagline-writing": "Para líneas muy cortas, memorables y fieles a la marca.",
      "poetic-tone": "Para un registro lírico con ritmo e imágenes vívidas.",
      "narrative-prose": "Para narración estilo novela, cuentos cortos y otras prosas narrativas basadas en escenas y un flujo suave."
    },
    technical: {
      general: "Para redacción técnica precisa con lenguaje claro y términos correctos.",
      "software-documentation": "Para guías de usuario de software y notas de versión con pasos y ejemplos.",
      "engineering-manuals": "Para procedimientos y seguridad con piezas, tolerancias y diagramas.",
      "product-specs": "Para fichas técnicas con medidas, materiales y límites.",
      "api-guides": "Para endpoints y parámetros con solicitudes de ejemplo y esquemas de respuesta."
    },
    legal: {
      general: "Para textos legales formales, precisos, consistentes y listos para cita.",
      contracts: "Para cláusulas, definiciones, obligaciones y remedios con términos exactos.",
      "terms-conditions": "Para términos de servicio, uso aceptable, garantías y limitaciones de responsabilidad.",
      "compliance-docs": "Para políticas e informes que cumplan normativas.",
      "privacy-policies": "Para explicar recolección, uso, retención de datos y derechos del usuario.",
      constitutional: "Para textos constitucionales y leyes con redacción exacta y referencias a artículos."
    },
    medical: {
      general: "Para contenido médico con términos precisos y estructura clara.",
      "patient-friendly-explanation": "Para instrucciones sencillas e información accionable para pacientes.",
      "research-abstracts": "Para resúmenes concisos de antecedentes, métodos, resultados y conclusiones.",
      "clinical-documentation": "Para notas clínicas, resúmenes de alta y recetas.",
      "health-campaigns": "Para mensajes de salud pública y publicaciones en redes."
    },
    journalistic: {
      general: "Para escritura factual con tono neutral y fuentes verificadas.",
      "news-reports": "Para novedades oportunas que abren con quién, qué, cuándo, dónde y por qué.",
      "editorial-opinion": "Para posturas argumentadas con evidencia, contexto y posición clara.",
      "feature-articles": "Para reportajes en profundidad con contexto, enfoque humano y narrativa.",
      "press-releases": "Para anuncios institucionales con datos clave, citas y contacto."
    },
    corporate: {
      general: "Para textos empresariales claros, concisos y alineados con la marca.",
      "internal-communications": "Para memorandos, anuncios y actualizaciones de políticas.",
      "investor-relations": "Para resultados, KPIs y revelaciones de riesgo.",
      "annual-reports": "Para resúmenes de desempeño, estrategia y secciones ESG.",
      "professional-presentations": "Para títulos de diapositivas, notas del ponente y conclusiones clave."
    },
    entertainment: {
      general: "Para cine, series y contenidos con tono atractivo y ritmo constante.",
      subtitling: "Para subtítulos con timing correcto, cortes de línea y velocidad de lectura adecuada.",
      screenwriting: "Para encabezados de escena, acciones y diálogos en formato estándar.",
      "script-adaptation": "Para guiones localizados que mantengan trama, humor e intención.",
      "character-dialogue": "Para voces acordes a cada personaje y al ritmo de la escena."
    },
    educational: {
      general: "Para materiales de enseñanza con estructura clara y lenguaje sencillo.",
      "e-learning": "Para módulos en línea, diapositivas y guiones de voz con tono activo.",
      "step-by-step-guides": "Para instrucciones paso a paso con numeración y redacción simple.",
      "academic-tutorials": "Para apuntes y recorridos que expliquen conceptos con ejemplos.",
      "test-preparation": "Para ejercicios, claves y consejos que fortalezcan la confianza en exámenes."
    }
  }
};

    /* =======================
       1) Core helpers
       ======================= */
    let heightRO=null;
    const $=s=>document.querySelector(s);
    const $$=s=>Array.from(document.querySelectorAll(s));
    const slug=t=>String(t).toLowerCase().replace(/[^\w]+/g,'-').replace(/(^-|-$)/g,'');
    const getContentH=el=>el?Math.ceil(el.scrollHeight):0;

    /* ---------- Targets & Styles ---------- */
    const TARGET_KEYS=['Bahasa','Chinese','English','French','Spanish'];
    const STYLE_DEF={
      formal:{subs:['general','academic','scientific']},
      casual:{subs:['general','chat','gaming','street-talk','comedy','social-media']},
      marketing:{subs:['general','promotional','persuasive','product-descriptions','brand-storytelling','seo-friendly','social-media','email-campaigns','event-promotion','influencer-ugc-style']},
      dubbing:{subs:['general','dialogue','narration']},
      creative:{subs:['general','literary-adaptation','slogan-tagline-writing','poetic-tone','narrative-prose']},
      technical:{subs:['general','software-documentation','engineering-manuals','product-specs','api-guides']},
      legal:{subs:['general','contracts','terms-conditions','compliance-docs','privacy-policies','constitutional']},
      medical:{subs:['general','patient-friendly-explanation','research-abstracts','clinical-documentation','health-campaigns']},
      journalistic:{subs:['general','news-reports','editorial-opinion','feature-articles','press-releases']},
      corporate:{subs:['general','internal-communications','investor-relations','annual-reports','professional-presentations']},
      entertainment:{subs:['general','subtitling','screenwriting','script-adaptation','character-dialogue']},
      educational:{subs:['general','e-learning','step-by-step-guides','academic-tutorials','test-preparation']}
    };

    const SUBSTYLE_ALIASES={
      'formal:business':['corporate','general'],
      'formal:financial':['corporate','investor-relations'],
      'formal:dialogue':['dubbing','dialogue'],
      'casual:dialogue':['entertainment','character-dialogue'],
      'casual:social-media':['marketing','social-media'],
      'marketing:descriptive':['marketing','product-descriptions'],
      'marketing:pitching':['marketing','persuasive'],
      'marketing:social-media-marketing':['marketing','social-media'],
      'dubbing:narrative':['dubbing','narration'],
      'dubbing:historical':['dubbing','narration'],
      'dubbing:kids':['dubbing','narration'],
      'creative:storytelling':['creative','narrative-prose']
    };
    const resolveAlias=(mode,sub)=>{const key=`${slug(mode)}:${slug(sub||'general')}`;const hit=SUBSTYLE_ALIASES[key];return hit?{mode:hit[0],subStyle:hit[1]}:{mode,subStyle:sub}};

    /* ---------- UI Strings ---------- */
    const LOCALES={
      en:{title:"AI Localization Prototype",input_label:"Input Text",input_ph:"Paste or write your text here…",target_lang:"Target Language",loc_style:"Localization Style",substyle:"Sub-style",substyle_for:"Sub-style for",no_substyle:"No sub-style",submit:"Submit",result_label:"Result",split_view:"Split View",back:"Back",copy:"Copy",copied:"Copied!",pane_input:"Input",pane_result:"Result",clear_highlights:"Clear Highlights",rephrase:"Rephrase",choose_lang:"Select your language",toast_enter_text:"Please enter some text first.",toast_choose_target:"Choose a target language or Rephrase.",toast_choose_style:"Please choose a localization style.",toast_error_generic:"Something went wrong. Please try again.",or:"Or",upload_hint:"Drag & drop a .txt, .docx, .pdf, or .srt here",upload_sub:"…or click to browse",download_localized:"Download localized",download_all_zip:"Download all (.zip)",new_tab:"New Tab",open_files:"Open files",translate_all:"Translate all"},
      id:{title:"Prototipe Lokalisasi AI",input_label:"Teks Masukan",input_ph:"Tempel atau tulis teks di sini…",target_lang:"Bahasa Tujuan",loc_style:"Gaya Lokalisasi",substyle:"Sub-gaya",substyle_for:"Sub-gaya untuk",no_substyle:"Tanpa sub-gaya",submit:"Kirim",result_label:"Hasil",split_view:"Tampilan Terpisah",back:"Kembali",copy:"Salin",copied:"Tersalin!",pane_input:"Masukan",pane_result:"Hasil",clear_highlights:"Hapus Sorotan",rephrase:"Parafrase",choose_lang:"Pilih bahasa antarmuka",toast_enter_text:"Mohon isi teks terlebih dahulu.",toast_choose_target:"Pilih bahasa tujuan atau Parafrase.",toast_choose_style:"Pilih gaya lokalisasi.",toast_error_generic:"Terjadi kesalahan. Coba lagi.",or:"Atau",upload_hint:"Seret & lepas berkas .txt, .docx, .pdf, atau .srt",upload_sub:"…atau klik untuk memilih",download_localized:"Unduh hasil",download_all_zip:"Unduh semua (.zip)",new_tab:"Tab Baru",open_files:"Buka berkas",translate_all:"Terjemahkan semua"},
      zh:{title:"AI 本地化原型",input_label:"输入文本",input_ph:"在此粘贴或输入文本…",target_lang:"目标语言",loc_style:"本地化风格",substyle:"子风格",substyle_for:"子风格：",no_substyle:"无子风格",submit:"提交",result_label:"结果",split_view:"分屏视图",back:"返回",copy:"复制",copied:"已复制！",pane_input:"输入",pane_result:"结果",clear_highlights:"清除高亮",rephrase:"改写",choose_lang:"选择界面语言",toast_enter_text:"请先输入文本。",toast_choose_target:"请选择目标语言或改写。",toast_choose_style:"请选择本地化风格。",toast_error_generic:"出错了，请重试。",or:"或",upload_hint:"拖拽 .txt、.docx、.pdf 或 .srt 到此处",upload_sub:"…或点击选择",download_localized:"下载本地化文件",download_all_zip:"全部下载 (.zip)",new_tab:"新建标签",open_files:"打开文件",translate_all:"全部翻译"},
      fr:{title:"Prototype de Localisation IA",input_label:"Texte d’entrée",input_ph:"Collez ou saisissez votre texte ici…",target_lang:"Langue cible",loc_style:"Style de localisation",substyle:"Sous-style",substyle_for:"Sous-style pour",no_substyle:"Aucun sous-style",submit:"Envoyer",result_label:"Résultat",split_view:"Vue scindée",back:"Retour",copy:"Copier",copied:"Copié !",pane_input:"Entrée",pane_result:"Résultat",clear_highlights:"Effacer les surlignages",rephrase:"Reformuler",choose_lang:"Choisissez votre langue",toast_enter_text:"Veuillez d’abord saisir du texte.",toast_choose_target:"Choisissez une langue cible ou Reformuler.",toast_choose_style:"Choisissez un style de localisation.",toast_error_generic:"Un problème est survenu. Réessayez.",or:"Ou",upload_hint:"Glissez-déposez un .txt, .docx, .pdf ou .srt",upload_sub:"…ou cliquez pour parcourir",download_localized:"Télécharger la version localisée",download_all_zip:"Tout télécharger (.zip)",new_tab:"Nouvel onglet",open_files:"Ouvrir des fichiers",translate_all:"Tout traduire"},
      es:{title:"Prototipo de Localización IA",input_label:"Texto de entrada",input_ph:"Pega o escribe tu texto aquí…",target_lang:"Idioma de destino",loc_style:"Estilo de localización",substyle:"Subestilo",substyle_for:"Subestilo para",no_substyle:"Sin subestilo",submit:"Enviar",result_label:"Resultado",split_view:"Vista dividida",back:"Volver",copy:"Copiar",copied:"¡Copiado!",pane_input:"Entrada",pane_result:"Resultado",clear_highlights:"Borrar resaltados",rephrase:"Reformular",choose_lang:"Selecciona tu idioma",toast_enter_text:"Primero escribe algún texto.",toast_choose_target:"Elige un idioma objetivo o Reformular.",toast_choose_style:"Elige un estilo de localización.",toast_error_generic:"Algo salió mal. Inténtalo de nuevo.",or:"O",upload_hint:"Arrastra y suelta un .txt, .docx, .pdf o .srt",upload_sub:"…o haz clic para elegir",download_localized:"Descargar localizado",download_all_zip:"Descargar todo (.zip)",new_tab:"Nueva pestaña",open_files:"Abrir archivos",translate_all:"Traducir todo"}
    };
    const DEFAULT_LANG='en';
    const UI_LANGS=[{code:'en',label:'English'},{code:'id',label:'Bahasa Indonesia'},{code:'zh',label:'中文'},{code:'fr',label:'Français'},{code:'es',label:'Español'}];
    const face=code=>({en:'En',id:'Id',zh:'Zh',fr:'Fr',es:'Es'})[code]||code.toUpperCase();
    const t=key=>{const lang=localStorage.getItem('uiLang')||DEFAULT_LANG;return (LOCALES[lang]&&LOCALES[lang][key])||LOCALES[DEFAULT_LANG][key]||key};

    const LANG_LABELS={
      en:{Bahasa:'Bahasa',Chinese:'Chinese',English:'English',French:'French',Spanish:'Spanish'},
      id:{Bahasa:'Bahasa Indonesia',Chinese:'Tionghoa',English:'Inggris',French:'Prancis',Spanish:'Spanyol'},
      zh:{Bahasa:'印尼语',Chinese:'中文',English:'英语',French:'法语',Spanish:'西班牙语'},
      fr:{Bahasa:'Indonésien',Chinese:'Chinois',English:'Anglais',French:'Français',Spanish:'Espagnol'},
      es:{Bahasa:'Indonesio',Chinese:'Chino',English:'Inglés',French:'Francés',Spanish:'Español'}
    };
    const langLabel=k=>{const lang=localStorage.getItem('uiLang')||DEFAULT_LANG;return (LANG_LABELS[lang]?.[k])||(LANG_LABELS[DEFAULT_LANG]?.[k])||k};

    const STYLE_I18N = window.STYLE_I18N || {};
    const nicify = s => String(s).replace(/-/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
    const styleLabel = k => {
      const L = localStorage.getItem('uiLang') || DEFAULT_LANG;
      return (STYLE_I18N?.[L]?.style?.[k]) || (STYLE_I18N?.en?.style?.[k]) || nicify(k);
    };
    const subLabel = k => {
      const L = localStorage.getItem('uiLang') || DEFAULT_LANG;
      return (STYLE_I18N?.[L]?.sub?.[k]) || (STYLE_I18N?.en?.sub?.[k]) || nicify(k);
    };

    const STYLE_MICROCOPY = window.STYLE_MICROCOPY || {};
    const microcopyText = (mode, sub) => {
      const L = localStorage.getItem('uiLang') || DEFAULT_LANG;
      const m = STYLE_MICROCOPY?.[L]?.[mode]?.[sub];
      if (m) return m;
      return STYLE_MICROCOPY?.[DEFAULT_LANG]?.[mode]?.[sub] || "";
    };

    /* ---------------- State ---------------- */
    let selectedMode="",targetLanguage="",selectedSubStyle="",rephrase=false,splitView=false;

    // === Tabs/documents state ===
    const docs=[]; // {id,name,ext,size,mime,text,cues,srtTranslations,lastAlignedTgt,output,isSrt}
    let activeId=null;
    let seq=1; // for Untitled counters

    const COPY_SVG='<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="3"></rect><rect x="2" y="2" width="13" height="13" rx="3"></rect></svg>';
    const CHECK_SVG='<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"></path></svg>';
    const GLOBE_SVG='<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M3 12h18M12 3a12 12 0 0 1 0 18M12 3a12 12 0 0 0 0 18"></path></svg>';

    /* UI helpers */
    function autosizeTextarea(el){
      if(!el) return;
      const cap = Number(el.dataset.maxh || 420);
      el.style.height='auto';
      const h = Math.max(44, el.scrollHeight);
      const finalH = Math.min(cap, h);
      el.style.height = finalH + 'px';
      if (h > cap) { el.style.overflowY = 'auto'; }
      else { el.style.overflowY = 'hidden'; }
    }
    function setLoaderText(msg){
      // Bridge old loader updates to new status tab
      setStatus(msg||'Localizing…');
      const n=$('#glassLoader .glass-text');
      if(n){ n.textContent = msg || 'Localizing…'; }
    }
    function showLoader(disableBtn,msg){
      // Redirect loader to status tab per new UX
      if(disableBtn){$('#submitBtn')?.setAttribute('disabled','true');$('#submitAllBtn')?.setAttribute('disabled','true')}
      showStatus(msg||'Working…');
    }
    function hideLoader(enableBtn){
      // Smoothly delay hide so user can read the final status
      setTimeout(()=>hideStatus(),1300);
      $('#cardRoot')?.setAttribute('aria-busy','false');
      if(enableBtn){$('#submitBtn')?.removeAttribute('disabled');$('#submitAllBtn')?.removeAttribute('disabled')}
    }
    
    // Upload progress functions
    function showUploadProgress(){
      console.log('🔄 showUploadProgress called');
      let progressBar = $('#uploadProgressBar');
      if (!progressBar) {
        console.log('📊 Creating new progress bar');
        // Create progress bar if it doesn't exist
        let targetContainer = $('#tabsContainer');
        console.log('📁 Tabs container:', targetContainer);
        
        // Fallback containers if tabs container not found
        if (!targetContainer) {
          targetContainer = $('.card') || $('#cardRoot') || document.body;
          console.log('📁 Using fallback container:', targetContainer);
        }
        
        if (targetContainer) {
          progressBar = document.createElement('div');
          progressBar.id = 'uploadProgressBar';
          progressBar.className = 'upload-progress-bar';
          progressBar.innerHTML = `
            <div class="upload-progress-text">Uploading...</div>
            <div class="upload-progress-track">
              <div class="upload-progress-fill"></div>
            </div>
          `;
          
          // Insert after tabs container or at the beginning of fallback container
          if (targetContainer.id === 'tabsContainer') {
            targetContainer.parentNode.insertBefore(progressBar, targetContainer.nextSibling);
          } else {
            targetContainer.insertBefore(progressBar, targetContainer.firstChild);
          }
          console.log('📊 Progress bar created and inserted');
        } else {
          console.error('❌ No suitable container found');
        }
      } else {
        console.log('📊 Using existing progress bar');
      }
      if (progressBar) {
        progressBar.classList.add('show');
        progressBar.classList.add('is-busy');
        const fill = progressBar.querySelector('.upload-progress-fill');
        if (fill) fill.style.width = '0%';
        console.log('📊 Progress bar shown');
      } else {
        console.error('❌ Progress bar not found after creation attempt');
      }
    }
    
    function hideUploadProgress(){
      const progressBar = $('#uploadProgressBar');
      if (progressBar) {
        progressBar.classList.remove('is-busy');
        // keep visible for a short pause, then collapse
        setTimeout(()=>{ progressBar.classList.remove('show'); }, 1200);
        setTimeout(() => {
          const fill = progressBar.querySelector('.upload-progress-fill');
          if (fill) fill.style.width = '0%';
        }, 1600);
      }
    }
    
    function updateUploadProgress(current, total, fileName = ''){
      console.log(`📊 updateUploadProgress: ${current}/${total}, file: ${fileName}`);
      const progressBar = $('#uploadProgressBar');
      if (progressBar) {
        const percentage = Math.round((current / total) * 100);
        const fill = progressBar.querySelector('.upload-progress-fill');
        const text = progressBar.querySelector('.upload-progress-text');
        if (fill) {
          fill.style.width = percentage + '%';
          console.log(`📊 Progress updated to ${percentage}%`);
        }
        if (text) {
          if (fileName) {
            text.textContent = `Uploading ${fileName}... ${current}/${total}`;
          } else {
            text.textContent = `Uploading... ${current}/${total}`;
          }
          console.log(`📊 Progress text updated: ${text.textContent}`);
        }
      } else {
        console.error('❌ Progress bar not found in updateUploadProgress');
      }
    }
    
    function setUploadProgressText(message){
      const progressBar = $('#uploadProgressBar');
      if (progressBar) {
        const text = progressBar.querySelector('.upload-progress-text');
        if (text){
          // Extract base message without trailing dots or ellipsis, then add animated dots via CSS
          const base = String(message||'').replace(/[\.\u2026]+\s*$/,'');
          text.textContent = base + ' ';
          text.setAttribute('data-ellipsis','');
        }
      }
    }
    
    // Generic status helpers (centralized status tab)
    function showStatus(message){ showUploadProgress(); setUploadProgressText(message||'Working…'); }
    function setStatus(message){ setUploadProgressText(message||''); const el=$('#uploadProgressBar'); if(el){ if(/done|complete|success/i.test(message||'')){ el.classList.remove('is-busy'); } else { el.classList.add('is-busy'); } } }
    function hideStatus(){ hideUploadProgress(); }
    
    // Process file operations in chunks to prevent UI freezing
    async function processFileInChunks(parsed) {
      console.log(`📄 Processing file in chunks: ${parsed.originalName}`);
      
      // Yield before DOM operations
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Add document in chunks
      addDocFromFile(parsed);
      
      // Yield after DOM operations
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Update badge
      setBadge({name:parsed.originalName, ext:parsed.ext, size:parsed.size});
      
      // Final yield
      await new Promise(resolve => setTimeout(resolve, 50));
      
      console.log(`📄 File processing completed: ${parsed.originalName}`);
    }
    function hasAnyResult(){
      const d = currentDoc();
      if(!d) return false;
      if(d.isSrt) return (d.srtTranslations||[]).some(x => (x||'').trim().length>0);
      return !!((d.output||'').trim());
    }
    function updateActionButtonsEnabled(){
      const can=docs.some(d => d.isSrt ? (d.srtTranslations||[]).some(x=>x && x.trim()) : (d.output||'').trim().length);
      ['#downloadInlineBtn','#downloadAllInlineBtn','#downloadSplitBtn','#downloadAllSplitBtn','#toggleSplit'].forEach(sel=>{
        const el=$(sel); if(!el) return;
        if(sel==='#toggleSplit'){ el.disabled=!hasAnyResult(); return; }
        el.toggleAttribute('disabled', !can);
      });
    }
    function updateSplitButton(){
      const btn=$('#toggleSplit');
      btn.disabled=!hasAnyResult();
      btn.textContent=splitView?t('back'):t('split_view');
      updateActionButtonsEnabled();
    }
    function maybeShowSubmitAll(){
      const multi = docs.length>1;
      $('#submitAllBtn')?.classList.toggle('is-hidden', !multi);
    }
    function animateCopy(btn){const original=btn._originalHTML||btn.innerHTML;btn._originalHTML=original;btn.classList.add('copied');btn.innerHTML=CHECK_SVG+'<span>'+t('copied')+'</span>';clearTimeout(btn._t);btn._t=setTimeout(()=>{btn.classList.remove('copied');btn.innerHTML=original},1100)}
    function escapeHTML(s=''){return s.replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))}
    function showToast(message){
      const host=$('#toasts');if(!host){alert(message);return}
      const el=document.createElement('div');el.className='toast warn';el.setAttribute('role','alert');
      el.innerHTML=`<svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 9v4"></path><path d="M12 17h.01"></path><path d="M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0Z"></path></svg><div>${escapeHTML(message)}</div>`;
      host.appendChild(el);requestAnimationFrame(()=>el.classList.add('show'));
      setTimeout(()=>{el.classList.remove('show');setTimeout(()=>el.remove(),250)},2400)
    }
    function pulse(el){if(!el)return;el.classList.add('field-pulse');setTimeout(()=>el.classList.remove('field-pulse'),900)}

    /* ---------- Tabs ---------- */
    function currentDoc(){ return docs.find(d=>d.id===activeId) || null; }
    function addTextTab(){
      const doc={ id:'d'+Date.now()+Math.random().toString(36).slice(2),
        name:`Untitled ${seq++}`, ext:'txt', size:0, mime:'text/plain',
        text:'', cues:[], srtTranslations:[], lastAlignedTgt:[], output:'', isSrt:false
      };
      docs.push(doc);
      activeId = doc.id;
      renderTabs(); loadDocToUI(doc); maybeShowSubmitAll();
      $('#inputText')?.focus();
    }
    function addDocFromFile(parsed){
      const ext=(parsed.ext||'').replace(/^\./,'').toLowerCase();
      const doc={ id:'d'+Date.now()+Math.random().toString(36).slice(2),
        name: parsed.originalName || parsed.name || 'file',
        ext, size: parsed.size||0, mime: parsed.mime||'',
        text: parsed.text||'',
        cues: Array.isArray(parsed.cues)?parsed.cues:[],
        srtTranslations: Array.isArray(parsed.cues)?new Array(parsed.cues.length).fill(''):[],
        lastAlignedTgt:[], output:'', isSrt: (ext==='srt')
      };
      docs.push(doc); activeId=doc.id;
      renderTabs(); loadDocToUI(doc); maybeShowSubmitAll();
      
      // Update character count after file is loaded
      setTimeout(() => {
        if (window.updateCharacterCount) {
          window.updateCharacterCount();
        }
      }, 100);
    }
    function closeDoc(id){
      const idx=docs.findIndex(d=>d.id===id);
      if(idx<0) return;
      docs.splice(idx,1);
      if(!docs.length){ addTextTab(); } else {
        if(activeId===id){ activeId = docs[Math.max(0, idx-1)].id; }
        renderTabs(); loadDocToUI(currentDoc());
      }
      maybeShowSubmitAll();
    }
    function renderTabs(){
      const bar=$('#tabBar'); if(!bar) return;
      bar.innerHTML = docs.map(d=>{
        return `<button class="tab ${d.id===activeId?'active':''}" role="tab" aria-selected="${d.id===activeId?'true':'false'}" data-id="${d.id}" title="${escapeHTML(d.name)}">
                  <span class="tab-title">${escapeHTML(d.name)}</span>
                  <span class="tab-ext">${escapeHTML((d.ext||'').toUpperCase())}</span>
                  <span class="tab-close" data-close="${d.id}" title="Close">×</span>
                </button>`;
      }).join('');
      // Click to activate
      bar.querySelectorAll('.tab').forEach(el=>{
        el.addEventListener('click',e=>{
          if(e.target && e.target.matches('.tab-close')) return;
          const id=el.getAttribute('data-id'); if(id){ activeId=id; renderTabs(); loadDocToUI(currentDoc());}
        });
      });
      // Click to close
      bar.querySelectorAll('.tab .tab-close').forEach(el=>{
        el.addEventListener('click', e=>{e.stopPropagation(); closeDoc(el.getAttribute('data-close'));});
      });
      enableDragScroll(bar);
      updateSplitButton();
    }
    /* Grab-to-scroll for tabs — fixed so clicks still work */
    function enableDragScroll(node){
      if(!node || node._dragWired) return;
      let isDown=false, isDragging=false, startX=0, scrollLeft=0;
      node.addEventListener('pointerdown',e=>{
        if(e.button!==0) return;
        isDown=true; isDragging=false; node.classList.add('grabbing');
        startX=e.clientX; scrollLeft=node.scrollLeft;
      });
      node.addEventListener('pointermove',e=>{
        if(!isDown) return;
        const dx=e.clientX-startX;
        if(Math.abs(dx)>3) isDragging=true;      // threshold to count as drag
        if(isDragging) node.scrollLeft=scrollLeft-dx;
      });
      const end=(e)=>{
        if(!isDown) return;
        if(isDragging){ e?.preventDefault?.(); e?.stopPropagation?.(); }
        isDown=false; isDragging=false; node.classList.remove('grabbing');
      };
      node.addEventListener('pointerup',end); node.addEventListener('pointercancel',end);
      node._dragWired=true;
    }

    /* ---------- Build language/style controls ---------- */
    function buildLangButtons(){
      const row=$('#langButtonsRow'); if(!row) return;
      const current=targetLanguage;
      const sorted=[...TARGET_KEYS].sort((a,b)=>langLabel(a).localeCompare(langLabel(b)));
      let html=`<button id="btnRephrase" class="btn toggle-btn" type="button" data-kind="rephrase">${t('rephrase')}</button>`;
      html+=sorted.map(k=>`<button class="btn toggle-btn lang-btn" type="button" data-lang="${k}">${langLabel(k)}</button>`).join('');
      row.innerHTML=html;
      $('#btnRephrase')?.addEventListener('click',toggleRephrase);
      $$('.lang-btn').forEach(b=>b.addEventListener('click',()=>selectTarget(b.dataset.lang)));
      if(rephrase) $('#btnRephrase')?.classList.add('active');
      $$('.lang-btn').forEach(b=>b.classList.toggle('active',b.dataset.lang===current));
    }
    function buildStyleButtons(){
      const row=$('#styleButtonsRow'); if(!row) return;
      const current=selectedMode;
      const keys=Object.keys(STYLE_DEF);
      row.innerHTML=keys.map(k=>`<button class="btn style-btn" data-mode="${k}" type="button">${styleLabel(k)}</button>`).join('');
      $$('.style-btn').forEach(b=>b.addEventListener('click',()=>setMode(b.dataset.mode)));
      if(current){document.querySelector(`.style-btn[data-mode="${current}"]`)?.classList.add('active')}
    }

    /* ---------- Language modal ---------- */
    function renderLangGrid(){const grid=$('#langGrid');if(!grid) return;const cur=localStorage.getItem('uiLang')||DEFAULT_LANG;grid.innerHTML=UI_LANGS.map(item=>`<div class="lang-item${item.code===cur?' active':''}" data-code="${item.code}" role="button" tabindex="0" aria-label="${item.label}"><div>${item.label}</div><div class="lang-code">${face(item.code)} <span class="lang-check">✓</span></div></div>`).join('')}
    function openLangModal(){const ov=$('#langOverlay'); if(!ov) return; ov.classList.add('show'); ov.setAttribute('aria-hidden','false'); $('#uiLangBtn')?.setAttribute('aria-expanded','true'); const onKey=e=>{if(e.key==='Escape')closeLangModal()}; const onClick=e=>{if(e.target.id==='langOverlay')closeLangModal()}; ov._onKey=onKey; ov._onClick=onClick; document.addEventListener('keydown',onKey); ov.addEventListener('click',onClick); $('#langGrid')?.addEventListener('click',ov._onPick=evt=>{const it=evt.target.closest('.lang-item'); if(!it) return; setUiLang(it.dataset.code); closeLangModal()})}
    function closeLangModal(){const ov=$('#langOverlay'); if(!ov) return; ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); $('#uiLangBtn')?.setAttribute('aria-expanded','false'); document.removeEventListener('keydown',ov._onKey||(()=>{})); ov.removeEventListener('click',ov._onClick||(()=>{})); $('#langGrid')?.removeEventListener('click',ov._onPick||(()=>{}))}

    function applyI18n(){
      document.title=t('title');
      document.documentElement.lang=localStorage.getItem('uiLang')||DEFAULT_LANG;
      $$('.title,[data-i18n="title"]').forEach(n=>n.textContent=t('title'));
      $$('[data-i18n]').forEach(n=>{const k=n.getAttribute('data-i18n'); if(k && k!=='title') n.textContent=t(k)});
      $('#inputText')?.setAttribute('placeholder',t('input_ph'));
      const code=localStorage.getItem('uiLang')||DEFAULT_LANG;
      const faceBtn=$('#uiLangBtn'); if(faceBtn){faceBtn.innerHTML=`${GLOBE_SVG}<span>${face(code)}</span>`; faceBtn.title=t('choose_lang')}
      const tl=targetLanguage, mode=selectedMode, sub=selectedSubStyle, wasRephrase=rephrase;
      buildLangButtons(); buildStyleButtons();
      if(wasRephrase) $('#btnRephrase')?.classList.add('active');
      if(tl){$$('.lang-btn').forEach(b=>b.classList.toggle('active',b.dataset.lang===tl))}
      if(mode){renderSubstyles(mode); if(sub) setSubStyle(sub); }
      renderLangGrid();
      updateSplitButton();
    }
    function setUiLang(lang){localStorage.setItem('uiLang',lang); document.documentElement.dir=['ar','he','fa','ur'].includes(lang)?'rtl':'ltr'; applyI18n()}

    document.addEventListener('DOMContentLoaded',()=>{
      document.body.classList.remove('no-js');
      const saved=localStorage.getItem('uiLang')||DEFAULT_LANG; setUiLang(saved);
      buildLangButtons(); buildStyleButtons();

      injectHistoryButton();

      $('#uiLangBtn')?.addEventListener('click',()=>{renderLangGrid(); openLangModal()});
      $('#langCloseBtn')?.addEventListener('click',closeLangModal);

      $('#substyleTrigger')?.addEventListener('click',()=>{toggleSubstylePanel();adjustWrapHeight()});

      $('#submitBtn')?.addEventListener('click',()=>submitActiveDoc());
      $('#submitAllBtn')?.addEventListener('click',translateAllTabs);
      $('#toggleSplit')?.addEventListener('click',toggleSplitView);
      $('#addTextTabBtn')?.addEventListener('click',addTextTab);

      // Inline output actions
      $('#copyBtn')?.addEventListener('click',()=>copyText('#outputText','#copyBtn'));
      $('#copySplitBtn')?.addEventListener('click',()=>copyText('#outputText','#copySplitBtn'));
      $('#downloadInlineBtn')?.addEventListener('click',()=>downloadLocalized(currentDoc()));
      $('#downloadAllInlineBtn')?.addEventListener('click',downloadAllZip);
      $('#downloadSplitBtn')?.addEventListener('click',()=>downloadLocalized(currentDoc()));
      $('#downloadAllSplitBtn')?.addEventListener('click',downloadAllZip);
      
      // (removed Edit Mode toggle)

      // Input bindings save to active doc
      $('#inputText')?.addEventListener('input',()=>{
        const d=currentDoc(); if(!d) return;
        d.lastAlignedTgt=[]; d.text=$('#inputText').value;
        autosizeTextarea($('#inputText'));
        if(splitView && !d.isSrt) renderSegmentBoxes(d); adjustWrapHeight()
      });
      $('#outputText')?.addEventListener('input',()=>{
        const d=currentDoc(); if(!d) return;
        d.lastAlignedTgt=[]; d.output=$('#outputText').value;
        autosizeTextarea($('#outputText'));
        if(splitView) renderSegmentBoxes(d); adjustWrapHeight()
      });
      $('#outputRich')?.addEventListener('input',()=>{
        const d=currentDoc(); if(!d) return;
        d.lastAlignedTgt=[]; syncRichToHidden();
        d.output=$('#outputText').value;
        if(splitView && !d.isSrt) renderSegmentBoxes(d); updateSplitButton()
      });

      $('#subStyleContainer')?.classList.add('is-hidden'); setChevron(false); renderSubstyles("");
      initDropzone();

      autosizeTextarea($('#inputText'));
      autosizeTextarea($('#outputText'));

      // First tab
      addTextTab();

      adjustWrapHeight(); updateSplitButton();
      window.addEventListener('resize',debounce(()=>{if(splitView)equalizeRowHeights();adjustWrapHeight(true)},120));
    });

    /* ---------------- History (client-side only) ---------------- */
    const HISTORY_KEY='locHistory';
    const HISTORY_MAX=30;
    const CLOCK_SVG = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M12 7v6l4 2"></path></svg>';

    function injectHistoryButton(){
      const tb=document.querySelector('.toolbar');
      if(!tb || document.getElementById('historyBtn')) return;
      const btn=document.createElement('button');
      btn.id='historyBtn';
      btn.className='btn face-btn';
      btn.title='Recent runs';
      btn.innerHTML = CLOCK_SVG + '<span>History</span>';
      btn.addEventListener('click',openHistoryModal);
      tb.appendChild(btn);
      ensureHistoryOverlay();
    }
    function readHistory(){try{return JSON.parse(localStorage.getItem(HISTORY_KEY)||'[]')}catch{return []}}
    function pushHistory(entry){
      const arr=readHistory();
      arr.unshift(entry);
      while(arr.length>HISTORY_MAX) arr.pop();
      localStorage.setItem(HISTORY_KEY,JSON.stringify(arr));
    }
    const HISTORY_SECURE = true; // store payloads only in sessionStorage
    function makeHistoryEntryFromDoc(doc){
      const id = 'h'+Date.now().toString(36)+Math.random().toString(36).slice(2,8);
      const payloadKey = 'HIST_PAYLOAD:'+id;
      const payload = doc.isSrt ? {
        type:'srt', text: doc.text||'', cues: Array.isArray(doc.cues)?doc.cues:[],
        srtTranslations: Array.isArray(doc.srtTranslations)?doc.srtTranslations:[],
        output: doc.output||''
      } : { type:'text', text: doc.text||'', output: doc.output||'' };
      try{ sessionStorage.setItem(payloadKey, JSON.stringify(payload)); }catch{}
      return {
        id, payloadKey,
        ts: Date.now(),
        docId: doc.id,
        name: doc.name||'Untitled',
        ext: doc.ext||'txt',
        isSrt: !!doc.isSrt,
        mode: selectedMode, subStyle: selectedSubStyle,
        targetLanguage, rephrase,
        srcChars: (doc.isSrt ? (doc.text || (doc.cues||[]).map(c=>c.text).join('\n') || '').length : (doc.text||'').length),
        outChars: (doc.output||'').length
      };
    }
    function recallHistory(index){
      const items = readHistory();
      const meta = items[Number(index)];
      if(!meta){ return; }
      const key = meta.payloadKey || ('HIST_PAYLOAD:'+ (meta.id||''));
      let payload = null; try{ payload = JSON.parse(sessionStorage.getItem(key)||'null'); }catch{}
      if(!payload){
        showToast('This history is from a previous session. Content not stored.');
        // Still set UI selections for convenience
        selectedMode = meta.mode||selectedMode; selectedSubStyle = meta.subStyle||''; targetLanguage = meta.targetLanguage||targetLanguage; rephrase = !!meta.rephrase;
        buildStyleButtons(); if(selectedSubStyle) setSubStyle(selectedSubStyle); buildLangButtons();
        return;
      }
      // Restore UI selections
      selectedMode = meta.mode||selectedMode; selectedSubStyle = meta.subStyle||''; targetLanguage = meta.targetLanguage||targetLanguage; rephrase = !!meta.rephrase;
      buildStyleButtons(); if(selectedSubStyle) setSubStyle(selectedSubStyle); buildLangButtons();

      // Find existing doc, else create
      let doc = docs.find(d=>d.id===meta.docId);
      const createdNew = !doc;
      if(!doc){
        doc = {
          id:'d'+Date.now()+Math.random().toString(36).slice(2),
          name: meta.name||'Untitled', ext: meta.ext||'txt', size:0, mime:'',
          text:'', cues:[], srtTranslations:[], lastAlignedTgt:[], output:'', isSrt: !!(payload.type==='srt' || meta.isSrt)
        };
        docs.push(doc);
      }
      // Restore snapshot
      if(payload.type==='srt' || doc.isSrt){
        doc.isSrt = true;
        doc.text = payload.text||'';
        doc.cues = Array.isArray(payload.cues)?payload.cues:[];
        doc.srtTranslations = Array.isArray(payload.srtTranslations)?payload.srtTranslations:[];
        doc.output = payload.output || (doc.srtTranslations||[]).join('\n');
      }else{
        doc.isSrt = false;
        doc.text = payload.text||'';
        doc.output = payload.output||'';
      }
      // Activate tab and render
      activeId = doc.id;
      renderTabs();
      loadDocToUI(doc);
      if(splitView){ if(doc.isSrt) renderSrtBoxes(doc); else renderSegmentBoxes(doc); }
      // Flash highlight
      const ot=$('#outputText'); if(ot){ ot.classList.add('field-pulse'); setTimeout(()=>ot.classList.remove('field-pulse'),900); }
      closeHistoryModal();
      // If we created a new tab, ensure submit all visibility
      maybeShowSubmitAll();
    }
    function ensureHistoryOverlay(){
      if(document.getElementById('histOverlay')) return;
      ensureHistoryStyles();
      const wrap=document.createElement('div');
      wrap.id='histOverlay';
      wrap.className='lang-overlay';
      wrap.setAttribute('role','dialog');
      wrap.setAttribute('aria-modal','true');
      wrap.setAttribute('aria-hidden','true');
      wrap.innerHTML=`
        <div class="lang-sheet" role="document">
          <div class="lang-head">
            <div class="lang-title">Recent runs</div>
            <div style="display:flex;gap:8px">
              <button class="lang-close" id="histClearBtn" title="Clear history"><span>Clear history</span></button>
              <button class="lang-close" id="histCloseBtn" aria-label="Close">✕</button>
            </div>
          </div>
          <div class="lang-grid" id="histGrid"></div>
        </div>`;
      document.body.appendChild(wrap);
      document.getElementById('histCloseBtn').addEventListener('click',closeHistoryModal);
      document.getElementById('histClearBtn').addEventListener('click',()=>{localStorage.removeItem(HISTORY_KEY);renderHistoryGrid();});
    }
    function ensureHistoryStyles(){
      if(document.getElementById('histOverlayStyles')) return;
      const css = `
        #histOverlay .lang-grid { grid-template-columns: 1fr; max-height: min(60vh, 560px); overflow: auto; }
        #histOverlay .lang-item { 
          display:flex; flex-direction:column; align-items:flex-start; gap:6px; 
          padding:16px 18px; font-size:15px; line-height:1.5; cursor:pointer; 
          transition:all .18s var(--ease); border-radius:8px; margin:2px 4px;
        }
        #histOverlay .lang-item:hover { 
          background:var(--accent-weak); 
          border-color:var(--accent);
          color:var(--accent);
          transform:translateX(3px);
          box-shadow:0 2px 8px rgba(0,122,255,.12);
        }
        #histOverlay .lang-item .lang-code { opacity:.78; font-size:13px; transition:opacity .18s var(--ease); }
        #histOverlay .lang-item:hover .lang-code { opacity:1; }
        #histOverlay .lang-close#histClearBtn { font-weight:500; padding:6px 12px; border-radius:10px; }
      `;
      const style = document.createElement('style');
      style.id = 'histOverlayStyles';
      style.textContent = css;
      document.head.appendChild(style);
    }
    function renderHistoryGrid(){
      const grid=$('#histGrid'); if(!grid) return;
      const items=readHistory();
      if(!items.length){
        grid.innerHTML=`<div class="lang-item"><div>No history yet</div><div class="lang-code">—</div></div>`;
        return;
      }
      grid.innerHTML = items.map((h,i)=>{
        const d=new Date(h.ts);
        const meta = [
          `${h.mode}/${h.subStyle||'general'}`,
          h.rephrase ? 'rephrase' : (h.targetLanguage||''),
          `${h.srcChars}→${h.outChars}`,
          h.fileName? h.fileName : null
        ].filter(Boolean).join(' · ');
        return `<div class="lang-item" data-index="${i}" role="button" tabindex="0" aria-label="Recall ${escapeHTML(meta)}">
                  <div>${escapeHTML(d.toLocaleString())}</div>
                  <div class="lang-code">${escapeHTML(meta)}</div>
                </div>`;
      }).join('');
      // Wire recall interaction
      grid.querySelectorAll('.lang-item[data-index]').forEach(it=>{
        it.addEventListener('click',()=>{ const idx=Number(it.getAttribute('data-index')); recallHistory(idx); });
        it.addEventListener('keydown',e=>{ if(e.key==='Enter'||e.key===' ') { e.preventDefault(); const idx=Number(it.getAttribute('data-index')); recallHistory(idx); } });
      });
    }
    function openHistoryModal(){ensureHistoryOverlay();renderHistoryGrid();const ov=$('#histOverlay'); if(!ov) return; ov.classList.add('show'); ov.setAttribute('aria-hidden','false'); ov._onKey=e=>{if(e.key==='Escape')closeHistoryModal()}; ov._onClick=e=>{if(e.target.id==='histOverlay')closeHistoryModal()}; document.addEventListener('keydown',ov._onKey); ov.addEventListener('click',ov._onClick);}
    function closeHistoryModal(){const ov=$('#histOverlay'); if(!ov) return; ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',ov._onKey||(()=>{})); ov.removeEventListener('click',ov._onClick||(()=>{}));}

    /* ---------------- Dropzone & file handling ---------------- */
    function initDropzone(){
      const dz=$('#dropzone'), input=$('#fileInput');
      const onOver=e=>{e.preventDefault();dz.classList.add('drag')};
      const onLeave=e=>{e.preventDefault();dz.classList.remove('drag')};
      const onDrop=e=>{
        e.preventDefault(); dz.classList.remove('drag');
        const files=Array.from(e.dataTransfer.files||[]); if(files.length) handleFiles(files);
      };
      dz.addEventListener('dragover',onOver);
      dz.addEventListener('dragleave',onLeave);
      dz.addEventListener('drop',onDrop);
      input.addEventListener('change',e=>{const files=Array.from(e.target.files||[]); if(files.length) handleFiles(files)});
      $('#clearFile')?.addEventListener('click',()=>{ if(currentDoc()) closeDoc(currentDoc().id) });
    }
    function setBadge(meta){
      $('#fileMeta').innerHTML = `<b>${escapeHTML(meta.name)}</b> · ${escapeHTML((meta.ext||'').toUpperCase())} · ${Math.round((meta.size||0)/1024)} KB`;
      $('#fileBadgeWrap').classList.add('is-hidden'); // tabs supersede it
    }
    // Track active uploads to prevent duplicates
    let uploadInProgress = false;
    const uploadedFiles = new Set(); // Track uploaded file names
    
    async function handleFiles(files){
      if (uploadInProgress) {
        console.log('Upload already in progress, ignoring duplicate request');
        return;
      }
      
      // Check tier restrictions for multiple files
      const user = JSON.parse(localStorage.getItem('user') || '{}');
      const isGuest = user.isGuest === true;
      const tier = user.tier || 'free';
      
      console.log('🔍 File upload tier check:', { user, isGuest, tier, filesCount: files.length });
      
      if ((isGuest || tier === 'free') && files.length > 1) {
        console.log('❌ Multiple file upload blocked for tier:', tier);
        showToast('Multiple file uploads require Pro or Team tier. Sign in to upgrade!');
        return;
      }
      
      uploadInProgress = true;
      console.log('🚀 Starting file upload process');
      showStatus('Preparing upload…');
      
      // Filter out already uploaded files
      const newFiles = files.filter(file => {
        const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
        if (uploadedFiles.has(fileKey)) {
          console.log(`Skipping duplicate file: ${file.name}`);
          return false;
        }
        uploadedFiles.add(fileKey);
        return true;
      });
      
      if (newFiles.length === 0) {
        uploadInProgress = false;
        hideUploadProgress();
        return;
      }
      
      console.log(`📁 Processing ${newFiles.length} new files...`);
      
      // No popup notifications; status tab is the single source of truth
      setStatus(`Uploading… 0/${newFiles.length}`);
      
      const results = [];
      let successCount = 0;
      let errorCount = 0;
      
      try{
        for(const [index, file] of newFiles.entries()){
          console.log(`📄 Starting upload ${index + 1}/${newFiles.length}: ${file.name}`);
          
          // Update progress with file name for better feedback
          updateUploadProgress(index, newFiles.length, file.name);
          setStatus(`Uploading ${file.name}… ${index}/${newFiles.length}`);
          
          // Show processing message for large files
          if (file.size > 5 * 1024 * 1024) { // > 5MB
            setUploadProgressText(`Processing large file: ${file.name}...`);
          }
          
          // Yield to main thread to prevent UI freezing
          await new Promise(resolve => setTimeout(resolve, 50));
          
          try {
            const fd=new FormData(); fd.append('file',file);
            
            // Add authentication token if available
            const headers = {};
            const token = localStorage.getItem('authToken');
            const guestId = localStorage.getItem('guestId');
            
            if (token) {
              headers['Authorization'] = `Bearer ${token}`;
            } else if (guestId) {
              headers['X-Guest-ID'] = guestId;
            }
            
            // Show upload in progress
            setStatus(`Uploading ${file.name}…`);
            
            const res=await fetch('/api/upload',{
              method:'POST',
              headers: headers,
              body:fd
            });
            
            if(!res.ok) {
              const errorData = await res.json().catch(() => ({}));
              throw new Error(errorData.error || `Upload failed with status ${res.status}`);
            }
            
            // Show processing message
            setStatus(`Processing ${file.name}…`);
            
            // Yield to main thread during JSON parsing for large responses
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const data=await res.json();
            console.log(`📄 Server response received for ${file.name}`);
            
            // Yield before heavy processing
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const f=data.file||{};
            const ext=((f.ext||data.ext||file.name.split('.').pop()||'txt')||'').replace(/^\./,'').toLowerCase();
            const parsed={
              originalName: f.originalName || data.name || file.name,
              size: f.size || data.size || file.size,
              mime: f.mime || data.mime || file.type,
              text: data.text || '',
              cues: Array.isArray(data.cues)?data.cues:[],
              ext
            };
            
            // Show completion message
            setStatus(`Finalizing ${file.name}…`);
            
            // Yield to main thread during DOM operations - this is the critical part
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Process DOM operations in chunks to prevent freezing
            await processFileInChunks(parsed);
            
            results.push({ file: parsed, success: true });
            successCount++;
            
            console.log(`✅ File processed: ${parsed.originalName}`);
            
            // Update character count after file processing
            setTimeout(() => {
              if (window.updateCharacterCount) {
                window.updateCharacterCount();
              }
            }, 150);
            
          } catch (fileError) {
            console.error(`❌ Failed to upload ${file.name}:`, fileError);
            results.push({ file: { originalName: file.name }, success: false, error: fileError.message });
            errorCount++;
          }
          
          // Yield between files
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Final progress update
        updateUploadProgress(newFiles.length, newFiles.length);
        setStatus('Upload complete');
        
        // End state summary via status tab only
        if (errorCount === 0) setStatus('Upload complete');
        else if (successCount === 0) setStatus('Upload failed');
        else setStatus(`Upload complete • ${successCount} succeeded, ${errorCount} failed`);
        
      }catch(e){ 
        console.error('File upload error:', e); 
        setStatus('Upload failed');
      }
      finally{
        uploadInProgress = false;
        hideStatus();
        
        // Clear uploaded files tracking after delay (allow for duplicate detection)
        setTimeout(() => {
          uploadedFiles.clear();
        }, 5000);
      }
    }

    /* ---------- Substyles ---------- */
    function renderSubstyles(modeId){
      const subs=(STYLE_DEF[modeId]||{subs:[]}).subs;
      const title=$('#substyleTitle'); if(title){ title.textContent = subs.length ? (t('substyle_for')+' '+styleLabel(modeId)) : t('substyle'); }
      const wrap=$('#chipsWrap'); if(!wrap) return;

      let chips=`<button class="chip active" data-val="" type="button" title="${escapeHTML(t('no_substyle'))}" aria-label="${escapeHTML(t('no_substyle'))}">${t('no_substyle')}</button>`;
      subs.forEach(id=>{
        const label=subLabel(id);
        const tip=microcopyText(modeId,id);
        const aria=tip?`${label}: ${tip}`:label;
        chips+=`<button class="chip" data-val="${id}" type="button" title="${escapeHTML(tip||label)}" aria-label="${escapeHTML(aria)}">${label}</button>`;
      });
      wrap.innerHTML=chips;
      $$('.chip').forEach(ch=>ch.addEventListener('click',()=>setSubStyle(ch.dataset.val)));
      selectedSubStyle="";

      const panel=$('#subStylePanel');
      if(panel && !$('#substyleNote')){
        const note=document.createElement('div');
        note.id='substyleNote'; note.className='substyle-note'; note.setAttribute('aria-live','polite');
        panel.appendChild(note);
      }
      updateSubstyleNote();
    }
    function toggleSubstylePanel(){const panel=$('#subStylePanel');const open=panel&&!panel.classList.contains('open');panel?.classList.toggle('open',open);setChevron(!!open)}
    function setChevron(open){const chev=$('#substyleChevron');if(chev){chev.classList.toggle('up',open);chev.textContent='▾'}}

    function updateSubstyleNote(){
      const el=$('#substyleNote'); if(!el) return;
      const sel=selectedSubStyle||'';
      const canon=resolveAlias(selectedMode, sel);
      const text=(sel && canon.subStyle)?microcopyText(canon.mode, canon.subStyle):'';
      const label=sel?`${subLabel(canon.subStyle)}:`:'';
      if(text && sel){el.innerHTML=`<b>${escapeHTML(label)}</b> ${escapeHTML(text)}`; el.classList.add('show');}
      else{el.textContent=''; el.classList.remove('show');}
      adjustWrapHeight();
    }
    function setSubStyle(val){
      selectedSubStyle=(selectedSubStyle===val)?"":val;
      clearChipSelection();
      const sel=selectedSubStyle===""?'.chip[data-val=""]':`.chip[data-val="${selectedSubStyle}"]`;
      $$(sel).forEach(el=>el.classList.add('active'));
      updateSubstyleNote();
      adjustWrapHeight();
    }
    function clearChipSelection(){$$('.chip').forEach(el=>el.classList.remove('active'))}

    /* ---------- Global sentence splitter helpers ---------- */
    function splitGlobal(text){
      if(!text) return [];
      let chunks=[];
      try{
        const seg = new Intl.Segmenter('und',{granularity:'sentence'});
        chunks = Array.from(seg.segment(text)).map(s=>s.segment);
      }catch{
        const rx=/[^.!?…。！？]+(?:\.\.\.|[.!?…。！？])*/g;
        chunks = (String(text).match(rx)||[]);
      }
      return chunks.map(s=>s.trim()).filter(Boolean);
    }
    function endsWithEllipsis(s){ return /\.\.\.$|…$/.test((s||'').trim()); }
    function isInterjection(s){
      const x=(s||'').trim();
      if(/^(ah|oh|uh|um|erm?|eh|hmm|huh|well|hey|yo|oi|aduh|waduh|yah|ya|loh|lah|nah|duh|whoa|wow|alas|sob|hiks|uy|ehh|bah|euh|oula|hala)[.!?…]*$/i.test(x)) return true;
      if(/^[啊呀哎唉嗯呃喔哦噢哇嘿噗嗨欸〜～…！]*$/.test(x)) return true;
      return false;
    }
    function wordCount(s){return (String(s).trim().match(/[^\s]+/g)||[]).length}
    function charCount(s){return (String(s)||'').replace(/\s/g,'').length}
    function shouldMerge(prev,next){
      const a=(prev||'').trim(),b=(next||'').trim(); if(!a||!b) return false;
      if(isInterjection(a)) return true;
      const trailing=/(?:\.\.\.|\.|…|。|！|？|!|\?)\s*$/.test(a);
      const shortWords = wordCount(a)<=3;
      const shortChars = charCount(a)<=12;
      if(trailing && (shortWords || shortChars)) return true;
      if(endsWithEllipsis(a)) return true;
      return false;
    }
    function segmentText(text){
      const raw = splitGlobal(text);
      if(!raw.length) return [];
      const healed = [];
      for(const cur of raw){
        const last = healed[healed.length-1];
        if(last && shouldMerge(last, cur)){
          healed[healed.length-1] = (last + ' ' + cur).replace(/\s+/g,' ').trim();
        }else{
          healed.push(cur.trim());
        }
      }
      const joined = [];
      for(const cur of healed){
        const prev = joined[joined.length-1];
        if(prev && /[,;:]$/.test(prev) && /^["“”'’]/.test(cur)){
          joined[joined.length-1] = (prev + ' ' + cur).replace(/\s+/g,' ').trim();
        }else{
          joined.push(cur);
        }
      }
      return joined;
    }
    function pickSplitPoint(s){
      const str = String(s);
      if(str.length < 24) return -1;
      const halfway = Math.floor(str.length * 0.45);
      const candidates = /[.!?。！？…]+/g;
      let m, best=-1;
      while((m=candidates.exec(str))){
        const i = candidates.lastIndex;
        if(i >= halfway){ best = i; break; }
      }
      if(best>0) return best;
      const commas = /[,;、，؛]/g;
      while((m=commas.exec(str))){
        const i = commas.lastIndex;
        if(i >= halfway){ best = i; break; }
      }
      if(best>0) return best;
      const space = str.indexOf(' ', Math.max(halfway, 8));
      return space>0 ? space : -1;
    }
    function alignToSource(targetText, srcCount){
      let segs = segmentText(targetText).slice();
      if(segs.length===srcCount){
        for(let i=1;i<segs.length;i++){
          const prev = segs[i-1], cur = segs[i];
          const prevIsMicro = endsWithEllipsis(prev) || wordCount(prev)<=2 || charCount(prev)<=8;
          if(prevIsMicro){
            const merged = (prev + ' ' + cur).replace(/\s+/g,' ').trim();
            const cut = pickSplitPoint(merged);
            if(cut>0){
              segs[i-1] = merged.slice(0,cut).trim();
              segs[i]   = merged.slice(cut).trim();
            }else{
              segs[i-1] = merged;
              segs.splice(i,1);
              break;
            }
          }
        }
      }
      while(segs.length > srcCount){
        let idx = segs.findIndex(s => isInterjection(s) || charCount(s) < 15 || endsWithEllipsis(s));
        if(idx <= 0) idx = 1;
        segs[idx-1] = (segs[idx-1] + ' ' + segs[idx]).replace(/\s+/g,' ').trim();
        segs.splice(idx,1);
      }
      while(segs.length < srcCount){
        let longest = 0, li = 0;
        for(let i=0;i<segs.length;i++){
          const len = charCount(segs[i]);
          if(len > longest){ longest = len; li = i; }
        }
        const cut = pickSplitPoint(segs[li]);
        if(cut>0){
          const a = segs[li].slice(0,cut).trim();
          const b = segs[li].slice(cut).trim();
          segs.splice(li,1,a,b);
        }else{
          segs.push('');
          break;
        }
      }
      return segs;
    }
    function buildRowHTML(text, idx, isTarget = false){
      const s = String(text || '');
      const words = (s.trim().match(/[^\s]+/g) || []).length;
      const chars = s.replace(/\s/g,'').length;
      
      if (isTarget) {
        // Use textarea for target segments to avoid contenteditable issues
        return `
          <div class="segrow" data-idx="${idx}">
            <div class="lineno">${idx+1}</div>
            <div class="segcontent">
              <textarea class="segtext-textarea" data-idx="${idx}" rows="2">${escapeHTML(s)}</textarea>
              <div class="segmeta">${words} words · ${chars} chars</div>
            </div>
          </div>`;
      } else {
        return `
          <div class="segrow" data-idx="${idx}">
            <div class="lineno">${idx+1}</div>
            <div class="segcontent">
              <div class="segtext">${escapeHTML(s)}</div>
              <div class="segmeta">${words} words · ${chars} chars</div>
            </div>
          </div>`;
      }
    }
    /** Wire textarea editors for target segments */
    function wireSegmentEditors(){
      const d = currentDoc(); if(!d) return;
      const textareas = Array.from(document.querySelectorAll('#segTgtBox .segtext-textarea'));
      if (!Array.isArray(d.lastAlignedTgt) || d.lastAlignedTgt.length !== textareas.length) {
        // Initialize target cache from current DOM
        d.lastAlignedTgt = textareas.map(ta => ta.value || '');
        d.output = d.lastAlignedTgt.join('\n');
      }

      textareas.forEach(textarea => {
        const idx = Number(textarea.getAttribute('data-idx')||'0');
        const row = textarea.closest('.segrow');
        const metaEl = row?.querySelector('.segmeta');
        
        // Auto-resize textarea
        const autoResize = () => {
          textarea.style.height = 'auto';
          textarea.style.height = Math.max(40, textarea.scrollHeight) + 'px';
        };
        
        autoResize();
        
        textarea.addEventListener('input', ()=>{
          const val = textarea.value || '';
          d.lastAlignedTgt[idx] = val;
          d.output = d.lastAlignedTgt.join('\n');
          
          // Update word/char count
          if (metaEl){
            const w = (val.trim().match(/[^\s]+/g) || []).length;
            const c = val.replace(/\s/g,'').length;
            metaEl.textContent = `${w} words · ${c} chars`;
          }
          
          autoResize();
        });
      });
    }
    function renderSegmentBoxes(doc){
      const d = doc || currentDoc(); if(!d) return;
      if(d.isSrt){ renderSrtBoxes(d); return; }

      const srcSegs=segmentText(d.text||'');
      const nSrc = srcSegs.length;

      let tgtSegs;
      if(Array.isArray(d.lastAlignedTgt) && d.lastAlignedTgt.length === nSrc){
        tgtSegs = d.lastAlignedTgt.slice();
      }else{
        const tgtVal = d.output || '';
        tgtSegs = alignToSource(tgtVal, nSrc);
      }

      const n=Math.max(srcSegs.length,tgtSegs.length);
      const src=$('#segSrcBox'),tgt=$('#segTgtBox'); if(!src||!tgt) return;
      const savedSrc=src.scrollTop, savedTgt=tgt.scrollTop;
      src.innerHTML=''; tgt.innerHTML='';
      for(let i=0;i<n;i++){
        src.insertAdjacentHTML('beforeend',buildRowHTML(srcSegs[i]||'',i, false));
        tgt.insertAdjacentHTML('beforeend',buildRowHTML(tgtSegs[i]||'',i, true));
      }
      wireSegmentEditors();
      equalizeRowHeights(); syncScroll(src,tgt); adjustWrapHeight();
      // Restore scroll positions to avoid anchoring shifts on re-render
      src.scrollTop=savedSrc; tgt.scrollTop=savedTgt;
    }
    function equalizeRowHeights(){
      const srcRows=$('#segSrcBox')?$('#segSrcBox').querySelectorAll('.segrow'):[];
      const tgtRows=$('#segTgtBox')?$('#segTgtBox').querySelectorAll('.segrow'):[];
      const n=Math.max(srcRows.length,tgtRows.length);
      for(let i=0;i<n;i++){
        equalizeRowHeightsAtIndex(i, srcRows[i], tgtRows[i]);
      }
    }
    function equalizeRowHeightsAtIndex(i, aEl, bEl){
      const a = aEl || document.querySelector(`#segSrcBox .segrow[data-idx="${i}"]`);
      const b = bEl || document.querySelector(`#segTgtBox .segrow[data-idx="${i}"]`);
      if(!a||!b) return;
      // Reset constraints for these two rows only
      a.style.minHeight='unset'; b.style.minHeight='unset';
      a.style.height='auto';     b.style.height='auto';
      a.style.width='auto';      b.style.width='auto';
      a.style.maxHeight='none';  b.style.maxHeight='none';

      const aContent = a.querySelector('.segcontent');
      const bContent = b.querySelector('.segcontent');
      const aText = a.querySelector('.segtext');
      const bText = b.querySelector('.segtext');
      if (aContent){aContent.style.width='100%';aContent.style.height='auto';aContent.style.overflow='visible';aContent.style.minHeight='auto'}
      if (bContent){bContent.style.width='100%';bContent.style.height='auto';bContent.style.overflow='visible';bContent.style.minHeight='auto'}
      if (aText){aText.style.width='100%';aText.style.height='auto';aText.style.overflow='visible';aText.style.maxHeight='none'}
      if (bText){bText.style.width='100%';bText.style.height='auto';bText.style.overflow='visible';bText.style.maxHeight='none'}
      // Force layout calc for these rows only
      a.offsetHeight; b.offsetHeight;
      const ha = a.offsetHeight, hb = b.offsetHeight;
      const h = Math.max(ha, hb);
      // Only raise the shorter row to avoid reflow on both panes
      if(ha < h) a.style.minHeight = h+'px';
      if(hb < h) b.style.minHeight = h+'px';
    }
    function syncScroll(a,b){
      if(!a||!b||a._syncPartner===b) return;
      a._syncPartner=b; b._syncPartner=a;
      let lock=false;
      let isTyping=false;
      
      // Disable scroll sync while typing
      document.addEventListener('input',(e)=>{
        if(e.target.matches('#segTgtBox .segtext[contenteditable="true"]')){
          isTyping=true;
          clearTimeout(window._typingTimeout);
          window._typingTimeout=setTimeout(()=>isTyping=false,200);
        }
      });
      
      a.addEventListener('scroll',()=>{ if(lock||isTyping) return; lock=true; b.scrollTop=a.scrollTop; lock=false; },{passive:true});
      b.addEventListener('scroll',()=>{ if(lock||isTyping) return; lock=true; a.scrollTop=b.scrollTop; lock=false; },{passive:true});
    }
    function debounce(fn,ms){let t;return()=>{clearTimeout(t);t=setTimeout(fn,ms)}}
    
    /* (removed Edit Mode code) */

    function renderSrtBoxes(doc){
      const d=doc||currentDoc(); if(!d) return;
      const src=$('#segSrcBox'),tgt=$('#segTgtBox'); if(!src||!tgt) return;
      const cues = d.cues||[];
      src.innerHTML=''; tgt.innerHTML='';
      const useCues = cues.length>0 ? cues : ( (d.text||'').split(/\r?\n/).map(txt=>({text:txt,start:'',end:''})) );
      for(let i=0;i<useCues.length;i++){
        const c=useCues[i];
        const srcWords = wordCount(c.text||''); const srcChars = charCount(c.text||'');
        const srcHTML = `<div class="segrow" data-idx="${i}">
            <div class="lineno">${i+1}</div>
            <div class="segcontent">
              <div class="segtext">${escapeHTML(c.text||'')}</div>
              <div class="segmeta">${escapeHTML(c.start||'')} ${c.start||c.end ? '→' : '—'} ${escapeHTML(c.end||'')} · ${srcWords} words · ${srcChars} chars</div>
            </div>
          </div>`;
        // Normalize any HTML line breaks from upstream to real newlines so textarea grows correctly
        const tgtVal = (d.srtTranslations[i]||'').replace(/<br\s*\/?>(?=\s*|$)/gi,'\n');
        const tgtWords = wordCount(tgtVal); const tgtChars = charCount(tgtVal);
        const tgtHTML = `<div class="segrow" data-idx="${i}">
            <div class="lineno">${i+1}</div>
            <div class="segcontent">
              <textarea data-srt="${i}">${escapeHTML(tgtVal)}</textarea>
              <div class="segmeta" id="tmeta-${i}">${escapeHTML(c.start||'')} ${c.start||c.end ? '→' : '—'} ${escapeHTML(c.end||'')} · ${tgtWords} words · ${tgtChars} chars</div>
            </div>
          </div>`;
        src.insertAdjacentHTML('beforeend',srcHTML);
        tgt.insertAdjacentHTML('beforeend',tgtHTML);
      }
      $$('textarea[data-srt]').forEach(el=>{
        // Grow to fit content including explicit <br> from cues
        const autoGrow = (ta)=>{
          ta.style.height = 'auto';
          ta.style.overflowY = 'hidden';
          const h = Math.max(44, ta.scrollHeight);
          ta.style.height = h + 'px';
        };
        autoGrow(el);
        el.addEventListener('input',e=>{
          const idx=Number(e.target.getAttribute('data-srt'));
          d.srtTranslations[idx]=e.target.value;
          d.output = (d.srtTranslations||[]).join('\n');
          $('#outputText').value = d.output;
          const c = useCues[idx]||{};
          const w = wordCount(e.target.value), ch = charCount(e.target.value);
          const meta = $(`#tmeta-${idx}`); if(meta) meta.textContent = `${(c.start||'')} ${c.start||c.end?'→':'—'} ${(c.end||'')} · ${w} words · ${ch} chars`;
          autoGrow(e.target);
          equalizeRowHeights();
          updateSplitButton();
        });
        // Regrow on initial paint and when fonts load
        setTimeout(()=>autoGrow(el),50);
        window.addEventListener('resize',()=>autoGrow(el));
      });
      $('#outputText').value = d.output || (d.srtTranslations||[]).join('\n');
      autosizeTextarea($('#outputText'));
      equalizeRowHeights(); syncScroll(src,tgt); adjustWrapHeight();
      // Final pass: ensure every textarea height matches its scrollHeight
      requestAnimationFrame(()=>{
        $$('textarea[data-srt]').forEach(ta=>{
          ta.style.height='auto';
          ta.style.overflowY='hidden';
          ta.style.height=Math.max(44, ta.scrollHeight)+'px';
        });
        equalizeRowHeights();
      });
    }

    // Capture inline edits in split view target segments (non-SRT)
    function wireSplitEditHandlers(){
      try{
        document.querySelectorAll('#segTgtBox .segrow .segtext[contenteditable="true"]').forEach((el,idx)=>{
          if(el._wiredEdit) return; el._wiredEdit=true;
          const onInput=()=>{
            const doc=currentDoc(); if(!doc) return;
            const val=(el.textContent||'').replace(/\r/g,'');
            if(!Array.isArray(doc.lastAlignedTgt)) doc.lastAlignedTgt=[];
            doc.lastAlignedTgt[idx]=val;
            doc.output = (doc.lastAlignedTgt||[]).join('\n');
            const out=$('#outputText'); if(out){ out.value=doc.output; autosizeTextarea(out); }
          };
          el.addEventListener('input', onInput);
          el.addEventListener('blur', onInput);
        });
      }catch{}
    }

    /* ---------- Load/Save doc <-> UI ---------- */
    function loadDocToUI(doc){
      if(!doc) return;
      // Input
      $('#inputText').value = doc.text || '';
      autosizeTextarea($('#inputText'));
      // Update character count when loading new document
      setTimeout(() => {
        if (window.updateCharacterCount) {
          window.updateCharacterCount();
        }
      }, 10);
      // Output
      if(doc.isSrt){
        $('#outputRich').classList.add('is-hidden');
        $('#outputText').classList.remove('is-hidden');
        $('#outputText').value = (doc.srtTranslations||[]).join('\n');
        autosizeTextarea($('#outputText'));
      }else{
        $('#outputText').classList.add('is-hidden');
        $('#outputRich').classList.remove('is-hidden');
        $('#outputRich').textContent = doc.output || '';
        syncRichToHidden();
      }
      // Split view state
      if(splitView){ if(doc.isSrt) renderSrtBoxes(doc); else { renderSegmentBoxes(doc); wireSplitEditHandlers(); } }
      updateSplitButton();
      adjustWrapHeight();
      renderTabs();
    }

    function syncRichToHidden(){
      const d=currentDoc(); if(!d) return;
      let val = $('#outputRich').textContent || '';
      let hidden = $('#outputText');
      if(hidden){ hidden.value = val; autosizeTextarea(hidden); }
    }

    /* ---------- Actions (translate / download) ---------- */
    function selectTarget(lang){if(targetLanguage===lang){targetLanguage=''; $$('.lang-btn').forEach(b=>{if(b.dataset.lang===lang)b.classList.remove('active')})}else{targetLanguage=lang; rephrase=false; $('#btnRephrase')?.classList.remove('active'); $$('.lang-btn').forEach(b=>b.classList.toggle('active',b.dataset.lang===lang))} adjustWrapHeight()}
    function toggleRephrase(){rephrase=!rephrase; $('#btnRephrase')?.classList.toggle('active',rephrase); if(rephrase){targetLanguage=''; $$('.lang-btn').forEach(b=>b.classList.remove('active'))} adjustWrapHeight()}

    function setMode(modeId){
      const container=$('#subStyleContainer'), panel=$('#subStylePanel');
      if(selectedMode===modeId){
        selectedMode=""; $$('.style-btn').forEach(b=>b.classList.remove('active'));
        container?.classList.add('is-hidden'); panel?.classList.remove('open'); setChevron(false);
        selectedSubStyle=""; clearChipSelection(); adjustWrapHeight(); return;
      }
      selectedMode=modeId;
      $$('.style-btn').forEach(b=>b.classList.remove('active'));
      document.querySelector(`.style-btn[data-mode="${modeId}"]`)?.classList.add('active');
      renderSubstyles(modeId);
      container?.classList.remove('is-hidden'); panel?.classList.remove('open'); setChevron(false);
      adjustWrapHeight();
    }



    async function submitActiveDoc(doc, opts={}){
      const d=doc||currentDoc(); if(!d) { showToast('No tab'); return; }
      if(d.isSrt){
        return submitSrtDoc(d, opts);
      }
      const input=(d.text||'').trim();
      if(!input){showToast(t('toast_enter_text'));pulse($('#inputText'));return}
      
      // Check character limit
      if (!(await window.checkCharacterLimit(input))) {
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        const tier = user.isGuest ? 'guest' : (user.tier || 'free');
        const tierConfig = window.getTierLimit(tier);
        
        if (user.isGuest) {
          showToast(`Text exceeds ${tierConfig.maxInputSize.toLocaleString()} character limit. Sign in to get higher limits!`);
          // Auto-open sign in modal for guests
          setTimeout(() => {
            if (typeof openAuth === 'function') openAuth('login');
          }, 1000);
        } else {
          showToast(`Text exceeds ${tierConfig.name} tier limit of ${tierConfig.maxInputSize.toLocaleString()} characters. Upgrade for higher limits!`);
        }
        
        pulse($('#inputText'));
        return;
      }
      
      if(!targetLanguage && !rephrase){showToast(t('toast_choose_target'));pulse($('#langButtonsRow'));return}
      if(!selectedMode){showToast(t('toast_choose_style'));pulse($('#styleButtonsRow'));return}

      try{
        if(!opts.silent) showLoader(true,'Localizing…');
        await runTextDoc(d);
        (document.querySelector('#outputText')||document.querySelector('#outputRich'))?.scrollIntoView({behavior:'smooth',block:'center'});
      }catch(e){console.error(e);showToast(t('toast_error_generic'))}
      finally{
        if(!opts.silent){
          setStatus('Localization done');
          setTimeout(()=>hideLoader(true),120);
        }
      }
    }

    async function submitSrtDoc(d, opts={}){
      const items = (d.cues?.length?d.cues.map(c=>c.text):(d.text||'').split(/\r?\n/)).map(v=>v||'');
      if(!items.length){ showToast('No SRT cues'); return; }
      if(!targetLanguage && !rephrase){showToast(t('toast_choose_target'));pulse($('#langButtonsRow'));return}
      if(!selectedMode){showToast(t('toast_choose_style'));pulse($('#styleButtonsRow'));return}
      try{
        if(!opts.silent) showLoader(true,'Localizing…');
        await runSrtDoc(d);
      }catch(e){ console.error(e); showToast(t('toast_error_generic')) }
      finally{ 
        if(!opts.silent){
          setStatus('Localization done');
          setTimeout(()=>hideLoader(true),120);
        }
      }
    }

    async function translateAllTabs(){
      if(!docs.length){ showToast('No tabs'); return; }
      if(!targetLanguage && !rephrase){showToast(t('toast_choose_target'));pulse($('#langButtonsRow'));return}
      if(!selectedMode){showToast(t('toast_choose_style'));pulse($('#styleButtonsRow'));return}

      // Only work on tabs that actually have content
      const work = docs.filter(d=>{
        if(d.isSrt){
          const items = (d.cues?.length?d.cues.map(c=>c.text):(d.text||'').split(/\r?\n/)).map(v=>(v||'').trim());
          return items.some(v=>v.length);
        }else{
          return (d.text||'').trim().length>0;
        }
      });
      if(!work.length){ showToast('Nothing to translate.'); return; }

      showLoader(true,`Localizing 0/${work.length}`);
      try{
        let i=0;
        for(const d of work){
          i++;
          const prettyName = (d.name || '').toString().trim() || (d.ext?`Untitled.${(d.ext||'').toUpperCase()}`:'Untitled');
          setLoaderText(`Localizing ${prettyName} ${i}/${work.length}`);
          setStatus(`Localizing ${prettyName} ${i}/${work.length}`);
          if(d.isSrt) await runSrtDoc(d);
          else await runTextDoc(d);
          setLoaderText(`Localizing ${prettyName} ${i}/${work.length}`);
          setStatus(`Localizing ${prettyName} ${i}/${work.length}`);
        }
      }catch(e){ console.error(e); showToast(t('toast_error_generic'))}
      finally{ setStatus('Localization done'); hideLoader(true); }
    }

    async function downloadLocalized(d){
      d = d || currentDoc(); if(!d) return;
      const base = (d.name||'output').replace(/\.[^.]+$/,'');
      if(d.isSrt){
        const cues = (d.cues||[]).map((c,i)=>({ start:c.start||'', end:c.end||'', text:(d.srtTranslations?.[i]||'') }));
        const payload = { format:'srt', filename:`${base}.localized`, cues, type:'srt', name:`${base}.localized.srt` };
        try{
          const res = await fetch('/api/download',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
          if(!res.ok) throw new Error('HTTP '+res.status);
          const blob = await res.blob();
          const url = URL.createObjectURL(blob); const a=document.createElement('a');
          a.href=url; a.download=`${base}.localized.srt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        }catch(e){ console.error(e); showToast(t('toast_error_generic')) }
        return;
      }

      const text = d.output || '';
      const ext = ['pdf','docx','txt'].includes((d.ext||'').toLowerCase()) ? d.ext.toLowerCase() : 'txt';
      const payload={ text, filename:`${base}.localized`, format:ext };
      try{
        const res = await fetch('/api/download',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `${base}.localized.${ext}`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }catch(e){ console.error(e); showToast(t('toast_error_generic')) }
    }

    async function downloadAllZip(){
      const files = docs.map(d=>{
        if(d.isSrt){
          const base=(d.name||'output').replace(/\.[^.]+$/,'');
          const cues = (d.cues||[]).map((c,i)=>({start:c.start||'', end:c.end||'', text:(d.srtTranslations?.[i]||'')}));
          const hasAny = cues.some(c=> (c.text||'').trim().length );
          if(!hasAny) return null;
          return { filename:`${base}.localized`, type:'srt', format:'srt', cues };
        }else{
          const out=(d.output||'').trim();
          if(!out) return null;
          const base=(d.name||'output').replace(/\.[^.]+$/,'');
          const ext = ['pdf','docx','txt'].includes((d.ext||'').toLowerCase())?d.ext.toLowerCase():'txt';
          return { filename:`${base}.localized`, format:ext, text:out };
        }
      }).filter(Boolean);

      if(!files.length){ showToast('Nothing to download yet.'); return; }
      try{
        
        // Add authentication headers
        const headers = {'Content-Type':'application/json'};
        const token = localStorage.getItem('authToken');
        const guestId = localStorage.getItem('guestId');
        
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        } else if (guestId) {
          headers['X-Guest-ID'] = guestId;
        }
        
        const res=await fetch('/api/download-zip',{method:'POST',headers:headers,body:JSON.stringify({zipname:'localized_bundle', files})});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const blob=await res.blob();
        const url=URL.createObjectURL(blob);
        const a=document.createElement('a');
        a.href=url; a.download='localized_bundle.zip';
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }catch(e){ console.error(e); showToast(t('toast_error_generic')) }
    }

    /* ---------- Split view ---------- */
    function toggleSplitView(){
      const has = hasAnyResult();
      const d=currentDoc();
      if(!splitView && !has) return;
      if(!splitView){
        if(d?.isSrt) renderSrtBoxes(d); else renderSegmentBoxes(d);
        splitView=true; updateSplitButton();
        crossfade('#stackArea','#splitArea',()=>{
          observeActiveHeight(); 
          
          // Fix text clipping in split view - ensure all text is visible
          setTimeout(() => {
            document.querySelectorAll('.view.split .segtext, #segSrcBox .segtext, #segTgtBox .segtext').forEach(el => {
              el.style.maxHeight = 'none';
              el.style.overflow = 'visible';
              el.style.height = 'auto';
              el.style.whiteSpace = 'pre-wrap';
            });
            
            document.querySelectorAll('.view.split .segcontent, #segSrcBox .segcontent, #segTgtBox .segcontent').forEach(el => {
              el.style.maxHeight = 'none';
              el.style.overflow = 'visible';
              el.style.height = 'auto';
            });
            
            document.querySelectorAll('.view.split .segrow, #segSrcBox .segrow, #segTgtBox .segrow').forEach(el => {
              el.style.maxHeight = 'none';
              el.style.height = 'auto';
              el.style.alignItems = 'stretch';
            });
            
            equalizeRowHeights();
            console.log('📱 Split view text clipping fixed');
          }, 100);
        })
      }else{
        splitView=false; updateSplitButton();
        crossfade('#splitArea','#stackArea',()=>{const wrap=$('#modeWrap');wrap.classList.remove('layered');wrap.style.height='';if(heightRO){heightRO.disconnect();heightRO=null}})
      }
    }
    function crossfade(fromSel,toSel,done){const wrap=$('#modeWrap'),from=$(fromSel),to=$(toSel); if(!wrap||!from||!to){done&&done();return} wrap.classList.add('layered'); const hFrom=getContentH(from); wrap.style.height=hFrom+'px'; to.classList.add('active'); from.classList.remove('active'); requestAnimationFrame(()=>{const hTo=getContentH(to); wrap.style.height=hTo+'px'; const finalize=()=>{wrap.removeEventListener('transitionend',onEnd);done&&done()}; const onEnd=e=>{if(e.propertyName!=='height')return;finalize()}; wrap.addEventListener('transitionend',onEnd); if(Math.abs(hTo-hFrom)<1) setTimeout(finalize,20)})}
    function observeActiveHeight(){const wrap=$('#modeWrap'),active=wrap?.querySelector('.view.active'); if(!wrap||!active) return; if(heightRO) heightRO.disconnect(); heightRO=new ResizeObserver(()=>{if(wrap.classList.contains('layered')){wrap.style.height=getContentH(active)+'px'}}); heightRO.observe(active)}
    function adjustWrapHeight(){
      const wrap=$('#modeWrap'),active=wrap?.querySelector('.view.active');
      if(!wrap||!active) return;
      if(wrap.classList.contains('layered')){wrap.style.height=getContentH(active)+'px'}else{wrap.style.height=''}
    }

        /* ---------- Copy helper ---------- */
    async function copyText(sel, btnSel){
      try{
        const n=$(sel); const v=n?.value || n?.textContent || '';
        await navigator.clipboard.writeText(v);
        const b=$(btnSel); if(b) animateCopy(b);
      }catch{}
    }

    // ===========================================================
// Brand Kit + Advanced Tools (Glossary & Phrasebook)
// ===========================================================

  /* ---------- Storage keys ---------- */
  const BRAND_KEY='brandKit:v2';              // bumped for UI change
  const GLOSSARY_KEY='glossary:v1';
  const GLOSSARY_ENABLED_KEY='glossaryEnabled:v1';

  /* ---------- Lightweight user account (UID) ---------- */
  const UID_KEY='locUID';
  function getUID(){
    let u=localStorage.getItem(UID_KEY);
    if(!u){ u='u_'+Math.random().toString(36).slice(2)+Date.now().toString(36); localStorage.setItem(UID_KEY,u); }
    return u;
  }

  /* ---------- Helpers ---------- */
  const readJSON=(k,f)=>{try{return JSON.parse(localStorage.getItem(k)||'null')??(typeof f==='function'?f():f)}catch{return (typeof f==='function'?f():f)}};
  const writeJSON=(k,v)=>localStorage.setItem(k,JSON.stringify(v||null));
  const defBrand=()=>({
    name:'',
    tone:[],
    audience:'',
    doList:'',
    dontList:'',
    examples:''
  });
  const defGlossary=()=>[];   // [{src:'Login', tgt:'Masuk', flags:{lock:true,case:'auto'}, notes:''}]

    /* ---------- Global style injector (fixes/clips/animations) ---------- */
  function ensureGlobalUIStyles(){
    if(document.getElementById('globalEnhanceCSS')) return;
    const css = `
      /* ====== TUNE HERE: Save bubble look ======
         Change these two variables to experiment.
         Example: --save-bubble-blur: 16px; --save-bubble-alpha: .72; */
      :root{
        --save-bubble-blur: 2px;
        --save-bubble-alpha: 0.40;
        /* NEW — tune modal sheet glass here (Brand/Advanced/History) */
        --sheet-glass-blur: var(--save-bubble-blur);   /* e.g. 4px */
        --sheet-glass-alpha: var(--save-bubble-alpha); /* e.g. .10 */
      }

            /* Glass look for modal sheets (Brand Kit, Advanced Tools, History, Language).
        Uses the same tuning vars as the save bubble by default. */
      #brandOverlay .lang-sheet,
      #advOverlay .lang-sheet,
      #histOverlay .lang-sheet,
      #langOverlay .lang-sheet{
        background: rgba(255,255,255,var(--sheet-glass-alpha));
        -webkit-backdrop-filter: blur(var(--sheet-glass-blur)) saturate(1.50);
        backdrop-filter: blur(var(--sheet-glass-blur)) saturate(1.50);
        border: 1px solid rgba(0,0,0,.08);
        box-shadow: 0 10px 40px rgba(0,0,0,.12);
}

      /* Save bubble — glassy, never covers selection */
      .save-bubble{
        position:fixed;z-index:9999;transform:translate(-50%,-6px) scale(.98);opacity:0;
        background:rgba(255,255,255,var(--save-bubble-alpha));
        -webkit-backdrop-filter:blur(var(--save-bubble-blur));backdrop-filter:blur(var(--save-bubble-blur));
        border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:8px 12px;box-shadow:0 8px 28px rgba(0,0,0,.12);
        display:flex;align-items:center;gap:8px;font-size:13px;pointer-events:none;transition:opacity .16s var(--ease),transform .16s var(--ease)
      }
      .save-bubble.show{opacity:1;transform:translate(-50%,-10px) scale(1);pointer-events:auto}
      .save-bubble .act{border:1px solid var(--border);border-radius:10px;padding:6px 10px;background:#fff;cursor:pointer}
      .save-bubble .ok{display:none;color:var(--accent)}
      .save-bubble.saved .ok{display:inline}
      .save-bubble.saved .label{display:none}

      /* Prevent horizontal scrollbars inside overlays */
      #advOverlay .lang-sheet, #brandOverlay .lang-sheet{ overflow-x:hidden; box-sizing:border-box }

      /* Brand Kit form — fixed layout */
      #brandOverlay .lang-sheet{max-width:95vw; width:1200px; overflow-x:hidden}
      .brand-container{
        padding:24px 28px; margin:0;
      }
      .brand-top-section{
        display:grid; grid-template-columns:1fr auto; gap:20px; align-items:flex-start; margin-bottom:24px;
      }
      .brand-name-section{}
      .brand-toggle-section{display:flex; align-items:center; gap:12px}
      
      .brand-tones-section{margin-bottom:24px}
      
      .brand-bottom-grid{
        display:grid; grid-template-columns:1fr 1fr 1fr; gap:20px; margin-bottom:24px;
      }
      .brand-footer{
        display:flex; justify-content:flex-end; gap:12px; padding-top:20px; 
        border-top:1px solid #e5e7eb;
      }
      
      .brand-section-label{
        font-size:14px; font-weight:600; color:#1a1a1a; margin-bottom:8px; display:block;
      }
      .brand-input{
        width:300px; min-width:300px; max-width:100%; padding:12px 16px; border:1px solid #d1d5db; border-radius:12px; 
        background:#fff; font-size:14px; font-family:inherit;
        transition:border-color .2s ease, box-shadow .2s ease, width .2s ease;
      }
      .brand-input:focus{
        width:400px;
        outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak);
      }
      .brand-textarea{
        width:100%; min-height:140px; padding:12px 16px; border:1px solid #d1d5db; 
        border-radius:12px; background:#fff; font-size:14px; font-family:inherit; resize:vertical;
        transition:border-color .2s ease, box-shadow .2s ease;
      }
      .brand-textarea:focus{
        outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak);
      }

      /* Tone chips — exact design replica */
      .tones-grid{
        display:grid; grid-template-columns:repeat(5, 1fr); gap:8px; margin-top:8px;
        grid-template-rows:auto auto;
      }
      .tone-chip{ 
        padding:10px 16px; border:2px solid #e5e7eb; border-radius:20px; background:#fff; 
        font-size:13px; font-weight:500; cursor:pointer; 
        transition:all .18s ease; color:#374151; white-space:nowrap;
        text-align:center; box-shadow:0 1px 3px rgba(0,0,0,.08);
      }
      .tone-chip:hover{
        background:#f8f9fa; transform:translateY(-1px);
        border-color:#d1d5db; box-shadow:0 3px 8px rgba(0,0,0,.12);
      }
      .tone-chip.active{ 
        background:var(--accent); color:#fff; font-weight:600;
        border:2px solid var(--accent); 
        box-shadow:0 0 0 2px var(--accent-weak), 0 3px 12px rgba(0,122,255,.25);
      }
      .tone-chip.active:hover{
        background:#0056d6; border-color:#0056d6; transform:translateY(-1px);
        box-shadow:0 0 0 3px var(--accent-weak), 0 4px 16px rgba(0,122,255,.35);
      }
      
      /* Brand toggle switch */
      .brand-toggle{
        position:relative; width:52px; height:28px; border-radius:20px; 
        background:#cbd5e1; cursor:pointer; transition:background .3s ease;
        border:none; outline:none;
      }
      .brand-toggle.active{background:var(--accent)}
      .brand-toggle::after{
        content:''; position:absolute; top:2px; left:2px; width:24px; height:24px;
        background:#fff; border-radius:50%; transition:transform .3s ease;
        box-shadow:0 1px 3px rgba(0,0,0,.3);
      }
      .brand-toggle.active::after{transform:translateX(24px)}
      
      .brand-toggle-label{
        font-size:13px; font-weight:500; color:#374151;
      }
      


      /* Advanced overlay + tabs */
      #advOverlay .lang-sheet{max-width:90vw; width:1100px; overflow-x:hidden;}
      .adv-tabs{display:flex;gap:8px;padding:10px 12px;border-bottom:1px solid rgba(0,0,0,0.08);position:sticky;top:0;background:rgba(255,255,255,0.1);backdrop-filter:blur(var(--sheet-glass-blur)) saturate(1.50);z-index:1}
      .adv-tab{border:1px solid rgba(0,0,0,0.08);background:rgba(255,255,255,0.2);backdrop-filter:blur(8px);border-radius:999px;padding:6px 12px;font-size:13px;cursor:pointer;transition:all .15s ease;}
      .adv-tab:hover{background:rgba(255,255,255,0.3);border-color:rgba(0,122,255,0.3);transform:translateY(-1px);}
      .adv-tab.active{background:rgba(255,255,255,0.4);border-color:var(--accent);box-shadow:0 0 0 2px var(--accent-weak);backdrop-filter:blur(12px);}

      .adv-pane{display:none;padding:14px 16px;}
      .adv-pane.active{display:block;}

      /* Glossary table — improved spacing and styling */
      .bp-table{ width:100%; border:1px solid var(--border); border-radius:12px; overflow:visible; background:#fff; box-shadow:var(--shadow-soft) }
      .bp-table table{ width:100%; border-collapse:collapse; font-size:14px }
      .bp-table th,.bp-table td{ border-top:1px solid #f0f0f3; padding:12px 16px; vertical-align:top; }
      .bp-table th:first-child{ border-top-left-radius:12px; }
      .bp-table th:last-child{ border-top-right-radius:12px; }
      .bp-table th{ background:#fafafa; font-weight:600; text-align:left; white-space:nowrap; font-size:14px; color:#1a1a1a; }
      .bp-table td input[type="text"]{ 
        width:100%; min-width:180px; padding:8px 12px; border:1px solid #d1d5db; 
        border-radius:8px; background:#fff; font-size:14px; font-family:inherit;
        transition:border-color .2s ease, box-shadow .2s ease;
      }
      .bp-table td input[type="text"]:focus{
        outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak);
      }
      .bp-table td select{ 
        min-width:160px; padding:8px 12px; border:1px solid #d1d5db; 
        border-radius:8px; background:#fff; font-size:14px; font-family:inherit;
        transition:border-color .2s ease, box-shadow .2s ease;
      }
      .bp-table td select:focus{
        outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak);
      }
      .bp-table.is-disabled{ opacity:.6 }
      .bp-toolbar{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
      .mini{ 
        padding:10px 16px; border:2px solid #e5e7eb; border-radius:12px; background:#fff; 
        font-size:13px; font-weight:500; cursor:pointer; 
        transition:all .18s ease; color:#374151; white-space:nowrap;
        text-align:center; box-shadow:0 1px 3px rgba(0,0,0,.08);
      }
      .mini:hover{
        background:#f8f9fa; transform:translateY(-1px);
        border-color:#d1d5db; box-shadow:0 3px 8px rgba(0,0,0,.12);
      }
      .mini.primary{ 
        background:var(--accent); color:#fff; font-weight:600;
        border:2px solid var(--accent); 
        box-shadow:0 0 0 2px var(--accent-weak), 0 3px 12px rgba(0,122,255,.25);
      }
      .mini.primary:hover{
        background:#0056d6; border-color:#0056d6; transform:translateY(-1px);
        box-shadow:0 0 0 3px var(--accent-weak), 0 4px 16px rgba(0,122,255,.35);
      }

      /* Glossary ON/OFF switch - same as brand toggle */
      .gl-toggle{display:inline-flex;align-items:center;gap:12px;margin-left:4px}
      .gl-switch{
        position:relative; width:52px; height:28px; border-radius:20px; 
        background:#cbd5e1; cursor:pointer; transition:background .3s ease;
        border:none; outline:none;
      }
      .gl-switch.on{background:var(--accent)}
      .gl-switch::after{
        content:''; position:absolute; top:2px; left:2px; width:24px; height:24px;
        background:#fff; border-radius:50%; transition:transform .3s ease;
        box-shadow:0 1px 3px rgba(0,0,0,.3);
      }
      .gl-switch.on::after{transform:translateX(24px)}
      .gl-label{font-size:13px; font-weight:500; color:#374151;}

      /* Phrasebook Saved (refined) */
      .pb-wrap{ display:grid; grid-template-columns:1fr; gap:12px; }
      /* When Saved sidebar is shown, use 2-column layout */
      .pb-wrap[data-cols="2"]{ grid-template-columns:minmax(0,1fr) 320px; }
      .pb-wrap[data-cols="1"]{ grid-template-columns:1fr; }
      @media (max-width:980px){ .pb-wrap{ grid-template-columns:1fr } }
      #advPhrasebook .pb-wrap{ grid-template-columns:1fr; } /* Phrasebook always full-width initially */
      .pb-saved{ border:1px solid var(--border); border-radius:12px; box-shadow:var(--shadow-soft); background:#fff; overflow:hidden; transition:transform .18s var(--ease), opacity .18s var(--ease) }
      .pb-head{ display:flex; align-items:center; justify-content:space-between; padding:16px 20px; border-bottom:1px solid #f0f0f3; background:#fafafa; }
      .pb-head strong{ font-size:14px; font-weight:600; color:#1a1a1a; }
      .pb-head .pb-search, .pb-head .pb-sort{ height:32px; padding:0 12px; border:1px solid #d1d5db; border-radius:8px; background:#fff; font-size:14px; font-family:inherit; transition:border-color .2s ease, box-shadow .2s ease; display:flex; align-items:center; line-height:1; }
      .pb-head .pb-search:focus, .pb-head .pb-sort:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-weak); }
      .pb-list{ max-height:60vh; overflow:auto; padding:4px 4px }
      .pb-item{ display:flex; justify-content:space-between; align-items:center; padding:16px 20px; border-top:1px solid #f0f0f3; gap:12px; transition:background .15s ease; }
      .pb-item:hover{ background:#f8f9fa; }
      .pb-item:first-child{ border-top:none }
      .pb-meta{ font-size:12px; color:#6b7280; font-weight:400; }
      .pb-star{ border:1px solid #e5e7eb; background:#fff; border-radius:8px; padding:8px 12px; cursor:pointer; font-size:12px; font-weight:500; color:#374151; transition:all .15s ease; }
      .pb-star:hover{ border-color:#d1d5db; background:#f9fafb; transform:translateY(-1px); }
      .pb-empty{ padding:20px; color:#6b7280; font-size:14px; text-align:center; background:#f8f9fa; border-radius:8px; margin:12px 0; }

      /* Slide-open affordance for small screens */
      .pb-saved.is-hidden{ opacity:0; pointer-events:none; }
      .pb-saved{ opacity:1; }

      /* Brand save animation */
      .flash-save{ animation:flash 900ms var(--ease) 1 }
      @keyframes flash{ 0%{box-shadow:0 0 0 0 rgba(0,122,255,.35)} 100%{box-shadow:0 0 0 0 transparent} }

      /* Character limit indicator */
      .char-limit-indicator {
        display: flex;
        align-items: center;
        padding: 6px 12px;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 500;
        color: #64748b;
        transition: all 0.2s var(--ease);
        min-width: 120px;
      }
      
      .char-limit-indicator.warning {
        background: #fef3c7;
        border-color: #f59e0b;
        color: #92400e;
      }
      
      .char-limit-indicator.danger {
        background: #fee2e2;
        border-color: #ef4444;
        color: #dc2626;
      }
      
      .char-limit-content {
        display: flex;
        flex-direction: column;
        gap: 4px;
        width: 100%;
      }
      
      .char-limit-text {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 11px;
        font-weight: 600;
        line-height: 1;
      }
      
      .char-limit-bar {
        width: 100%;
        height: 3px;
        background: #e2e8f0;
        border-radius: 2px;
        overflow: hidden;
      }
      
      .char-limit-progress {
        height: 100%;
        background: var(--accent);
        border-radius: 2px;
        transition: all 0.3s var(--ease);
        transform-origin: left;
        width: 0%;
      }
      
      .char-limit-indicator.warning .char-limit-progress {
        background: #f59e0b;
      }
      
      .char-limit-indicator.danger .char-limit-progress {
        background: #ef4444;
        animation: pulse-danger 2s infinite;
      }
      
      @keyframes pulse-danger {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }
      
      /* Responsive adjustments */
      @media (max-width: 768px) {
        .char-limit-indicator {
          min-width: 100px;
          padding: 4px 8px;
        }
        
        .char-limit-text {
          font-size: 10px;
        }
        
        .char-limit-bar {
          height: 2px;
        }
      }

      /* Prevent accidental browser selection handle from covering bubble on mobile */
      @media (pointer:coarse){
        .save-bubble{ transform:translate(-50%,-2px) scale(1) }
      }
    `;
    const st=document.createElement('style'); st.id='globalEnhanceCSS'; st.textContent=css; document.head.appendChild(st);
  }

  /* ---------- Toolbar buttons ---------- */
  const SPARKLE_SVG = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.75" aria-hidden="true"><path d="M12 3l2.2 4.6L19 10l-4.6 2.2L12 17l-2.2-4.8L5 10l4.8-2.4L12 3z"></path></svg>';
  const WRENCH_SVG = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.8"><path d="M21 3l-6 6M3 21l6-6M3 3l6 6M21 21l-6-6"></path></svg>';

  function injectBrandButton(){
    const tb=document.querySelector('.toolbar'); if(!tb || document.getElementById('brandBtn')) return;
    const btn=document.createElement('button');
    btn.id='brandBtn';
    btn.className='btn face-btn';
    btn.title='Brand Kit';
    btn.innerHTML = SPARKLE_SVG + '<span>Brand Kit</span>';
    btn.addEventListener('click',openBrandOverlay);
    tb.insertBefore(btn, tb.querySelector('#addTextTabBtn')||null);
    ensureBrandOverlay();
    // Hover blue accent like History
    btn.addEventListener('mouseenter',()=>{ btn.style.color='var(--accent)'; btn.style.borderColor='var(--accent)'; btn.style.boxShadow='0 4px 18px rgba(0,0,0,.12), 0 0 0 2px var(--accent-weak)'; });
    btn.addEventListener('mouseleave',()=>{ btn.style.color=''; btn.style.borderColor=''; btn.style.boxShadow=''; });
  }

  function injectAdvancedButton(){
    const tb=document.querySelector('.toolbar'); if(!tb || document.getElementById('advBtn')) return;
    const btn=document.createElement('button');
    btn.id='advBtn';
    btn.className='btn face-btn';
    btn.title='Advanced Tools (Glossary, Phrasebook)';
    btn.innerHTML = WRENCH_SVG + '<span>Advanced Tools</span>';
    btn.addEventListener('click',openAdvancedOverlay);
    tb.insertBefore(btn, tb.querySelector('#addTextTabBtn')||null);
    ensureAdvancedOverlay();
    // Hover blue accent like History
    btn.addEventListener('mouseenter',()=>{ btn.style.color='var(--accent)'; btn.style.borderColor='var(--accent)'; btn.style.boxShadow='0 4px 18px rgba(0,0,0,.12), 0 0 0 2px var(--accent-weak)'; });
    btn.addEventListener('mouseleave',()=>{ btn.style.color=''; btn.style.borderColor=''; btn.style.boxShadow=''; });
  }

    /* ---------- Brand overlay (standalone) ---------- */
  function ensureBrandOverlay(){
    if(document.getElementById('brandOverlay')) return;

    const wrap=document.createElement('div');
    wrap.id='brandOverlay';
    wrap.className='lang-overlay';
    wrap.setAttribute('role','dialog');
    wrap.setAttribute('aria-modal','true');
    wrap.setAttribute('aria-hidden','true');

    wrap.innerHTML = `
      <div class="lang-sheet" role="document">
        <div class="lang-head">
          <div class="lang-title" style="font-size:18px;font-weight:700;color:#1a1a1a">Brand Kit</div>
          <div style="display:flex;gap:8px">
            <button class="lang-close" id="brandCloseBtn" aria-label="Close" style="font-size:16px;color:#6b7280;padding:8px 10px">✕</button>
          </div>
        </div>

        <div class="brand-container">
          <!-- Top Section: Brand Name + Toggle -->
          <div class="brand-top-section">
            <div class="brand-name-section">
              <label class="brand-section-label">Brand names</label>
              <input id="bpName" class="brand-input" type="text" placeholder="">
            </div>
            <div class="brand-toggle-section">
              <button id="brandToggle" class="brand-toggle" type="button"></button>
              <span class="brand-toggle-label">Brand Injection On/Off</span>
            </div>
          </div>

          <!-- Tones Section -->
          <div class="brand-tones-section">
            <label class="brand-section-label">Tones</label>
            <div class="tones-grid" id="bpTones"></div>
          </div>

          <!-- Bottom Grid -->
          <div class="brand-bottom-grid">
            <div>
              <label class="brand-section-label">Target Audience</label>
              <textarea id="bpAudience" class="brand-textarea" rows="6" placeholder="Who are you writing for? (e.g., new customers, developers, parents, executives)"></textarea>
            </div>
            <div>
              <label class="brand-section-label">Brand Examples</label>
              <textarea id="bpExamples" class="brand-textarea" rows="6" placeholder="Share a few brand-perfect example sentences that capture your voice and style"></textarea>
            </div>
            <div>
              <label class="brand-section-label">Things to Avoid</label>
              <textarea id="bpAvoid" class="brand-textarea" rows="6" placeholder="Words, phrases, or tones to avoid (e.g., jargon, overpromises, corporate speak)"></textarea>
            </div>
          </div>

          <!-- Footer -->
          <div class="brand-footer">
            <button class="mini" id="bpReset">Reset</button>
            <button class="mini primary" id="bpSave">Save</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(wrap);

    // Close/open
    const close=()=>{wrap.classList.remove('show'); wrap.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',onKey)};
    const onKey=e=>{if(e.key==='Escape') close()};
    wrap.querySelector('#brandCloseBtn').addEventListener('click',close);
    wrap.addEventListener('click',e=>{ if(e.target.id==='brandOverlay') close(); });

    // Populate tones in grid layout
    const tones=['Friendly','Clear','Professional','Premium','Warm','Confident','Playful','Minimalist','Bold','Humble'];
    const toneWrap=wrap.querySelector('#bpTones');
    tones.forEach(tok=>{
      const el=document.createElement('button');
      el.className='tone-chip'; el.type='button'; el.textContent=tok; el.dataset.val=tok;
      el.addEventListener('click',()=>{
        el.classList.toggle('active');
      });
      toneWrap.appendChild(el);
    });

    // Brand toggle functionality
    const brandToggle = wrap.querySelector('#brandToggle');
    const brandToggleLabel = wrap.querySelector('.brand-toggle-label');
    let brandEnabled = readJSON('brandEnabled:v1', false);
    
    function updateBrandToggle(enabled) {
      brandEnabled = enabled;
      brandToggle.classList.toggle('active', enabled);
      brandToggleLabel.textContent = enabled ? 'Brand Injection On' : 'Brand Injection Off';
      writeJSON('brandEnabled:v1', enabled);
    }
    
    updateBrandToggle(brandEnabled);
    brandToggle.addEventListener('click', () => {
      updateBrandToggle(!brandEnabled);
    });



    // Restore
    const b=readJSON(BRAND_KEY, defBrand);
    wrap.querySelector('#bpName').value=b.name||'';
    wrap.querySelector('#bpAudience').value=b.audience||'';
    wrap.querySelector('#bpAvoid').value=b.dontList||'';
    wrap.querySelector('#bpExamples').value=b.examples||'';
    (b.tone||[]).forEach(t=>{
      const chip = toneWrap.querySelector(`[data-val="${t}"]`);
      if(chip) chip.classList.add('active');
    });

    // Save/reset
    wrap.querySelector('#bpSave').addEventListener('click', async (e)=>{
      const btn = e.currentTarget;
      const next={
        name: wrap.querySelector('#bpName').value.trim(),
        tone: Array.from(toneWrap.querySelectorAll('.tone-chip.active')).map(x=>x.dataset.val),
        audience: wrap.querySelector('#bpAudience').value.trim(),
        dontList: wrap.querySelector('#bpAvoid').value.trim(),
        examples: wrap.querySelector('#bpExamples').value.trim(),
        enabled: brandEnabled
      };
      // Persist locally
      writeJSON(BRAND_KEY,next);
      // Optimistic flash
      if (btn) { btn.classList.add('flash-save'); btn.textContent='Saved ✓'; }
      setTimeout(()=>{ if(btn && btn.classList){ btn.classList.remove('flash-save'); btn.textContent='Save'; } },900);

      // Sync to server (upsert first kit for this user)
      try{
        const headers = { 'Content-Type':'application/json' };
        const token = localStorage.getItem('authToken');
        const guestId = localStorage.getItem('guestId');
        
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        } else if (guestId) {
          headers['X-Guest-ID'] = guestId;
        }
        const payload = {
          name: next.name || 'My Brand',
          tone: next.tone || [],
          forbidden_words: (next.dontList||'').split(/[\n,]+/).map(s=>s.trim()).filter(Boolean),
          style_notes: JSON.stringify({ audience: next.audience||'', examples: next.examples||'', enabled: !!next.enabled })
        };
        const list = await fetch('/api/brand-kits', { headers });
        if (list.ok){
          const data = await list.json();
          const exist = (data.items||[])[0];
          if (exist && exist.id){
            await fetch(`/api/brand-kits/${exist.id}`, { method:'PUT', headers, body: JSON.stringify(payload) });
          } else {
            await fetch('/api/brand-kits', { method:'POST', headers, body: JSON.stringify(payload) });
          }
        }
      }catch(err){ console.warn('Brand kit sync failed', err); }
    });
    wrap.querySelector('#bpReset').addEventListener('click',()=>{
      // Clear all form fields
      wrap.querySelector('#bpName').value = '';
      wrap.querySelector('#bpAudience').value = '';
      wrap.querySelector('#bpAvoid').value = '';
      wrap.querySelector('#bpExamples').value = '';
      
      // Unselect all tone chips
      toneWrap.querySelectorAll('.tone-chip.active').forEach(chip => {
        chip.classList.remove('active');
      });
      
      // Reset toggle to disabled (default)
      updateBrandToggle(false);
      
      // Clear stored data
      writeJSON(BRAND_KEY, defBrand());
      writeJSON('brandEnabled:v1', false);
      
      showToast('Brand kit reset');
    });
  }

  function openBrandOverlay(){
    const ov=document.getElementById('brandOverlay'); if(!ov) return;
    ov.classList.add('show'); ov.setAttribute('aria-hidden','false');
    const onKey=e=>{if(e.key==='Escape'){ ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',onKey); }};
    document.addEventListener('keydown',onKey);
  }

  /* ---------- Advanced Tools overlay (Glossary + Phrasebook Saved) ---------- */
  function ensureAdvancedOverlay(){
    if(document.getElementById('advOverlay')) return;

    const wrap=document.createElement('div');
    wrap.id='advOverlay';
    wrap.className='lang-overlay';
    wrap.setAttribute('role','dialog');
    wrap.setAttribute('aria-modal','true');
    wrap.setAttribute('aria-hidden','true');

    wrap.innerHTML=`
      <div class="lang-sheet" role="document" style="max-width:980px">
        <div class="lang-head">
          <div class="lang-title">Advanced Tools</div>
          <div style="display:flex;gap:8px">
            <button class="lang-close" id="advCloseBtn" aria-label="Close">✕</button>
          </div>
        </div>

        <div class="adv-tabs">
          <button class="adv-tab active" data-pane="advGlossary">Glossary</button>
          <button class="adv-tab" data-pane="advPhrasebook">Phrasebook</button>
        </div>

        <div class="lang-grid" id="advGrid">
          <!-- Glossary (with Saved sidebar) -->
          <div class="adv-pane active" id="advGlossary">
            <div class="pb-wrap" data-cols="1">
              <div>
                <div class="bp-toolbar">
                  <button class="mini" id="glAdd">Add row</button>
                  <button class="mini" id="glImport">Import CSV/TSV/TMX</button>
                  <input type="file" id="glFile" accept=".csv,.tsv,.txt,.tmx" style="display:none">
                  <button class="mini" id="glClear">Clear</button>

                  <!-- ON/OFF toggle -->
                  <div class="gl-toggle" title="Enable/disable glossary rules">
                    <div class="gl-switch" id="glSwitch"></div>
                    <span class="gl-label" id="glSwitchLabel">Glossary On</span>
                  </div>

                  <div style="font-size:13px; color:#6b7280; font-weight:400;">Lock terms for consistent terminology.</div>
                </div>
                <div class="bp-table" id="glTableHost" style="margin-top:20px;">
                  <table id="glTable">
                    <thead>
                      <tr>
                        <th style="width:25%">Source term</th>
                        <th style="width:25%">Preferred translation</th>
                        <th style="width:20%">Flags</th>
                        <th style="width:30%">Notes</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:16px;padding:8px 16px;background:#f8f9fa;border-radius:8px;">
                  <div id="glStats" style="font-size:13px; color:#6b7280; font-weight:400;">0 terms</div>
                  <div style="font-size:13px; color:#6b7280; font-weight:400;text-align:right;line-height:1.4;">Tip: leave "Preferred translation" blank + lock → keep product names untranslated.</div>
                </div>
              </div>

              <!-- Minimal saved sidebar (shared with Phrasebook) -->
              <div class="pb-saved is-hidden" data-scope="glossary">
                <div class="pb-head">
                  <div style="display:flex;align-items:center;gap:8px"><strong>Saved</strong></div>
                  <div style="display:flex;gap:8px">
                    <input class="pb-search" type="text" placeholder="Search saved…" style="border:1px solid var(--border);border-radius:10px">
                    <select class="pb-sort" style="border:1px solid var(--border);border-radius:10px">
                      <option value="new">Newest</option>
                      <option value="old">Oldest</option>
                      <option value="az">A → Z</option>
                      <option value="za">Z → A</option>
                    </select>
                  </div>
                </div>
                <div class="pb-list"></div>
              </div>
            </div>
          </div>

          <!-- Phrasebook (main + same Saved sidebar) -->
          <div class="adv-pane" id="advPhrasebook">
            <div class="pb-wrap" data-cols="1">
              <div class="pb-saved" data-scope="phrasebook" style="grid-column:1/-1">
                <div class="pb-head">
                  <div style="display:flex;align-items:center;gap:8px"><strong>Saved</strong></div>
                  <div style="display:flex;gap:8px">
                    <input class="pb-search" type="text" placeholder="Search saved…" style="border:1px solid var(--border);border-radius:10px">
                    <select class="pb-sort" style="border:1px solid var(--border);border-radius:10px">
                      <option value="new">Newest</option>
                      <option value="old">Oldest</option>
                      <option value="az">A → Z</option>
                      <option value="za">Z → A</option>
                    </select>
                  </div>
                </div>
                <div class="pb-list"></div>
              </div>
              <div id="pbHowTo" style="grid-column:1/-1;padding:16px 20px;background:#f8f9fa;border-radius:8px;margin-top:16px;">
                <div style="font-size:13px; color:#6b7280; font-weight:400; line-height:1.4;">
                  Tip: select text in the Result and click <strong style="color:#374151;">Save to Phrasebook</strong>. In Split View, it saves the paired source line automatically.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>`;
    document.body.appendChild(wrap);

    // helper: keep grid columns sane when Saved sidebar is shown/hidden
    function adjustPbWrapGrid(){
      document.querySelectorAll('#advOverlay .adv-pane .pb-wrap').forEach(w=>{
        const hasVisibleSidebar = !!w.querySelector('.pb-saved:not(.is-hidden)');
        w.setAttribute('data-cols', hasVisibleSidebar ? '2' : '1');
      });
    }

    // tabs
    wrap.querySelectorAll('.adv-tab').forEach(btn=>{
      btn.addEventListener('click',()=>{
        // Simple, fast tab switching
        wrap.querySelectorAll('.adv-tab').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        
        wrap.querySelectorAll('.adv-pane').forEach(p=>p.classList.remove('active','active-enter'));
        const targetPane = document.getElementById(btn.getAttribute('data-pane'));
        
        if(targetPane) {
          targetPane.classList.add('active');
        }

        // Handle sidebar visibility based on tab
        const isPhrasebook = btn.getAttribute('data-pane') === 'advPhrasebook';
        
        if(isPhrasebook) {
          // Show phrasebook sidebar
          document.querySelectorAll('#advGlossary .pb-saved').forEach(x=>x.classList.add('is-hidden'));
          document.querySelectorAll('#advPhrasebook .pb-saved').forEach(x=>x.classList.remove('is-hidden'));
        } else {
          // Hide all sidebars for glossary
          document.querySelectorAll('#advPhrasebook .pb-saved').forEach(x=>x.classList.add('is-hidden'));
          document.querySelectorAll('#advGlossary .pb-saved').forEach(x=>x.classList.add('is-hidden'));
        }
        
        // Adjust grid layout
        adjustPbWrapGrid();
      });
    });

    const close=()=>{wrap.classList.remove('show'); wrap.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',onKey)};
    const onKey=e=>{if(e.key==='Escape') close()};
    wrap.querySelector('#advCloseBtn').addEventListener('click',close);
    wrap.addEventListener('click',e=>{ if(e.target.id==='advOverlay') close(); });

    // Glossary ON/OFF switch
    const glSwitch = wrap.querySelector('#glSwitch');
    const glLabel = wrap.querySelector('#glSwitchLabel');
    const hostTable = wrap.querySelector('#glTableHost');

    function setGlUI(on){
      glSwitch.classList.toggle('on', !!on);
      glLabel.textContent = on ? 'Glossary On' : 'Glossary Off';
      hostTable.classList.toggle('is-disabled', !on);
      writeJSON(GLOSSARY_ENABLED_KEY, !!on);
    }
    setGlUI(readJSON(GLOSSARY_ENABLED_KEY, true)!==false);
    glSwitch.addEventListener('click',()=> setGlUI(!(glSwitch.classList.contains('on'))));

    // Glossary wire-up
    buildGlossaryTable();
    wrap.querySelector('#glImport').addEventListener('click',()=>wrap.querySelector('#glFile').click());
    wrap.querySelector('#glFile').addEventListener('change', async (e)=>{
      const file=e.target.files?.[0]; if(!file) return;
      try{
        const txt=await file.text();
        const list = parseTermsFromCSVorTMX(txt, file.name);
        const prev = readJSON(GLOSSARY_KEY, defGlossary);
        writeJSON(GLOSSARY_KEY, prev.concat(list));
        buildGlossaryTable(); showToast(`Imported ${list.length} terms`);
      }catch(err){ console.error(err); showToast('Failed to import glossary') }
      e.target.value='';
    });
    wrap.querySelector('#glClear').addEventListener('click',()=>{ writeJSON(GLOSSARY_KEY,defGlossary()); buildGlossaryTable(); });
    wrap.querySelector('#glAdd').addEventListener('click',()=>{ const cur=readJSON(GLOSSARY_KEY,defGlossary); cur.push({src:'',tgt:'',flags:{lock:true,case:'auto'},notes:''}); writeJSON(GLOSSARY_KEY,cur); buildGlossaryTable(true); });

    // Saved sidebars (both panes)
    setupPhrasebookSidebars();

    // initial layout
    adjustPbWrapGrid();
    buildGlossaryTable(); // Build glossary table on initial load
  }

  function openAdvancedOverlay(){
    const ov=document.getElementById('advOverlay'); if(!ov) return;
    ov.classList.add('show'); ov.setAttribute('aria-hidden','false');
    const onKey=e=>{if(e.key==='Escape'){ ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); document.removeEventListener('keydown',onKey); }};
    document.addEventListener('keydown',onKey);
    renderSavedPhrasebookAll();
    buildGlossaryTable(); // Ensure glossary table is built when overlay opens
    
    // Check which tab is currently active and set up the appropriate state
    const activeTab = ov.querySelector('.adv-tab.active');
    const isPhrasebookActive = activeTab && activeTab.getAttribute('data-pane') === 'advPhrasebook';
    
    if(isPhrasebookActive) {
      // If Phrasebook tab is active, show its sidebar and set 2-column layout
      ov.querySelectorAll('#advGlossary .pb-saved').forEach(x=>x.classList.add('is-hidden'));
      ov.querySelectorAll('#advPhrasebook .pb-saved').forEach(x=>x.classList.remove('is-hidden'));
      ov.querySelectorAll('#advPhrasebook .pb-wrap').forEach(w=>w.setAttribute('data-cols','2'));
    } else {
      // If Glossary tab is active (default), hide all sidebars and set single column
      ov.querySelectorAll('.pb-saved').forEach(x=>x.classList.add('is-hidden'));
      ov.querySelectorAll('.pb-wrap').forEach(w=>w.setAttribute('data-cols','1'));
    }
  }

  /* ---------- Glossary table ---------- */
  function buildGlossaryTable(focusLast=false){
    const tb=document.querySelector('#glTable tbody'); if(!tb) return;
    const rows=readJSON(GLOSSARY_KEY, defGlossary);
    tb.innerHTML = rows.length ? '' : `<tr><td colspan="4" class="pb-empty">No glossary terms yet</td></tr>`;
    rows.forEach((row,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td><input data-k="src" data-i="${i}" type="text" placeholder="Source term" value="${escapeHTML(row.src||'')}"></td>
        <td><input data-k="tgt" data-i="${i}" type="text" placeholder="Preferred translation" value="${escapeHTML(row.tgt||'')}"></td>
        <td>
          <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
            <select data-k="case" data-i="${i}">
              <option value="auto"${(row.flags?.case||'auto')==='auto'?' selected':''}>case:auto</option>
              <option value="exact"${(row.flags?.case||'auto')==='exact'?' selected':''}>case:exact</option>
              <option value="lower"${(row.flags?.case||'auto')==='lower'?' selected':''}>case:lower</option>
              <option value="upper"${(row.flags?.case||'auto')==='upper'?' selected':''}>case:upper</option>
              <option value="title"${(row.flags?.case||'auto')==='title'?' selected':''}>case:title</option>
            </select>
            <label style="display:inline-flex;gap:6px;align-items:center;font-size:12px">
              <input type="checkbox" data-k="lock" data-i="${i}" ${row.flags?.lock!==false?'checked':''}> lock
            </label>
          </div>
        </td>
        <td><input data-k="notes" data-i="${i}" type="text" placeholder="Notes" value="${escapeHTML(row.notes||'')}"></td>
      `;
      tb.appendChild(tr);
    });
    const save = ()=>{
      const cur = readJSON(GLOSSARY_KEY, defGlossary);
      tb.querySelectorAll('input,select').forEach(el=>{
        const i=Number(el.dataset.i), k=el.dataset.k;
        if(!Number.isFinite(i)||!cur[i]) return;
        if(k==='src'||k==='tgt'||k==='notes') cur[i][k]=el.value;
        if(k==='case'){cur[i].flags=cur[i].flags||{}; cur[i].flags.case=el.value;}
        if(k==='lock'){cur[i].flags=cur[i].flags||{}; cur[i].flags.lock=el.checked;}
      });
      writeJSON(GLOSSARY_KEY,cur);
      const stat=document.getElementById('glStats'); if(stat) stat.textContent = `${cur.length} term${cur.length!==1?'s':''}`;
    };
    tb.querySelectorAll('input,select').forEach(el=>el.addEventListener('input',debounce(save,150)));
    const stat=document.getElementById('glStats'); if(stat) stat.textContent = `${rows.length} term${rows.length!==1?'s':''}`;
    if(focusLast){
      const last=tb.querySelector('tr:last-child input[data-k="src"]'); last?.focus();
    }

    // reflect enabled state visually on first build
    const enabled = readJSON(GLOSSARY_ENABLED_KEY, true)!==false;
    document.getElementById('glTableHost')?.classList.toggle('is-disabled', !enabled);
  }

  /* ---------- CSV/TMX parsers (used by Glossary import) ---------- */
  function detectDelim(s){ return s.includes('\t') ? '\t' : ','; }
  function splitRow(line, delim){
    let out=[], cur='', q=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(q){
        if(ch==='"' && line[i+1]==='"'){ cur+='"'; i++; }
        else if(ch==='"'){ q=false; }
        else { cur+=ch; }
      }else{
        if(ch==='"'){ q=true; }
        else if(ch===delim){ out.push(cur); cur=''; }
        else { cur+=ch; }
      }
    }
    out.push(cur);
    return out.map(x=>x.trim());
  }
  function parsePairsCSVorTSV(text){
    const lines=String(text||'').split(/\r?\n/).filter(l=>l.trim().length);
    if(!lines.length) return [];
    const delim=detectDelim(lines[0]);
    const out=[];
    for(const line of lines){
      const cols=splitRow(line,delim);
      if(cols.length<2) continue;
      out.push({src:cols[0], tgt:cols[1], notes:cols[2]||''});
    }
    return out;
  }
  function parseTermsFromCSVorTMX(text, name){
    const fn=(name||'').toLowerCase();
    if(fn.endsWith('.tmx')){
      const pairs=[];
      const tuBlocks=String(text||'').split(/<\/tu>/i);
      for(const tu of tuBlocks){
        const segs = Array.from(tu.matchAll(/<tuv[^>]*?>\s*<seg>([\s\S]*?)<\/seg>\s*<\/tuv>/gi)).map(m=>m[1].replace(/<[^>]+>/g,'').trim());
        if(segs.length>=2){ pairs.push({src:segs[0], tgt:segs[1], flags:{lock:true,case:'auto'}, notes:''}); }
      }
      return pairs;
    }
    const rows=parsePairsCSVorTSV(text);
    return rows.map(r=>({src:r.src,tgt:r.tgt,flags:{lock:true,case:'auto'},notes:r.notes||''}));
  }

  /* ---------- Compose injections (Brand + Glossary only) ---------- */
  function composeInjections(){
    const brand = readJSON(BRAND_KEY, defBrand);
    const glossary = readJSON(GLOSSARY_KEY, defGlossary);
    const glossaryEnabled = readJSON(GLOSSARY_ENABLED_KEY, true)!==false;

    const parts=[];
    // Brand
    const tone = (brand.tone||[]).filter(Boolean).join(', ');
    const name = (brand.name||'').trim();
    if(tone || brand.audience || brand.doList || brand.dontList || brand.examples || name){
      parts.push(`[BRAND VOICE]
${name?`Brand: ${name}\n`:''}${tone?`Tone: ${tone}\n`:''}${brand.audience?`Audience: ${brand.audience}\n`:''}${brand.doList?`Do: ${brand.doList}\n`:''}${brand.dontList?`Don't: ${brand.dontList}\n`:''}${brand.examples?`Examples:\n${brand.examples}\n`:''}`.trim());
    }

    // Glossary (capped + only if enabled)
    if(glossaryEnabled){
      const TERMS_CAP = 500;
      const gl = (glossary||[]).filter(r=>r && (r.src||'').trim()).slice(0,TERMS_CAP);
      if(gl.length){
        const lines=gl.map(r=>{
          const src = r.src.trim();
          const tgt = (r.tgt||'').trim();
          const flags = r.flags||{};
          const f = [
            flags.lock!==false ? 'lock' : '',
            flags.case && flags.case!=='auto' ? `case:${flags.case}` : ''
          ].filter(Boolean).join('; ');
          return `${JSON.stringify(src)} => ${JSON.stringify(tgt)}${f?` [${f}]`:''}${r.notes?` // ${r.notes}`:''}`;
        });
        parts.push(`[GLOSSARY RULES]
- Treat mappings as preferred terms. If "lock" is set, use the target exactly.
- If target is empty and "lock" is set, keep the source term untranslated.
- Respect case hints (case:exact|lower|upper|title).
${lines.join('\n')}`);
      }
    }

    return parts.join('\n\n').trim();
  }

  /* ---------- Override runTextDoc/runSrtDoc to send injections ---------- */
  async function runTextDoc(d){
    const input=(d.text||'').trim();
    const srcSegs = segmentText(input);
    if(!srcSegs.length){ d.output=''; d.lastAlignedTgt=[]; return; }

    const injections = composeInjections();
    // Add authentication headers
    const headers = {'Content-Type':'application/json'};
    const token = localStorage.getItem('authToken');
    const guestId = localStorage.getItem('guestId');
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    } else if (guestId) {
      headers['X-Guest-ID'] = guestId;
    }
    
    setStatus('Localizing');
    const res=await fetch('/api/translate-batch',{
      method:'POST',
      headers: headers,
      body:JSON.stringify({
        items:srcSegs,
        mode:selectedMode,
        targetLanguage,
        subStyle:selectedSubStyle,
        rephrase,
        injections
      })
    });
    if(!res.ok) throw new Error('HTTP '+res.status);
    const data=await res.json();
    d.lastAlignedTgt = Array.isArray(data.items) ? data.items.map(s=>s||'') : [(data.result||'')];
    d.output = d.lastAlignedTgt.join('\n');
    setStatus('Localizing done');
    
    // Refresh usage after successful submission
    setTimeout(() => {
      if (window.updateCumulativeUsage) {
        window.updateCumulativeUsage();
      }
    }, 500);
    if($('#outputRich') && !$('#outputRich').classList.contains('is-hidden')){
      $('#outputRich').textContent = d.output; syncRichToHidden();
    }else{
      $('#outputText').value=d.output; autosizeTextarea($('#outputText'));
    }
    // Persist recall payload for this run (session-only)
    try{ const entry = makeHistoryEntryFromDoc(d); pushHistory(entry); }catch{}
    if(splitView) renderSegmentBoxes(d);
    updateSplitButton();
  }

  async function runSrtDoc(d){
    const items = (d.cues?.length?d.cues.map(c=>c.text):(d.text||'').split(/\r?\n/)).map(v=>(v||'').trim());
    const hasAny = items.some(v=>v.length);
    if(!hasAny){ d.output=''; d.srtTranslations = new Array(items.length).fill(''); return; }

    const injections = composeInjections();
              // Add authentication headers
          const headers = {'Content-Type':'application/json'};
          const token = localStorage.getItem('authToken');
          const guestId = localStorage.getItem('guestId');
          
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
          } else if (guestId) {
            headers['X-Guest-ID'] = guestId;
          }
          
          const res = await fetch('/api/translate-batch',{
            method:'POST',
            headers: headers,
            body:JSON.stringify({
              items,
              mode:selectedMode,
              targetLanguage,
              subStyle:selectedSubStyle,
              rephrase,
              injections
            })
          });
    if(!res.ok) throw new Error('HTTP '+res.status);
    const data = await res.json();
    d.srtTranslations = Array.isArray(data.items)? data.items : items;
    setStatus('Localizing done');
    d.output = d.srtTranslations.join('\n');
    $('#outputText').value = d.output;
    autosizeTextarea($('#outputText'));
    if(splitView) renderSrtBoxes(d);
    try{ const entry = makeHistoryEntryFromDoc(d); pushHistory(entry); }catch{}
    updateSplitButton();
  }

  /* ---------- Phrasebook (server-backed “Saved”) ---------- */
  async function pbAPI(path, method='GET', body=null){
    const headers={'Content-Type':'application/json','Cache-Control':'no-cache'};
    const token = localStorage.getItem('authToken');
    const guestId = localStorage.getItem('guestId');
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    } else if (guestId) {
      headers['X-Guest-ID'] = guestId;
    }
    const res = await fetch(path,{method,headers,body:body?JSON.stringify(body):undefined});
    if(!res.ok){
      let detail='';
      try{ detail = await res.text(); }catch{}
      console.error('Phrasebook API failure', method, path, res.status, detail);
      throw new Error('PB '+res.status);
    }
    return await res.json();
  }
  // Cache for phrasebook data to reduce server calls
  let phrasebookCache = null;
  let lastCacheTime = 0;
  const CACHE_DURATION = 1000; // 1 second cache
  
  async function pbLoad(forceRefresh = false){ 
    const now = Date.now();
    
    // Use cache if recent and not forcing refresh
    if (!forceRefresh && phrasebookCache && (now - lastCacheTime) < CACHE_DURATION) {
      console.log('📚 Using cached phrasebook data');
      return phrasebookCache;
    }
    
    try {
      const data = await pbAPI('/api/phrasebook','GET'); 
      const items = Array.isArray(data.items) ? data.items : [];
      
      // Update cache
      phrasebookCache = items;
      lastCacheTime = now;
      
      console.log('📚 Fresh phrasebook data loaded:', items.length, 'items');
      return items;
    } catch (error) {
      console.error('Failed to load phrasebook:', error);
      // Return cached data if available
      return phrasebookCache || [];
    }
  }
  async function pbAdd(item){ 
    // Optimistic insert for instant UI
    try {
      const optimisticId = item.id || ('pb_'+Date.now().toString(36)+Math.random().toString(36).slice(2));
      const optimisticItem = { ...item, id: optimisticId, createdAt: item.createdAt || Date.now() };
      if (!Array.isArray(phrasebookCache)) phrasebookCache = [];
      phrasebookCache.unshift(optimisticItem);
      lastCacheTime = Date.now();
      renderSavedPhrasebookAll(); // instant

      // Persist in background
      await pbAPI('/api/phrasebook/add','POST',{ item: optimisticItem }); 
      console.log('📚 Added to phrasebook:', optimisticItem.srcText, '→', optimisticItem.tgtText);

      // Reconcile with server truth (dedupe by id)
      const serverItems = await pbLoad(true);
      const seen = new Set();
      const merged = [...serverItems, ...phrasebookCache].filter(it=>{
        const key = String(it.id||'') || `${(it.srcText||'').toLowerCase()}|${(it.tgtText||'').toLowerCase()}`;
        if(seen.has(key)) return false; seen.add(key); return true;
      }).sort((a,b)=> (b.createdAt||0)-(a.createdAt||0));
      phrasebookCache = merged; lastCacheTime = Date.now();
      renderSavedPhrasebookAll();
    } catch (error) {
      console.error('Failed to add to phrasebook:', error);
      // Rollback optimistic insert if it failed
      if (phrasebookCache && item?.id) {
        phrasebookCache = phrasebookCache.filter(x=>String(x.id)!==String(item.id));
        renderSavedPhrasebookAll();
      }
      throw error;
    }
  }
  async function pbDelete(id){ 
    try {
      console.log('📚 Starting delete for ID:', id);
      
      // Call server delete API
      await pbAPI('/api/phrasebook/delete','POST',{ id }); 
      console.log('📚 Server delete successful for:', id);
      
      // Force cache refresh and UI update
      phrasebookCache = null;
      lastCacheTime = 0;
      
      // Immediate UI refresh with fresh server data
      await pbLoad(true);
      await renderSavedPhrasebookAll();
      
      console.log('📚 Phrasebook delete completed - UI updated');
      window.showNotification('Removed', 'Phrase deleted from library', 'success');
      
    } catch (error) {
      console.error('Failed to delete from phrasebook:', error);
      window.showNotification('Delete Failed', 'Could not remove phrase', 'error');
      throw error;
    }
  }

  // Render helpers for multiple sidebars (Glossary + Phrasebook)
  function setupPhrasebookSidebars(){
    document.querySelectorAll('.pb-saved').forEach(box=>{
      const s=box.querySelector('.pb-search');
      const o=box.querySelector('.pb-sort');
      s?.addEventListener('input',()=>renderSavedPhrasebook(box));
      o?.addEventListener('change',()=>renderSavedPhrasebook(box));
    });
    renderSavedPhrasebookAll();
  }
  async function renderSavedPhrasebookAll(){
    const all = Array.from(document.querySelectorAll('.pb-saved'));
    await Promise.all(all.map(box=>renderSavedPhrasebook(box)));
  }
  async function renderSavedPhrasebook(hostBox){
    const host = hostBox || document.querySelector('.pb-saved'); if(!host) return;
    const listEl = host.querySelector('.pb-list'); if(!listEl) return;
    const q = (host.querySelector('.pb-search')?.value||'').toLowerCase();
    const sort = (host.querySelector('.pb-sort')?.value)||'new';

    let items=[];
    try{ 
      items = await pbLoad(); 
      console.log('📚 Phrasebook rendered:', items.length, 'items');
    }catch(e){ 
      console.error('Phrasebook load error:', e); 
      items = []; // Fallback to empty array
    }
    items = items.filter(it=>{
      if(!q) return true;
      const s = `${it.srcText} ${it.tgtText} ${it.srcLang} ${it.tgtLang}`.toLowerCase();
      return s.includes(q);
    });
    items.sort((a,b)=>{
      if(sort==='new') return (b.createdAt||0)-(a.createdAt||0);
      if(sort==='old') return (a.createdAt||0)-(b.createdAt||0);
      const A=(a.tgtText||'').toLowerCase(), B=(b.tgtText||'').toLowerCase();
      if(sort==='az') return A.localeCompare(B);
      if(sort==='za') return B.localeCompare(A);
      return 0;
    });

    if(!items.length){ listEl.innerHTML = `<div class="pb-empty">Nothing saved yet. Select text in the Result and click “Save to Phrasebook”.</div>`; return; }

    listEl.innerHTML = items.map(it=>{
      const dir = `${escapeHTML(it.srcLang||'Auto')} → ${escapeHTML(it.tgtLang||'')}`;
      const when = new Date(it.createdAt||Date.now()).toLocaleString();
      return `<div class="pb-item" data-id="${it.id}">
        <div style="min-width:0">
          <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHTML(it.tgtText||'')}</div>
          <div class="pb-meta" title="${escapeHTML(it.srcText||'')}">${escapeHTML(it.srcText||'')}</div>
          <div class="pb-meta">${dir} · ${when}</div>
        </div>
        <button class="pb-star" title="Remove">★</button>
      </div>`;
    }).join('');

    listEl.querySelectorAll('.pb-item .pb-star').forEach(btn=>{
      btn.addEventListener('click',async (e)=>{
        e.preventDefault();
        e.stopPropagation();
        
        const itemElement = e.currentTarget.closest('.pb-item');
        const id = itemElement?.dataset?.id;
        
        if(!id) {
          console.error('📚 No ID found for delete button');
          return;
        }
        
        console.log('📚 Delete button clicked for ID:', id);
        
        // Optimistic UI: remove immediately
        if (phrasebookCache) {
          phrasebookCache = phrasebookCache.filter(x=>String(x.id)!==String(id));
        }
        itemElement?.remove();
        
        // Keep list tidy while server call happens
        if (listEl.childElementCount===0) {
          renderSavedPhrasebook(host);
        }
        
        try{ 
          await pbDelete(id); 
          console.log('📚 Delete operation completed successfully');
        }catch(error){
          // On failure, force reload
          await pbLoad(true);
          await renderSavedPhrasebookAll();
          console.error('Delete failed:', error);
        }
      });
    });
  }

  /* ---------- Save-selection bubble (instant show, refine in background) ---------- */
  let saveBubble=null, saveBubbleHideT=null;
  function ensureSaveBubble(){
    if(saveBubble) return saveBubble;
    const el=document.createElement('div');
    el.className='save-bubble';
    el.innerHTML=`<span class="ok">Saved ✓</span><span class="label">Save to Phrasebook</span><button class="act">Add</button>`;
    document.body.appendChild(el);
    el.querySelector('.act').addEventListener('click', onSaveBubbleCommit);
    return (saveBubble=el);
  }
  function clamp(n,lo,hi){ return Math.max(lo, Math.min(hi, n)); }
  function placeBubbleAtRect(r){
    const vpTop = window.scrollY;
    const centerX = window.scrollX + r.left + r.width/2;
    const x = clamp(centerX, 80, document.documentElement.clientWidth - 80);
    const roomAbove = r.top;
    const top = (roomAbove > 64) ? (vpTop + r.top - 12) : (vpTop + r.bottom + 12);
    return { x, y: top };
  }
  function showSaveBubbleAtRect(r, payload){
    ensureSaveBubble();
    saveBubble.dataset.payload = JSON.stringify(payload||{});
    const pos = placeBubbleAtRect(r);
    saveBubble.style.left = pos.x+'px';
    saveBubble.style.top = pos.y+'px';
    saveBubble.classList.remove('saved');
    saveBubble.classList.add('show');
    clearTimeout(saveBubbleHideT);
    saveBubbleHideT = setTimeout(()=>{ saveBubble.classList.remove('show'); }, 3000);
  }
  async function onSaveBubbleCommit(){
    if(!saveBubble) return;
    const data = JSON.parse(saveBubble.dataset.payload||'{}');
    try{
      await pbAdd({
        id:'pb_'+Date.now().toString(36)+Math.random().toString(36).slice(2),
        srcLang: data.srcLang || 'Auto',
        tgtLang: data.tgtLang || (targetLanguage || ''),
        srcText: data.srcText || '',
        tgtText: data.tgtText || '',
        createdAt: Date.now()
      });
      saveBubble.classList.add('saved');
      // Add to local cache immediately for instant UI update
      if (phrasebookCache) {
        phrasebookCache.unshift({
          id: 'pb_' + Date.now().toString(36) + Math.random().toString(36).slice(2),
          srcLang: data.srcLang || 'Auto',
          tgtLang: data.tgtLang || (targetLanguage || ''),
          srcText: data.srcText || '',
          tgtText: data.tgtText || '',
          createdAt: Date.now()
        });
        console.log('📚 Added to local cache for instant display');
      }
      
      // Immediate UI update without waiting for server
      renderSavedPhrasebookAll();
      console.log('📚 Phrasebook UI updated instantly');
    }catch(e){ console.error(e); showToast('Failed to save phrase'); }
  }
  function currentTargetLangLabel(){
    const lang=localStorage.getItem('uiLang')||DEFAULT_LANG;
    const label = langLabel(targetLanguage||'') || targetLanguage || '';
    return label || (LANG_LABELS[lang]?.English || 'English');
  }

  // ---- Alignment-based source-span finder (exact word/phrase) ----
  async function alignSrcForSelection(srcSeg='', tgtSeg='', selectedTgt=''){
    try{
      if(!srcSeg || !tgtSeg || !selectedTgt) return srcSeg;
      const res = await fetch('/api/align',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ src:srcSeg, tgt:tgtSeg, srcLang:'auto', tgtLang: currentTargetLangLabel() })
      });
      if(!res.ok) return srcSeg;
      const pairs = await res.json(); // [{src,tgt}]
      const needle = String(selectedTgt).toLowerCase();
      let best = null;
      let bestScore = -1;

      for(const p of (pairs||[])){
        const tgt = String(p.tgt||'');
        const tgtLc = tgt.toLowerCase();
        if(!tgt) continue;
        const contains = tgtLc.includes(needle);
        const overlap = contains ? Math.min(needle.length, tgt.length) : 0;
        const lenPenalty = Math.abs(tgt.length - needle.length) * -0.25;
        const score = (contains ? 5 : 0) + overlap + lenPenalty;
        if(score > bestScore){ bestScore=score; best=p; }
      }
      return (best && best.src) ? String(best.src) : srcSeg;
    }catch{ return srcSeg; }
  }

  function getSelectionRect(){
    const sel=window.getSelection();
    if(!sel || sel.rangeCount===0) return null;
    const r=sel.getRangeAt(0).getBoundingClientRect();
    if(!r || (!r.width && !r.height)) return null;
    return r;
  }

  // Locate the segment index + texts for current doc based on a target selection
  function findSegForSelectionInDoc(selectedText){
    const d = currentDoc(); if(!d) return { idx:-1, srcSeg:'', tgtSeg:'' };
    const srcSegs = d.isSrt ? (d.cues?.map(c=>c.text)||[]) : segmentText(d.text||'');
    let tgtSegs;
    if(d.isSrt){
      tgtSegs = Array.isArray(d.srtTranslations)? d.srtTranslations.slice() : (d.output||'').split(/\r?\n/);
    }else{
      tgtSegs = Array.isArray(d.lastAlignedTgt)&&d.lastAlignedTgt.length? d.lastAlignedTgt.slice() : alignToSource(d.output||'', srcSegs.length);
    }
    const idx = tgtSegs.findIndex(seg => (seg||'').toLowerCase().includes(String(selectedText||'').toLowerCase()));
    const srcSeg = idx>=0 ? (srcSegs[idx]||'') : (d.text||'');
    const tgtSeg = idx>=0 ? (tgtSegs[idx]||'') : (d.output||'');
    return { idx, srcSeg, tgtSeg };
  }

  // Show bubble immediately, refine the payload when alignment returns
  function showNowThenRefine(rect, srcSeg, tgtSeg, txt){
    const initial = { tgtText:txt, srcText:srcSeg||'', srcLang:'Auto', tgtLang: currentTargetLangLabel() };
    showSaveBubbleAtRect(rect, initial);
    alignSrcForSelection(srcSeg, tgtSeg, txt).then(refined=>{
      try{
        if(!saveBubble?.classList.contains('show')) return;
        const cur = JSON.parse(saveBubble.dataset.payload||'{}');
        // only update if the same selection is still active
        if((cur.tgtText||'')===txt){
          cur.srcText = refined || srcSeg || '';
          saveBubble.dataset.payload = JSON.stringify(cur);
        }
      }catch{}
    });
  }

  /* Wire selection listeners for: outputRich, outputText, split SRT & split non-SRT */
  function initSaveSelectionUI(){
    // Normal rich area
    const rich = document.getElementById('outputRich');
    if(rich){
      rich.addEventListener('mouseup', ()=>{
        const txt = (window.getSelection()?.toString()||'').trim();
        if(!txt) return;
        const r=getSelectionRect(); if(!r) return;
        const { srcSeg, tgtSeg } = findSegForSelectionInDoc(txt);
        showNowThenRefine(r, srcSeg, tgtSeg, txt);
      });
      // local prevention (still keep for safety)
      rich.addEventListener('contextmenu', e=> e.preventDefault());
    }

    // Fallback textarea
    const ta = document.getElementById('outputText');
    if(ta){
      ta.addEventListener('mouseup', ()=>{
        const s=ta.selectionStart, e=ta.selectionEnd;
        if(!ta.value || s===e) return;
        const txt = ta.value.slice(s,e).trim(); if(!txt) return;
        const { srcSeg, tgtSeg } = findSegForSelectionInDoc(txt);
        const rect = ta.getBoundingClientRect();
        const fakeRect = { left: rect.left + rect.width/2, width:0, top: rect.top + 10, bottom: rect.top + 22, height:12 };
        showNowThenRefine(fakeRect, srcSeg, tgtSeg, txt);
      });
      ta.addEventListener('contextmenu', e=> e.preventDefault());
    }

    // Split SRT textareas
    const split = document.getElementById('segTgtBox');
    if(split){
      split.addEventListener('mouseup', (e)=>{
        const el = e.target.closest('textarea[data-srt]'); if(!el) return;
        const s=el.selectionStart, oe=el.selectionEnd;
        if(s===oe) return;
        const txt = el.value.slice(s,oe).trim(); if(!txt) return;
        const idx = Number(el.getAttribute('data-srt')||0);
        const d=currentDoc(); if(!d) return;
        const srcTextSeg = (d.cues?.[idx]?.text) || '';
        const tgtSeg = el.value || '';
        const rect = el.getBoundingClientRect();
        const fakeRect = { left: rect.left + rect.width/2, width:0, top: rect.top + 6, bottom: rect.top + 18, height:12 };
        showNowThenRefine(fakeRect, srcTextSeg, tgtSeg, txt);
      });

      split.addEventListener('contextmenu', e=>{
        if(e.target.closest('textarea[data-srt]')) e.preventDefault();
      });
    }

    // Split non-SRT (plain divs)
    const tgtBox = document.getElementById('segTgtBox');
    if(tgtBox){
      tgtBox.addEventListener('mouseup', ()=>{
        const txt = (window.getSelection()?.toString()||'').trim();
        if(!txt) return;
        const r=getSelectionRect(); if(!r) return;
        const { srcSeg, tgtSeg } = findSegForSelectionInDoc(txt);
        showNowThenRefine(r, srcSeg, tgtSeg, txt);
      });

      tgtBox.addEventListener('contextmenu', e=> e.preventDefault());
    }

    // Global capture-level guard to suppress the Chrome context menu
    document.addEventListener('contextmenu', (e)=>{
      if(
        e.target.closest('#outputRich') ||
        e.target.closest('#outputText') ||
        e.target.closest('#segTgtBox') ||
        e.target.matches('textarea[data-srt]')
      ){
        e.preventDefault();
      }
    }, { capture:true });

    // Hide bubble on scroll or escape
    window.addEventListener('scroll', ()=>saveBubble?.classList.remove('show'), { passive:true });
    document.addEventListener('keydown', e=>{ if(e.key==='Escape') saveBubble?.classList.remove('show'); });
    document.addEventListener('click', e=>{
      if(saveBubble && !saveBubble.contains(e.target) && !e.target.closest('.save-bubble')) saveBubble.classList.remove('show');
    });
  }

  /* ---------- Tabs: enable drag-reorder ---------- */
  function initTabDnD(){
    const bar = document.getElementById('tabBar'); if(!bar) return;

    const setDraggable=()=>bar.querySelectorAll('.tab').forEach(el=>el.setAttribute('draggable','true'));
    setDraggable();
    new MutationObserver(setDraggable).observe(bar, { childList:true });

    let dragId=null;
    bar.addEventListener('dragstart',e=>{
      const t=e.target.closest('.tab'); if(!t) return;
      dragId=t.dataset.id; t.classList.add('dragging');
      e.dataTransfer.setData('text/plain', dragId);
      e.dataTransfer.effectAllowed='move';
    });
    bar.addEventListener('dragend',e=>{
      const t=e.target.closest('.tab'); if(t) t.classList.remove('dragging');
      bar.querySelectorAll('.drop-marker').forEach(x=>x.classList.remove('drop-marker'));
    });
    bar.addEventListener('dragover',e=>{
      if(!dragId) return;
      e.preventDefault();
      const over=e.target.closest('.tab'); if(!over || over.dataset.id===dragId) return;
      bar.querySelectorAll('.drop-marker').forEach(x=>x.classList.remove('drop-marker'));
      over.classList.add('drop-marker');
    });
    bar.addEventListener('drop',e=>{
      e.preventDefault();
      const over=e.target.closest('.tab'); if(!over) return;
      const targetId = over.dataset.id;
      bar.querySelectorAll('.drop-marker').forEach(x=>x.classList.remove('drop-marker'));
      if(!dragId || dragId===targetId) return;

      const from = docs.findIndex(d=>d.id===dragId);
      const to = docs.findIndex(d=>d.id===targetId);
      if(from<0 || to<0) return;
      const [moved]=docs.splice(from,1);
      docs.splice(to,0,moved);
      renderTabs(); // re-render reflect order
    });
  }

  /* ---------- Boot ---------- */
  document.addEventListener('DOMContentLoaded',()=>{
    ensureGlobalUIStyles();
    injectBrandButton();
    injectAdvancedButton();
    initSaveSelectionUI();
    initTabDnD();
    
    // Initialize the original dropzone functionality (this was missing!)
    initDropzone();
    
    // Setup quick login button (development only) and prevent auto-login in production
    const isLocalHost = ['localhost','127.0.0.1','::1'].includes(location.hostname);
    const quickLoginBtn = document.getElementById('quickLoginBtn');
    const signInBtn = document.getElementById('signInBtn');
    const signOutBtnTop = document.getElementById('signOutBtnTop');
    const authModal = document.getElementById('authModal');
    const authClose = document.getElementById('authClose');
    const authForm = document.getElementById('authForm');
    const authName = document.getElementById('authName');
    const authEmail = document.getElementById('authEmail');
    const authPassword = document.getElementById('authPassword');
    const authMsg = document.getElementById('authMsg');
    const authTabLogin = document.getElementById('authTabLogin');
    const authTabRegister = document.getElementById('authTabRegister');

    // Quick login button only on localhost
    if (quickLoginBtn) {
      if (isLocalHost) {
        quickLoginBtn.style.display='';
        quickLoginBtn.addEventListener('click', async () => {
          try { await window.quickLogin(); }
          catch (error) { console.error('Login failed:', error); }
        });
      } else {
        quickLoginBtn.remove();
      }
    }

    function openAuth(mode){
      const isRegister = mode==='register';
      const authNameField = document.getElementById('authNameField');
      const authForm = document.getElementById('authForm');
      const checkEmailState = document.getElementById('checkEmailState');
      
      // Reset to form state
      authForm.style.display = '';
      checkEmailState.style.display = 'none';
      
      // Smooth transition for name field using CSS classes
      if (isRegister) {
        authNameField.classList.remove('hidden');
        authNameField.classList.add('visible');
      } else {
        authNameField.classList.remove('visible');
        authNameField.classList.add('hidden');
      }
      
      // Update tab states
      authTabLogin.classList.toggle('active', !isRegister);
      authTabRegister.classList.toggle('active', isRegister);
      
      // Update button and title
      authSubmit.textContent = isRegister ? 'Create account' : 'Sign in';
      document.querySelector('.modal-head h3').textContent = isRegister ? 'Create account' : 'Sign in';
      
      // Clear messages
      authMsg.textContent='';
      
      // Show modal
      authModal.style.display='flex';
      
      // Focus appropriate field with proper timing
      setTimeout(() => {
        if (isRegister) {
          authName.focus();
        } else {
          authEmail.focus();
        }
      }, isRegister ? 250 : 100); // Longer delay for register to allow field to appear
    }
    function closeAuth(){ authModal.style.display='none'; }
    if (signInBtn) signInBtn.addEventListener('click', async ()=>{
      try{
        openAuth('login');
      }catch(e){ console.error(e); }
    });

    // Google button inside modal
    const authGoogle = document.getElementById('authGoogle');
    if (authGoogle) authGoogle.addEventListener('click', async ()=>{
      try{
        // Close the auth modal before OAuth redirect
        closeAuth();
        
        const { data, error } = await supabase.auth.signInWithOAuth({ 
          provider: 'google', 
          options: { 
            queryParams: {
              access_type: 'offline',
              prompt: 'consent'
            }
          }
        });
        if (error) throw error;
        
        console.log('OAuth initiated successfully');
      }catch(e){ 
        console.error('Google sign-in failed', e); 
        showToast('Google sign-in failed: ' + (e.message || e)); 
      }
    });
    if (authClose) authClose.addEventListener('click', closeAuth);
    if (authTabLogin) authTabLogin.addEventListener('click', ()=>openAuth('login'));
    if (authTabRegister) authTabRegister.addEventListener('click', ()=>openAuth('register'));
    
    // Back to login button from check email state
    const backToLogin = document.getElementById('backToLogin');
    if (backToLogin) backToLogin.addEventListener('click', ()=>openAuth('login'));

    function showCheckEmailState(email) {
      const authForm = document.getElementById('authForm');
      const checkEmailState = document.getElementById('checkEmailState');
      
      // Hide form and show check email state
      authForm.style.display = 'none';
      checkEmailState.style.display = '';
      
      // Update title
      document.querySelector('.modal-head h3').textContent = 'Check your email';
    }

    if (authForm) authForm.addEventListener('submit', async (e)=>{
      e.preventDefault();
      authMsg.textContent='';
      const email = authEmail.value.trim();
      const password = authPassword.value;
      const authNameField = document.getElementById('authNameField');
      const isRegister = authNameField.classList.contains('visible');
      const name = isRegister ? authName.value.trim() : undefined;
      
      try{
        if (isRegister) {
          // Sign up flow
          const { data, error } = await supabase.auth.signUp({ 
            email, 
            password, 
            options: { 
              data: { name, tier: 'free' } 
            } 
          });
          if (error) throw error;
          
          // Show check email state
          showCheckEmailState(email);
          
          // Auto-transition back to login after 3 seconds
          setTimeout(() => {
            openAuth('login');
          }, 3000);
        } else {
          // Sign in flow
          const { data, error } = await supabase.auth.signInWithPassword({ email, password });
          if (error) throw error;
          closeAuth();
          location.reload();
        }
      }catch(err){ 
        authMsg.textContent = err.message || String(err); 
      }
    });

    // Render header auth state
    window.renderAuthHeader = function renderAuthHeader(){
      try{
        const hasToken = !!localStorage.getItem('authToken');
        const u = JSON.parse(localStorage.getItem('user')||'{}');
        const badge = document.getElementById('tierBadge');
        const isGuest = u.isGuest === true;
        
        console.log('🔍 renderAuthHeader:', { hasToken, user: u, isGuest });
        
        if (hasToken && !isGuest){
          // Authenticated user
          console.log('🔍 Rendering authenticated user UI, tier:', u.tier);
          if (signInBtn) signInBtn.style.display='none';
          if (signOutBtnTop) signOutBtnTop.style.display='inline-block';
          if (signOutBtnTop && u.tier) signOutBtnTop.title = `Tier: ${u.tier}`;
          if (badge){
            if (u.tier){ 
              badge.style.display='inline-block'; 
              badge.textContent = String(u.tier).toUpperCase();
              // Reset guest styling
              badge.style.background=''; 
              badge.style.color='';
              badge.style.borderColor='';
              badge.title = `Current tier: ${u.tier}`;
            }
            else { badge.style.display='none'; }
          }
        } else if (isGuest) {
          // Guest user
          if (signOutBtnTop) signOutBtnTop.style.display='none';
          if (signInBtn) {
            signInBtn.style.display='inline-block';
            signInBtn.textContent = 'Sign in';
            signInBtn.title = 'Sign in to unlock more features and save your work';
          }
          if (badge){
            badge.style.display='inline-block'; 
            badge.textContent = 'GUEST';
            badge.style.background='#f3f4f6'; 
            badge.style.color='#6b7280';
            badge.style.borderColor='#d1d5db';
            badge.title = 'Guest mode - Sign in to unlock more features';
          }
        } else {
          // No user at all (shouldn't happen with guest mode)
          if (signOutBtnTop) signOutBtnTop.style.display='none';
          if (signInBtn) signInBtn.style.display='inline-block';
          if (badge) badge.style.display='none';
        }
      }catch{}
    }
    renderAuthHeader();

    // Character limit system
    const TIER_LIMITS = {
      free: { maxInputSize: 1000, name: 'Free' },
      pro: { maxInputSize: 10000, name: 'Pro' },
      team: { maxInputSize: 50000, name: 'Team' },
      guest: { maxInputSize: 1000, name: 'Guest' }
    };

    function getTierLimit(tier) {
      return TIER_LIMITS[tier] || TIER_LIMITS.free;
    }

    async function updateCharacterLimit() {
      const user = JSON.parse(localStorage.getItem('user') || '{}');
      const tier = user.isGuest ? 'guest' : (user.tier || 'free');
      const tierConfig = window.getTierLimit ? window.getTierLimit(tier) : TIER_LIMITS[tier] || TIER_LIMITS.free;
      const indicator = document.getElementById('charLimitIndicator');
      const charLimitSpan = document.getElementById('charLimit');
      
      if (indicator && charLimitSpan) {
        charLimitSpan.textContent = tierConfig.maxInputSize.toLocaleString();
        indicator.style.display = 'flex';
        
        // Create detailed tooltip
        const upgradeInfo = user.isGuest 
          ? 'Sign in to unlock higher limits!'
          : tier === 'free' 
            ? 'Upgrade to Pro (10K chars) or Team (50K chars)'
            : tier === 'pro'
              ? 'Upgrade to Team for 50K characters'
              : 'You have the highest tier limits';
              
        indicator.title = `${tierConfig.name} tier: ${tierConfig.maxInputSize.toLocaleString()} character limit\n${upgradeInfo}`;
        
        // Add click handler for guests to open sign-in modal
        indicator.style.cursor = user.isGuest ? 'pointer' : 'default';
        indicator.onclick = user.isGuest ? () => {
          if (typeof openAuth === 'function') openAuth('login');
        } : null;
      }
      
      // Fetch and update cumulative usage
      await updateCumulativeUsage();
    }

    async function updateCumulativeUsage() {
      const charUsedSpan = document.getElementById('charUsed');
      const charProgress = document.getElementById('charProgress');
      const indicator = document.getElementById('charLimitIndicator');
      
      if (!charUsedSpan || !charProgress || !indicator) return;
      
      try {
        // Fetch current usage from backend
        const headers = {};
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        
        if (user.isGuest) {
          headers['X-Guest-ID'] = localStorage.getItem('guestId');
        } else {
          // Try to get Supabase session token
          const authToken = localStorage.getItem('authToken');
          if (authToken) {
            headers['Authorization'] = `Bearer ${authToken}`;
          } else {
            // Try to get Supabase session
            try {
              const supabaseSession = await supabase.auth.getSession();
              if (supabaseSession?.data?.session?.access_token) {
                headers['Authorization'] = `Bearer ${supabaseSession.data.session.access_token}`;
                console.log('🔑 Using Supabase session token for usage API');
              }
            } catch (e) {
              console.warn('Failed to get Supabase session:', e);
            }
          }
        }
        
        const response = await fetch('/api/usage/current', { headers });
        const usageData = await response.json();
        
        if (response.ok) {
          // Update display with cumulative usage
          charUsedSpan.textContent = usageData.used.toLocaleString();
          charProgress.style.width = usageData.percentage + '%';
          
          // Update styling based on usage
          indicator.classList.remove('warning', 'danger');
          
          if (usageData.percentage >= 100) {
            indicator.classList.add('danger');
          } else if (usageData.percentage >= 80) {
            indicator.classList.add('warning');
          }
          
          // Update tooltip with usage info
          const tierConfig = window.getTierLimit ? window.getTierLimit(usageData.tier) : TIER_LIMITS[usageData.tier] || TIER_LIMITS.free;
          const upgradeInfo = usageData.isGuest 
            ? 'Sign in with Google to unlock higher limits!'
            : usageData.tier === 'free' 
              ? 'Upgrade to Pro (10K chars) or Team (50K chars)'
              : usageData.tier === 'pro'
                ? 'Upgrade to Team for 50K characters'
                : 'You have the highest tier limits';
                
          indicator.title = `${tierConfig.name} tier: ${usageData.used.toLocaleString()} / ${usageData.limit.toLocaleString()} characters used this month\n${upgradeInfo}`;
          
          // Store current usage data for debugging
          window.currentUsageData = usageData;
          console.log('📊 Usage data updated:', usageData);
        } else {
          console.error('❌ Failed to fetch usage data:', response.status, await response.text());
        }
      } catch (error) {
        console.error('Failed to fetch usage data:', error);
        
        // Show error state instead of falling back to per-tab count
        const charUsedSpan = document.getElementById('charUsed');
        const charProgress = document.getElementById('charProgress');
        const indicator = document.getElementById('charLimitIndicator');
        
        if (charUsedSpan && charProgress && indicator) {
          charUsedSpan.textContent = '?';
          charProgress.style.width = '0%';
          indicator.classList.remove('warning', 'danger');
          
          // Update tooltip to show error
          const user = JSON.parse(localStorage.getItem('user') || '{}');
          const tier = user.isGuest ? 'guest' : (user.tier || 'free');
          const tierConfig = window.getTierLimit ? window.getTierLimit(tier) : TIER_LIMITS[tier] || TIER_LIMITS.free;
          
          indicator.title = `Failed to load usage data. Limit: ${tierConfig.maxInputSize.toLocaleString()} characters`;
        }
      }
    }

    function updateCurrentTabCharacterCount() {
      const inputText = document.getElementById('inputText');
      const charUsedSpan = document.getElementById('charUsed');
      const charProgress = document.getElementById('charProgress');
      const indicator = document.getElementById('charLimitIndicator');
      
      if (!inputText || !charUsedSpan || !charProgress || !indicator) return;
      
      const user = JSON.parse(localStorage.getItem('user') || '{}');
      const tier = user.isGuest ? 'guest' : (user.tier || 'free');
      const tierConfig = window.getTierLimit ? window.getTierLimit(tier) : TIER_LIMITS[tier] || TIER_LIMITS.free;
      const currentLength = inputText.value.length;
      const maxLength = tierConfig.maxInputSize;
      const percentage = Math.min((currentLength / maxLength) * 100, 100);
      
      // Update display
      charUsedSpan.textContent = currentLength.toLocaleString();
      charProgress.style.width = percentage + '%';
      
      // Update styling based on usage
      indicator.classList.remove('warning', 'danger');
      
      if (percentage >= 100) {
        indicator.classList.add('danger');
      } else if (percentage >= 80) {
        indicator.classList.add('warning');
      }
      
      // Return whether limit is exceeded
      return currentLength > maxLength;
    }

    // Alias for backward compatibility
    function updateCharacterCount() {
      return updateCumulativeUsage();
    }

    async function checkCharacterLimit(text) {
      try {
        // Fetch current usage to check against cumulative limit
        const headers = {};
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        
        if (user.isGuest) {
          headers['X-Guest-ID'] = localStorage.getItem('guestId');
        } else {
          // Try to get Supabase session token
          const authToken = localStorage.getItem('authToken');
          if (authToken) {
            headers['Authorization'] = `Bearer ${authToken}`;
          } else {
            // Try to get Supabase session
            try {
              const supabaseSession = await supabase.auth.getSession();
              if (supabaseSession?.data?.session?.access_token) {
                headers['Authorization'] = `Bearer ${supabaseSession.data.session.access_token}`;
              }
            } catch (e) {
              console.warn('Failed to get Supabase session:', e);
            }
          }
        }
        
        const response = await fetch('/api/usage/current', { headers });
        const usageData = await response.json();
        
        if (response.ok) {
          // Check if adding this text would exceed the limit
          const potentialUsage = usageData.used + text.length;
          return potentialUsage <= usageData.limit;
        }
      } catch (error) {
        console.error('Failed to check character limit:', error);
      }
      
      // Fallback to simple text length check
      const user = JSON.parse(localStorage.getItem('user') || '{}');
      const tier = user.isGuest ? 'guest' : (user.tier || 'free');
      const tierConfig = window.getTierLimit ? window.getTierLimit(tier) : TIER_LIMITS[tier] || TIER_LIMITS.free;
      return text.length <= tierConfig.maxInputSize;
    }

    // Initialize character limit system
    async function initCharacterLimits() {
      if (window.updateCharacterLimit) {
        await window.updateCharacterLimit();
      }
      
      // Add event listener to input text
      const inputText = document.getElementById('inputText');
      if (inputText) {
        inputText.addEventListener('input', () => {
          if (window.updateCharacterCount) window.updateCharacterCount();
        });
        inputText.addEventListener('paste', () => {
          setTimeout(() => {
            if (window.updateCharacterCount) window.updateCharacterCount();
          }, 10); // Delay to allow paste to complete
        });
      }
      
      // Update on user change
      const originalRenderAuthHeader = window.renderAuthHeader;
      window.renderAuthHeader = function() {
        originalRenderAuthHeader.apply(this, arguments);
        setTimeout(async () => {
          if (window.updateCharacterLimit) {
            await window.updateCharacterLimit();
          }
          if (window.updateCharacterCount) {
            await window.updateCharacterCount();
          }
        }, 100);
      };
    }

    // Make functions globally accessible
    window.updateCharacterLimit = updateCharacterLimit;
    window.updateCharacterCount = updateCharacterCount;
    window.updateCumulativeUsage = updateCumulativeUsage;
    window.updateCurrentTabCharacterCount = updateCurrentTabCharacterCount;
    window.checkCharacterLimit = checkCharacterLimit;
    window.getTierLimit = getTierLimit;

    // Initialize character limits when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initCharacterLimits);
    } else {
      initCharacterLimits();
    }

    // Complete auth state cleanup
    window.clearAuthState = function clearAuthState() {
      console.log('🧹 Clearing all auth state');
      localStorage.removeItem('authToken');
      localStorage.removeItem('user');
      localStorage.removeItem('guestId');
      sessionStorage.clear();
      // Initialize fresh guest mode
      window.initGuestMode();
      window.renderAuthHeader();
    }



    // Sign out (top button)
    if (signOutBtnTop) signOutBtnTop.addEventListener('click',async ()=>{
      try{ await supabase.auth.signOut(); }catch{}
      window.clearAuthState();
      location.reload();
    });

    // If a dev admin token leaked to production, clear it once
    if (!isLocalHost) {
      try {
        const u = JSON.parse(localStorage.getItem('user') || 'null');
        if (u && (u.email === 'admin@localhost' || /@localhost$/.test(u.email))) {
          localStorage.removeItem('authToken');
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          if (typeof openAuth==='function') openAuth('login');
        }
      } catch (e) {}
    }

    // Auto-login should only happen on localhost during development
    if (isLocalHost) {
      setTimeout(() => { if (window.autoLogin) { window.autoLogin(); } }, 1000);
    }
    // Don't auto-show login for guests - they can use the app freely
    // Only show login modal if explicitly requested
  });
</script>

<!-- Socket.IO for real-time job progress -->
<script src="/socket.io/socket.io.js"></script>

<!-- Enhanced UI features integrated directly -->

<!-- Initialize advanced features -->
<script>
  // Initialize WebSocket job tracking  
  if (typeof io !== 'undefined') {
    console.log('🌐 Initializing WebSocket job tracking...');
    
    window.jobSocket = io('/jobs', {
      transports: ['websocket', 'polling'],
      timeout: 20000
    });
    
    window.jobSocket.on('connect', () => {
      console.log('🌐 Real-time job progress connected');
    });
    
    window.jobSocket.on('job_progress', (data) => {
      console.log('📊 Job progress:', data.jobId, data.progress + '%');
      
      // Update UI if job progress element exists
      const progressElement = document.querySelector(`[data-job-id="${data.jobId}"]`);
      if (progressElement) {
        const progressBar = progressElement.querySelector('.job-progress-bar .job-progress-fill');
        if (progressBar) {
          progressBar.style.width = data.progress + '%';
        }
        
        const progressText = progressElement.querySelector('.progress-text');
        if (progressText) {
          progressText.textContent = `${data.progress}% - ${data.status || 'Processing...'}`;
        }
      }
    });
    
    window.jobSocket.on('job_complete', (data) => {
      console.log('✅ Job completed:', data.jobId);
      
      // Show completion notification
      if (window.showNotification) {
        window.showNotification('Translation Complete', 'Your translation job has finished successfully!', 'success');
      }
      
      // Update result in UI if available
      if (data.result && data.result.result) {
        const resultTextarea = document.getElementById('resultText');
        if (resultTextarea && resultTextarea.value.trim() === '') {
          resultTextarea.value = data.result.result;
          
          // Trigger existing result handling if available
          if (window.processTranslationResult) {
            window.processTranslationResult(data.result.result);
          }
        }
      }
      
      // Remove progress indicator after delay
      setTimeout(() => {
        const progressElement = document.querySelector(`[data-job-id="${data.jobId}"]`);
        if (progressElement) {
          progressElement.remove();
        }
      }, 3000);
    });
    
    window.jobSocket.on('job_failed', (data) => {
      console.log('❌ Job failed:', data.jobId, data.error);
      
      if (window.showNotification) {
        window.showNotification('Translation Failed', data.error || 'Translation job failed', 'error');
      }
      
      // Remove progress indicator after delay
      setTimeout(() => {
        const progressElement = document.querySelector(`[data-job-id="${data.jobId}"]`);
        if (progressElement) {
          progressElement.classList.add('failed');
          setTimeout(() => progressElement.remove(), 5000);
        }
      }, 1000);
    });
    
    window.jobSocket.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason);
    });
    
    window.jobSocket.on('connect_error', (error) => {
      console.warn('WebSocket connection error:', error.message);
    });
  } else {
    console.warn('Socket.IO not available - real-time features disabled');
  }
  
  // Enhanced UI features - integrate with existing functionality
  document.addEventListener('DOMContentLoaded', () => {
    console.log('🎨 Enhanced UI features ready');
    
    // Add enhanced visual feedback CSS if not already present
    if (!document.getElementById('enhanced-ui-styles')) {
      const style = document.createElement('style');
      style.id = 'enhanced-ui-styles';
      style.textContent = `
        .dropzone.drag {
          transform: scale(1.02);
          box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3) !important;
          border-color: #3b82f6 !important;
          background-color: rgba(59, 130, 246, 0.05) !important;
          transition: all 0.2s ease;
        }
        
        .dropzone {
          transition: all 0.2s ease;
        }
        
        .job-progress-container {
          position: fixed;
          bottom: 20px;
          right: 20px;
          background: white;
          border-radius: 8px;
          box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
          padding: 16px;
          min-width: 300px;
          z-index: 1000;
        }
        
        .job-progress-item {
          display: flex;
          align-items: center;
          margin-bottom: 8px;
          padding: 8px;
          border-radius: 6px;
          background: #f9fafb;
        }
        
        .job-progress-item.completed {
          background: #d1fae5;
          color: #065f46;
        }
        
        .job-progress-item.failed {
          background: #fee2e2;
          color: #991b1b;
        }
        
        .job-progress-bar {
          width: 100%;
          height: 4px;
          background: #e5e7eb;
          border-radius: 2px;
          overflow: hidden;
          margin-top: 4px;
        }
        
        .job-progress-fill {
          height: 100%;
          background: #3b82f6;
          width: 0%;
          transition: width 0.3s ease;
        }
        
        .notification {
          position: fixed;
          top: 20px;
          right: 20px;
          background: white;
          border-radius: 8px;
          box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
          border-left: 4px solid #3b82f6;
          padding: 16px;
          max-width: 400px;
          z-index: 10001;
          animation: slideInNotification 0.3s ease-out;
          margin-bottom: 8px;
        }
        
        /* Dynamic positioning handled by JavaScript */
        
        .notification-success { border-left-color: #10b981; }
        .notification-error { border-left-color: #ef4444; }
        .notification-warning { border-left-color: #f59e0b; }
        
        @keyframes slideInNotification {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        
        .notification-title {
          font-weight: 600;
          margin-bottom: 4px;
        }
        
        .notification-message {
          font-size: 14px;
          color: #6b7280;
        }
        
        .notification-close {
          background: none;
          border: none;
          font-size: 18px;
          cursor: pointer;
          color: #6b7280;
          float: right;
          margin-top: -4px;
        }
      `;
      document.head.appendChild(style);
    }
    
    console.log('✅ Enhanced UI styles loaded');
  });
  
  // Enhanced notification system with smart positioning
  window.showNotification = function(title, message, type = 'info') {
    // Calculate position based on existing notifications
    const existingNotifications = document.querySelectorAll('.notification');
    let topPosition = 20;
    
    // Stack notifications properly
    existingNotifications.forEach((notif, index) => {
      topPosition = Math.max(topPosition, parseInt(notif.style.top || '20') + notif.offsetHeight + 10);
    });
    
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.style.top = topPosition + 'px';
    notification.innerHTML = `
      <button class="notification-close">×</button>
      <div class="notification-title">${title}</div>
      <div class="notification-message">${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    // Move other notifications up when this one is removed
    const removeNotification = () => {
      notification.style.animation = 'slideInNotification 0.3s ease-out reverse';
      setTimeout(() => {
        notification.remove();
        // Recalculate positions of remaining notifications
        const remaining = document.querySelectorAll('.notification');
        remaining.forEach((notif, index) => {
          notif.style.top = (20 + (index * 90)) + 'px';
        });
      }, 300);
    };
    
    // Auto-remove with delay based on content length
    const delay = Math.max(3000, Math.min(8000, message.length * 50)); // 3-8 seconds based on message length
    setTimeout(removeNotification, delay);
    
    // Close button
    notification.querySelector('.notification-close').addEventListener('click', removeNotification);
  };
  
  // Quick authentication system
  window.quickLogin = async function() {
    try {
      const response = await fetch('/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          email: 'admin@localhost',
          password: 'admin123'
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        
        // Store token for future requests
        localStorage.setItem('authToken', data.token);
        localStorage.setItem('user', JSON.stringify(data.user));
        
        // Update UI
        const loginBtn = document.getElementById('quickLoginBtn');
        if (loginBtn) {
          loginBtn.textContent = '👑 ' + data.user.name;
          loginBtn.style.background = '#10b981';
          loginBtn.title = `Logged in as ${data.user.email} (${data.user.tier})`;
        }
        
        window.showNotification('Login Successful', `Welcome back, ${data.user.name}!`, 'success');
        return data;
      } else {
        const error = await response.json();
        throw new Error(error.error || 'Login failed');
      }
    } catch (error) {
      console.error('Quick login failed:', error);
      window.showNotification('Login Failed', error.message, 'error');
      throw error;
    }
  };
  
  // Auto-login on page load if no token
  window.autoLogin = async function() {
    const token = localStorage.getItem('authToken');
    if (!token) {
      try {
        console.log('🔑 No auth token found, attempting quick login...');
        await window.quickLogin();
      } catch (error) {
        console.log('Auto-login failed, manual login required');
      }
    } else {
      // Verify existing token
      try {
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        const loginBtn = document.getElementById('quickLoginBtn');
        if (loginBtn && user.name) {
          loginBtn.textContent = '👑 ' + user.name;
          loginBtn.style.background = '#10b981';
          loginBtn.title = `Logged in as ${user.email} (${user.tier})`;
        }
        console.log('✅ Already authenticated as:', user.email);
      } catch (error) {
        console.log('Invalid stored token, clearing...');
        localStorage.removeItem('authToken');
        localStorage.removeItem('user');
      }
    }
  };
  
  // Job progress tracking helper
  window.trackJobProgress = function(jobId, jobName) {
    if (window.jobSocket) {
      window.jobSocket.emit('subscribe_job', jobId);
      
      // Create progress indicator
      let progressContainer = document.getElementById('job-progress-container');
      if (!progressContainer) {
        progressContainer = document.createElement('div');
        progressContainer.id = 'job-progress-container';
        progressContainer.className = 'job-progress-container';
        document.body.appendChild(progressContainer);
      }
      
      const progressElement = document.createElement('div');
      progressElement.id = `job-progress-${jobId}`;
      progressElement.className = 'job-progress-item';
      progressElement.setAttribute('data-job-id', jobId);
      progressElement.innerHTML = `
        <div class="job-info">
          <div class="job-name">${jobName}</div>
          <div class="progress-text">Starting...</div>
        </div>
        <div class="job-progress-bar">
          <div class="job-progress-fill" style="width: 0%"></div>
        </div>
      `;
      
      progressContainer.appendChild(progressElement);
      return progressElement;
    }
    return null;
  };
</script>

</body>
</html>